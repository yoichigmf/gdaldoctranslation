# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-23 04:43+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/tutorials/raster_driver_tut.rst:5
msgid "Raster driver implementation tutorial"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:10
msgid "Overall Approach"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:12
msgid ""
"In general new formats are added to GDAL by implementing format specific "
"drivers as subclasses of :cpp:class:`GDALDataset`, and band accessors as "
"subclasses of :cpp:class:`GDALRasterBand`. As well, a "
":cpp:class:`GDALDriver` instance is created for the format, and "
"registered with the :cpp:class:`GDALDriverManager`, to ensure that the "
"system knows about the format."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:14
msgid ""
"This tutorial will start with implementing a simple read-only driver "
"(based on the JDEM driver), and then proceed to utilizing the "
"RawRasterBand helper class, implementing creatable and updatable formats,"
" and some esoteric issues."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:16
msgid ""
"It is strongly advised that the :ref:`raster_data_model` be reviewed and "
"understood before attempting to implement a GDAL driver."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:19
msgid "Implementing the Dataset"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:21
msgid ""
"We will start showing minimal implementation of a read-only driver for "
"the Japanese DEM format (:source_file:`frmts/jdem/jdemdataset.cpp`). "
"First we declare a format specific dataset class, JDEMDataset in this "
"case."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:44
msgid ""
"In general we provide capabilities for a driver, by overriding the "
"various virtual methods on the GDALDataset base class. However, the "
"Open() method is special. This is not a virtual method on the base class,"
" and we will need a freestanding function for this operation, so we "
"declare it static. Implementing it as a method in the JDEMDataset class "
"is convenient because we have privileged access to modify the contents of"
" the database object."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:46
msgid "The open method itself may look something like this:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:102
msgid ""
"The first step in any database Open function is to verify that the file "
"being passed is in fact of the type this driver is for.  It is important "
"to realize that each driver's Open function is called in turn till one "
"succeeds.  Drivers must quietly return nullptr if the passed file is not "
"of their format.  They should only produce an error if the file does "
"appear to be of their supported format, but is for some reason "
"unsupported or corrupt. The information on the file to be opened is "
"passed in contained in a GDALOpenInfo object.  The GDALOpenInfo includes "
"the following public data members:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:124
msgid ""
"The driver can inspect these to establish if the file is supported. If "
"the `pszFilename` refers to an object in the file system, the `bStatOK` "
"flag will be set to TRUE. As well, if the file was successfully opened, "
"the first kilobyte or so is read in, and put in pabyHeader, with the "
"exact size in `nHeaderBytes`."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:126
msgid ""
"In this typical testing example it is verified that the file was "
"successfully opened, that we have at least enough header information to "
"perform our test, and that various parts of the header are as expected "
"for this format. In this case, there are no magic numbers for JDEM format"
" so we check various date fields to ensure they have reasonable century "
"values. If the test fails, we quietly return NULL indicating this file "
"isn't of our supported format."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:128
msgid "The identification is in fact delegated to a Identify() static function :"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:173
msgid ""
"It is important to make the \"is this my format\" test as stringent as "
"possible.  In this particular case, we check that dates are in the 19th "
"or 20th centry, but as this might also be too weak, we check that the "
"geospatial extent is consistent, and valid for Japan. Once we are "
"satisfied that the file is of our format, we can do any other tests that "
"are necessary to validate the file is usable, and in particular that we "
"can provide the level of access desired.  Since the JDEM driver does not "
"provide update support, error out in that case."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:192
msgid ""
"Next we need to create an instance of the database class in which we will"
" set various information of interest. We create it as a "
"std::unique_ptr<JDEMDataset> with the cpl::make_unique<> utility "
"(equivalent to std::make_unique<> available in C++14 and later), to make "
"memory management easier in error code paths."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:209
msgid ""
"At this point we \"borrow\" the file handle that was held by "
"GDALOpenInfo* (we did make sure that poDS->m_fp is initialized to nullptr"
" in the inline member definition). This file pointer uses the VSI*L GDAL "
"API to access files on disk. This virtualized POSIX-style API allows some"
" special capabilities like supporting large files, in-memory files and "
"zipped files."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:213
msgid ""
"Next the X and Y size are extracted from the header. The `nRasterXSize` "
"and `nRasterYSize` are data fields inherited from the GDALDataset base "
"class, and must be set by the Open() method."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:230
msgid ""
"All the bands related to this dataset must be created and attached using "
"the SetBand() method. We will explore the JDEMRasterBand() class shortly."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:237
msgid ""
"Finally we assign a name to the dataset object, and call the "
"GDALPamDataset TryLoadXML() method which can initialize auxiliary "
"information from an .aux.xml file if available. We also initialize for "
"external overviews (in a .ovr side car file). For more details on these "
"services review the GDALPamDataset and related classes."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:253
msgid "Implementing the RasterBand"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:255
msgid ""
"Similar to the customized JDEMDataset class subclassed from GDALDataset, "
"we also need to declare and implement a customized JDEMRasterBand derived"
" from :cpp:class:`GDALRasterBand` for access to the band(s) of the JDEM "
"file. For JDEMRasterBand the declaration looks like this:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:275
msgid ""
"The constructor may have any signature, and is only called from the "
"Open() method. Other virtual methods, such as "
":cpp:func:`GDALRasterBand::IReadBlock` must be exactly matched to the "
"method signature in gdal_priv.h."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:277
msgid "The constructor implementation looks like this:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:294
msgid ""
"The following data members are inherited from GDALRasterBand, and should "
"generally be set in the band constructor."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:304
msgid ""
"The full set of possible GDALDataType values are declared in gdal.h, and "
"include GDT_Byte, GDT_UInt16, GDT_Int16, and GDT_Float32. The block size "
"is used to establish a natural or efficient block size to access the data"
" with. For tiled datasets this will be the size of a tile, while for most"
" other datasets it will be one scanline, as in this case."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:306
msgid ""
"Next we see the implementation of the code that actually reads the image "
"data, IReadBlock()."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:363
msgid "Key items to note are:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:365
msgid ""
"It is typical to cast the GDALRasterBand::poDS member to the derived type"
" of the owning dataset. If your RasterBand class will need privileged "
"access to the owning dataset object, ensure it is declared as a friend "
"(omitted above for brevity)."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:366
msgid ""
"If an error occurs, report it with CPLError(), and return CE_Failure. "
"Otherwise return CE_None."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:367
msgid ""
"The pImage buffer should be filled with one block of data. The block is "
"the size declared in nBlockXSize and nBlockYSize for the raster band. The"
" type of the data within pImage should match the type declared in "
"eDataType in the raster band object."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:368
msgid ""
"The nBlockXOff and nBlockYOff are block offsets, so with 128x128 tiled "
"datasets values of 1 and 1 would indicate the block going from (128,128) "
"to (255,255) should be loaded."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:371
msgid "The Driver"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:373
msgid ""
"While the JDEMDataset and JDEMRasterBand are now ready to use to read "
"image data, it still isn't clear how the GDAL system knows about the new "
"driver. This is accomplished via the :cpp:class:`GDALDriverManager`. To "
"register our format we implement a registration function. The declaration"
" goes in gcore/gdal_frmts.h: void CPL_DLL GDALRegister_JDEM(void);"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:376
msgid "The definition in the driver file is:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:405
msgid ""
"Note the use of GDAL_CHECK_VERSION macro. This is a macro that should be "
"used by drivers that can be built as a plugin. As the GDAL C++ ABI may, "
"and will, change between GDAL feature releases (for example from GDAL "
"3.x.0 to 3.y.0), it is necessary to recompile your driver against the "
"header files of the GDAL feature version with which you want to make it "
"work. The GDAL_CHECK_VERSION macro will check that the GDAL version with "
"which the driver was compiled and the version against which it is running"
" are compatible (checking that the major and minor version numbers are "
"equal). The C++ ABI will however remain stable for releases of the same "
"release branch (that is for bug fixes releases x.y.z of a given feature "
"release x.y.0)."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:407
msgid ""
"The registration function will create an instance of a GDALDriver object "
"when first called, and register it with the GDALDriverManager. The "
"following fields can be set in the driver before registering it with the "
"GDALDriverManager."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:409
msgid ""
"The description is the short name for the format. This is a unique name "
"for this format, often used to identity the driver in scripts and command"
" line programs. Normally 3-5 characters in length, and matching the "
"prefix of the format classes. (mandatory)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:410
msgid ""
"GDAL_DCAP_RASTER: set to YES to indicate that this driver handles raster "
"data. (mandatory)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:411
msgid ""
"GDAL_DMD_LONGNAME: A longer descriptive name for the file format, but "
"still no longer than 50-60 characters. (mandatory)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:412
msgid ""
"GDAL_DMD_HELPTOPIC: The name of a help topic to display for this driver, "
"if any. In this case JDEM format is contained within the various format "
"web page held in gdal/html. (optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:413
msgid ""
"GDAL_DMD_EXTENSIONS: The extensions used for files of this type, without "
"the leading '.'. If more than one, they should be separated with space. "
"(optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:414
msgid ""
"GDAL_DMD_MIMETYPE: The standard mime type for this file format, such as "
"\"image/png\". (optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:415
msgid ""
"GDAL_DMD_CREATIONOPTIONLIST: There is evolving work on mechanisms to "
"describe creation options. See the geotiff driver for an example of this."
" (optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:416
msgid ""
"GDAL_DMD_CREATIONDATATYPES: A list of space separated data types "
"supported by this create when creating new datasets. If a Create() method"
" exists, these will be will supported. If a CreateCopy() method exists, "
"this will be a list of types that can be losslessly exported but it may "
"include weaker data types than the type eventually written. For instance,"
" a format with a CreateCopy() method, and that always writes Float32 "
"might also list Byte, Int16, and UInt16 since they can losslessly "
"translated to Float32. An example value might be \"Byte Int16 UInt16\". "
"(required - if creation supported)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:417
msgid ""
"GDAL_DCAP_VIRTUALIO: set to YES to indicate that this driver can deal "
"with files opened with the VSI*L GDAL API. Otherwise this metadata item "
"should not be defined. (optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:418
msgid ""
"pfnOpen: The function to call to try opening files of this format. "
"(optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:419
msgid ""
"pfnIdentify: The function to call to try identifying files of this "
"format. A driver should return 1 if it recognizes the file as being of "
"its format, 0 if it recognizes the file as being NOT of its format, or -1"
" if it cannot reach to a firm conclusion by just examining the header "
"bytes. (optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:420
msgid ""
"pfnCreate: The function to call to create new updatable datasets of this "
"format. (optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:421
msgid ""
"pfnCreateCopy: The function to call to create a new dataset of this "
"format copied from another source, but not necessary updatable. "
"(optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:422
msgid ""
"pfnDelete: The function to call to delete a dataset of this format. "
"(optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:423
msgid ""
"pfnUnloadDriver: A function called only when the driver is destroyed. "
"Could be used to cleanup data at the driver level. Rarely used. "
"(optional)"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:425
msgid ""
"For a driver that can be built as a plugin (that is to say a standalone "
"shared object, loaded at runtime by GDAL), since GDAL 3.9 and "
":ref:`rfc-96`, there is a way to implement the driver in a way where the "
"plugin will be loaded only when necessary, and not immediately at "
":cpp:func:`GDALAllRegister` time. Consult :ref:`rfc96_example_driver` for"
" the changes needed to make the driver compatible of deferred plugin "
"loading."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:428
msgid "Adding Driver to GDAL Tree"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:430
msgid ""
"Note that the GDALRegister_JDEM() method must be called by the higher "
"level program in order to have access to the JDEM driver. Normal practice"
" when writing new drivers is to:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:432
msgid ""
"Add a driver directory under frmts, with the directory name the same as "
"the short name."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:433
msgid ""
"Add a CMakeLists.txt in that directory modeled on those from other "
"similar directories (i.e. the jdem directory)."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:434
msgid ""
"Reference the new driver in frmts/CMakeLists.txt, using the "
"gdal_optional_format() or gdal_dependent_format() functions depending if "
"it requires no external dependency or it has at least one."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:435
msgid ""
"Add the module with the dataset, and rasterband implementation. Generally"
" this is called <short_name>dataset.cpp, with all the GDAL specific code "
"in one file, though that is not required."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:436
msgid ""
"Add the registration entry point declaration (i.e. GDALRegister_JDEM()) "
"to gcore/gdal_frmts.h."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:437
msgid ""
"Add a call to the registration function to frmts/gdalallregister.cpp, "
"protected by an appropriate #ifdef."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:439
msgid ""
"Once this is all done, it should be possible to rebuild GDAL, and have "
"the new format available in all the utilities. The :ref:`gdalinfo` "
"utility can be used to test that opening and reporting on the format is "
"working, and the :ref:`gdal_translate` utility can be used to test image "
"reading."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:442
msgid "Adding Georeferencing"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:444
msgid ""
"Now we will take the example a step forward, adding georeferencing "
"support. We add the following two virtual method overrides to "
"JDEMDataset, taking care to exactly match the signature of the method on "
"the GDALDataset base class."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:451
msgid ""
"The implementation of :cpp:func:`GDALDataset::GetGeoTransform` just "
"copies the usual geotransform matrix into the supplied buffer. Note that "
":cpp:func:`GDALDataset::GetGeoTransform` may be called a lot, so it isn't"
" generally wise to do a lot of computation in it. In many cases the "
"Open() will collect the geotransform, and this method will just copy it "
"over. Also note that the geotransform return is based on an anchor point "
"at the top left corner of the top left pixel, not the center of pixel "
"approach used in some packages."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:475
msgid ""
"The :cpp:func:`GDALDataset::GetSpatialRef` method returns a pointer to an"
" internal OGRSpatialReference object."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:484
msgid ""
"In this case the coordinate system is fixed for all files of this format,"
" and has been initialized in the JDEMDataset constructor. But in more "
"complex cases, a definition may need to be composed on the fly, in which "
"case it may be helpful to use the :cpp:class:`OGRSpatialReference` class "
"to help build the definition."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:498
msgid ""
"This completes explanation of the features of the JDEM driver. The full "
"source for jdemdataset.cpp can be reviewed as needed."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:501
msgid "Overviews"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:503
msgid ""
"GDAL allows file formats to make pre-built overviews available to "
"applications via the :cpp:func:`GDALRasterBand::GetOverview` and related "
"methods. However, implementing this is pretty involved, and goes beyond "
"the scope of this document for now. The GeoTIFF driver "
"(gdal/frmts/gtiff/geotiff.cpp) and related source can be reviewed for an "
"example of a file format implementing overview reporting and creation "
"support."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:505
msgid ""
"Formats can also report that they have arbitrary overviews, by overriding"
" the :cpp:func:`GDALRasterBand::HasArbitraryOverviews` method on the "
"GDALRasterBand, returning TRUE. In this case the raster band object is "
"expected to override the :cpp:func:`GDALRasterBand::RasterIO` method "
"itself, to implement efficient access to imagery with resampling. This is"
" also involved, and there are a lot of requirements for correct "
"implementation of the RasterIO() method. An example of this can be found "
"in the OGDI and ECW formats."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:507
msgid ""
"However, by far the most common approach to implementing overviews is to "
"use the default support in GDAL for external overviews stored in TIFF "
"files with the same name as the dataset, but the extension .ovr appended."
" In order to enable reading and creation of this style of overviews it is"
" necessary for the GDALDataset to initialize the `oOvManager` object "
"within itself. This is typically accomplished with a call like the "
"following near the end of the Open() method (after the PAM "
":cpp:func:`GDALDataset::TryLoadXML`)."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:513
msgid ""
"This will enable default implementations for reading and creating "
"overviews for the format. It is advised that this be enabled for all "
"simple file system based formats unless there is a custom overview "
"mechanism to be tied into."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:516
msgid "File Creation"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:518
msgid ""
"There are two approaches to file creation. The first method is called the"
" :cpp:func:`GDALDriver::CreateCopy` method, and involves implementing a "
"function that can write a file in the output format, pulling all imagery "
"and other information needed from a source GDALDataset. The second "
"method, the dynamic creation method, involves implementing a Create "
"method to create the shell of the file, and then the application writes "
"various information by calls to set methods."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:520
msgid ""
"The benefits of the first method are that that all the information is "
"available at the point the output file is being created. This can be "
"especially important when implementing file formats using external "
"libraries which require information like color maps, and georeferencing "
"information at the point the file is created. The other advantage of this"
" method is that the CreateCopy() method can read some kinds of "
"information, such as min/max, scaling, description and GCPs for which "
"there are no equivalent set methods."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:522
msgid ""
"The benefits of the second method are that applications can create an "
"empty new file, and write results to it as they become available. A "
"complete image of the desired data does not have to be available in "
"advance."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:524
msgid ""
"For very important formats both methods may be implemented, otherwise do "
"whichever is simpler, or provides the required capabilities."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:527
msgid "CreateCopy"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:529
msgid ""
"The GDALDriver::CreateCopy() method call is passed through directly, so "
"that method should be consulted for details of arguments. However, some "
"things to keep in mind are:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:531
msgid ""
"If the `bStrict` flag is FALSE the driver should try to do something "
"reasonable when it cannot exactly represent the source dataset, "
"transforming data types on the fly, dropping georeferencing and so forth."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:532
msgid ""
"Implementing progress reporting correctly is somewhat involved. The "
"return result of the progress function needs always to be checked for "
"cancellation, and progress should be reported at reasonable intervals. "
"The JPEGCreateCopy() method demonstrates good handling of the progress "
"function."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:533
msgid ""
"Special creation options should be documented in the on-line help. If the"
" options take the format \"NAME=VALUE\" the papszOptions list can be "
"manipulated with :cpp:func:`CPLFetchNameValue` as demonstrated in the "
"handling of the QUALITY and PROGRESSIVE flags for JPEGCreateCopy()."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:534
msgid ""
"The returned GDALDataset handle can be in ReadOnly or Update mode. Return"
" it in Update mode if practical, otherwise in ReadOnly mode is fine."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:536
msgid ""
"The full implementation of the CreateCopy function for JPEG (which is "
"assigned to pfnCreateCopy in the GDALDriver object) is here. static "
"GDALDataset *"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:644
msgid "Dynamic Creation"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:646
msgid ""
"In the case of dynamic creation, there is no source dataset. Instead the "
"size, number of bands, and pixel data type of the desired file is "
"provided but other information (such as georeferencing, and imagery data)"
" would be supplied later via other method calls on the resulting "
"GDALDataset."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:648
msgid ""
"The following sample implement PCI .aux labeled raw raster creation. It "
"follows a common approach of creating a blank, but valid file using non-"
"GDAL calls, and then calling GDALOpen(,GA_Update) at the end to return a "
"writable file handle. This avoids having to duplicate the various setup "
"actions in the Open() function."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:753
msgid ""
"File formats supporting dynamic creation, or even just update-in-place "
"access also need to implement an IWriteBlock() method on the raster band "
"class. It has semantics similar to IReadBlock(). As well, for various "
"esoteric reasons, it is critical that a FlushCache() method be "
"implemented in the raster band destructor. This is to ensure that any "
"write cache blocks for the band be flushed out before the destructor is "
"called."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:756
msgid "RawDataset/RawRasterBand Helper Classes"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:758
msgid ""
"Many file formats have the actual imagery data stored in a regular, "
"binary, scanline oriented format. Rather than re-implement the access "
"semantics for this for each formats, there are provided "
":cpp:class:`RawDataset` and :cpp:class:`RawRasterBand` classes declared "
"in gcore/ that can be utilized to implement efficient and convenient "
"access."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:760
msgid ""
"In these cases the format specific band class may not be required, or if "
"required it can be derived from RawRasterBand. The dataset class should "
"be derived from RawDataset."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:762
msgid ""
"The Open() method for the dataset then instantiates raster bands passing "
"all the layout information to the constructor. For instance, the PNM "
"driver uses the following calls to create it's raster bands."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:785
msgid "The RawRasterBand takes the following arguments."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:787
msgid ""
"poDS: The GDALDataset this band will be a child of. This dataset must be "
"of a class derived from RawRasterDataset."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:788
msgid "nBand: The band it is on that dataset, 1 based."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:789
msgid "fpRaw: The FILE * handle to the file containing the raster data."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:790
msgid ""
"nImgOffset: The byte offset to the first pixel of raster data for the "
"first scanline."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:791
msgid ""
"nPixelOffset: The byte offset from the start of one pixel to the start of"
" the next within the scanline."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:792
msgid ""
"nLineOffset: The byte offset from the start of one scanline to the start "
"of the next."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:793
msgid "eDataType: The GDALDataType code for the type of the data on disk."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:794
msgid ""
"bNativeOrder: FALSE if the data is not in the same endianness as the "
"machine GDAL is running on. The data will be automatically byte swapped."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:796
msgid ""
"Simple file formats utilizing the Raw services are normally placed all "
"within one file in the gdal/frmts/raw directory. There are numerous "
"examples there of format implementation."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:799
msgid "Metadata, and Other Exotic Extensions"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:801
msgid ""
"There are various other items in the GDAL data model, for which virtual "
"methods exist on the GDALDataset and GDALRasterBand. They include:"
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:803
msgid ""
"Metadata: Name/value text values about a dataset or band. The "
"GDALMajorObject (base class for GDALRasterBand and GDALDataset) has "
"built-in support for holding metadata, so for read access it only needs "
"to be set with calls to SetMetadataItem() during the Open(). The SAR_CEOS"
" (frmts/ceos2/sar_ceosdataset.cpp) and GeoTIFF drivers are examples of "
"drivers implementing readable metadata."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:805
msgid ""
"ColorTables: GDT_Byte raster bands can have color tables associated with "
"them. The frmts/png/pngdataset.cpp driver contains an example of a format"
" that supports colortables."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:807
msgid ""
"ColorInterpretation: The PNG driver contains an example of a driver that "
"returns an indication of whether a band should be treated as a Red, "
"Green, Blue, Alpha or Greyscale band."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:809
msgid ""
"GCPs: GDALDatasets can have a set of ground control points associated "
"with them (as opposed to an explicit affine transform returned by "
"GetGeotransform()) relating the raster to georeferenced coordinates. The "
"MFF2 (gdal/frmts/raw/hkvdataset.cpp) format is a simple example of a "
"format supporting GCPs."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:811
msgid ""
"NoDataValue: Bands with known \"nodata\" values can implement the "
"GetNoDataValue() method. See the PAux (frmts/raw/pauxdataset.cpp) for an "
"example of this."
msgstr ""

#: ../../source/tutorials/raster_driver_tut.rst:813
msgid ""
"Category Names: Classified images with names for each class can return "
"them using the GetCategoryNames() method though no formats currently "
"implement this."
msgstr ""

