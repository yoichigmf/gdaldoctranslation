# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-29 00:52+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/api/cpl.rst:5
msgid "Common Portability Library C API"
msgstr ""

#: ../../source/api/cpl.rst:8
msgid "cpl_conv.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/gnm_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/ogrspatialref.rst
#: ../../source/api/raster_c_api.rst ../../source/api/vector_c_api.rst
msgid "Defines"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/gnm_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/raster_c_api.rst ../../source/api/vector_c_api.rst
msgid "Typedefs"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/ogr_srs_api.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst
msgid "Functions"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdalattribute_cpp.rst ../../source/api/gdaldataset_cpp.rst
#: ../../source/api/gdaldimension_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalextendeddatatype_cpp.rst
#: ../../source/api/gdalgroup_cpp.rst ../../source/api/gdalmdarray_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogr_srs_api.rst
#: ../../source/api/ogrfeature_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst
msgid "Parameters"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdalattribute_cpp.rst ../../source/api/gdaldataset_cpp.rst
#: ../../source/api/gdaldimension_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalgroup_cpp.rst ../../source/api/gdalmdarray_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogr_srs_api.rst
#: ../../source/api/ogrfeature_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst
msgid "Returns"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdaldataset_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst
msgid "Public Members"
msgstr ""

#: ../../source/api/cpl.rst:14
msgid "cpl_csv.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/gnm_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/raster_c_api.rst ../../source/api/vector_c_api.rst
msgid "Enums"
msgstr ""

#: ../../source/api/cpl.rst:20
msgid "cpl_compressor.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param input_data"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param input_size"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param output_data"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param output_size"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param options"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param compressor_user_data"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/raster_c_api.rst
msgid "Return"
msgstr ""

#: ../../source/api/cpl.rst:26
msgid "cpl_error.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdalattribute_cpp.rst ../../source/api/gdaldataset_cpp.rst
#: ../../source/api/gdaldimension_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalextendeddatatype_cpp.rst
#: ../../source/api/gdalgroup_cpp.rst ../../source/api/gdalmdarray_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogrfeature_cpp.rst
#: ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/vector_c_api.rst
msgid "Public Functions"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Private Members"
msgstr ""

#: ../../source/api/cpl.rst:32
msgid "cpl_http.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pszURL"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param papszOptions"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pfnProgress"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pProgressArg"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pfnWrite"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pWriteArg"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/raster_c_api.rst
msgid "Param pUserData"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdaldataset_cpp.rst ../../source/api/ogrgeometry_cpp.rst
#: ../../source/api/ogrlayer_cpp.rst
msgid "Public Types"
msgstr ""

#: ../../source/api/cpl.rst:38
msgid "cpl_minixml.h"
msgstr ""

#: ../../source/api/cpl.rst:44
msgid "cpl_multiproc.h"
msgstr ""

#: ../../source/api/cpl.rst:50
msgid "cpl_port.h"
msgstr ""

#: ../../source/api/cpl.rst:56
msgid "cpl_progress.h"
msgstr ""

#: ../../source/api/cpl.rst:62
msgid "cpl_string.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdaldataset_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalextendeddatatype_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/ogrfeature_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Public Static Functions"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Private Functions"
msgstr ""

#: ../../source/api/cpl.rst:68
msgid "cpl_time.h"
msgstr ""

#: ../../source/api/cpl.rst:74
msgid "cpl_virtualmem.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param ctxt"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nOffset"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pPageToFill"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nToFill"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pPageToBeEvicted"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nToBeEvicted"
msgstr ""

#: ../../source/api/cpl.rst:80
msgid "cpl_vsi_error.h"
msgstr ""

#: ../../source/api/cpl.rst:86
msgid "cpl_vsi.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pFile"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nRanges"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param panOffsets"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param panSizes"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsisubfile/ virtual file handler."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsisubfile/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsicurl/ HTTP/FTP file system handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsicurl/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 1.8.0"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsicurl_streaming/ HTTP/FTP file system handler (requires "
"libcurl)."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsicurl_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 1.10"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsis3/ Amazon S3 file system handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsis3/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.1"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsis3_streaming/ Amazon S3 file system handler (requires "
"libcurl)."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsis3_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsigs/ Google Cloud Storage file system handler (requires "
"libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsigs/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.2"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsigs_streaming/ Google Cloud Storage file system handler "
"(requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsigs_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz/ Microsoft Azure Blob file system handler (requires "
"libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiaz/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.3"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz_streaming/ Microsoft Azure Blob file system handler "
"(requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiaz_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz/ Microsoft Azure Data Lake Storage Gen2 file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiadls/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 3.3"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsioss/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz_streaming/ Alibaba Cloud Object Storage Service (OSS) "
"(requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsioss_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiswift/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiswift_streaming/ OpenStack Swif Object Storage (Swift) file "
"system handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiswift_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsi7z/ 7zip file system handler (requires libarchive)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsi7z/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 3.7"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsirar/ RAR file system handler (requires libarchive)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsirar/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install GZip file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading on-the-fly and "
"writing in GZip (.gz) files."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"All portions of the file system underneath the base path \"/vsigzip/\" "
"will be handled by this driver."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsigzip/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 1.6.0"
msgstr ""

#: ../../<breathe>:-1
msgid "Install ZIP file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading on-the-fly in ZIP"
" (.zip) archives."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"All portions of the file system underneath the base path \"/vsizip/\" "
"will be handled by this driver."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsizip/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsistdin/ file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading from the standard"
" input stream."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"The file operations available are of course limited to Read() and forward"
" Seek() (full seek in the first MB of a file by default)."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Starting with GDAL 3.6, this limit can be configured either by setting "
"the CPL_VSISTDIN_BUFFER_LIMIT configuration option to a number of bytes "
"(can be -1 for unlimited), or using the \"/vsistdin?buffer_limit=value\" "
"filename."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsistdin/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiwebhdfs/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.4"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsistdout/ file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows writing to the standard "
"output stream."
msgstr ""

#: ../../<breathe>:-1
msgid "The file operations available are of course limited to Write()."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A variation of this file system exists as the /vsistdout_redirect/ file "
"system handler, where the output function can be defined with "
"VSIStdoutSetRedirection()."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsistdout/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsisparse/ virtual file handler."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsisparse/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsitar/ file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading on-the-fly in TAR"
" (regular .tar, or compressed .tar.gz/.tgz) archives."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"All portions of the file system underneath the base path \"/vsitar/\" "
"will be handled by this driver."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsitar/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsicached? file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsicached? documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 3.8.0"
msgstr ""

#: ../../source/api/cpl.rst:93
msgid ":ref:`cpl_cpp_api`."
msgstr ""

#: ../../source/api/cpl_cpp.rst:5
msgid "Common Portability Library C++ API"
msgstr ""

#: ../../source/api/cpl_cpp.rst:8
msgid "cpl_odbc.h"
msgstr ""

#: ../../source/api/cpl_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Private Static Functions"
msgstr ""

#: ../../source/api/cpl_cpp.rst:14
msgid "cpl_vsi_virtual.h"
msgstr ""

#: ../../source/api/cpl_cpp.rst
msgid "Variables"
msgstr ""

#: ../../source/api/cpl_cpp.rst:21
msgid ":ref:`cpl_api`."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:5
msgid "Compiling the C# bindings - CMake Scripts"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:7
msgid ""
"This page describes the primary steps when creating the GDAL/OGR C# "
"binaries from the source using the new CMake scripts."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:9
#: ../../source/api/csharp/csharp_compile_legacy.rst:9
msgid ""
"In most cases this is not necessary and it is better to use one of the "
"pre-compiled sources, such as `GisInternals "
"<https://gisinternals.com/>`__ or Conda."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:11
msgid ""
"You can either build the bindings as part of a full GDAL build - or "
"standalone on top of an existing installation."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:14
#: ../../source/api/csharp/csharp_compile_legacy.rst:18
#: ../../source/api/csharp/csharp_compile_legacy.rst:105
msgid "Requirements"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:16
#: ../../source/api/csharp/csharp_compile_legacy.rst:20
#: ../../source/api/csharp/csharp_compile_legacy.rst:107
msgid "The build environment has the following dependencies:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:18
msgid "CMake 3.10 or later"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:19
msgid "the appropriate C++ build environment (i.e. gcc or Visual Studio etc)."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:20
msgid "SWIG 4"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:21
msgid ".NET 5.0 or Mono"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:24
msgid ".NET Build Toolchain"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:26
msgid ""
"The build scripts can use either .NET 5.0 and  :file:`dotnet.exe` or Mono"
" and :file:`msc.exe` to compile the bindings."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:28
msgid ""
".NET is used for preference if it found on all platforms but the use of "
"Mono can be forced using a command line variable."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:31
msgid "Building as part of a GDAL Build"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:33
msgid "The build environment uses the following variables:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:36
msgid "CSHARP_MONO"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:36
#: ../../source/api/csharp/csharp_compile_cmake.rst:42
#: ../../source/api/csharp/csharp_compile_cmake.rst:44
msgid "Boolean"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:36
msgid "Forces the use of Mono"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:38
msgid "CSHARP_LIBRARY_VERSION"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:38
#: ../../source/api/csharp/csharp_compile_cmake.rst:40
msgid "String"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:38
msgid "Set the .NET version for the shared libraries"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:40
msgid "CSHARP_APPLICATION_VERSION"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:40
msgid "Set the .NET version for the sample apps"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:42
msgid "GDAL_CSHARP_ONLY"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:42
msgid "Build standalone on GDAL binaries"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:44
msgid "BUILD_CSHARP_BINDINGS"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:44
msgid "Build the C# bindings DEFAULT ON"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:48
msgid "Building with .NET"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:50
msgid ""
"If the build environment has .NET 5.0 installed and GDAL is built, then "
"the c# bindings will be built using .NET by default."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:52
msgid ""
"The details of building GDAL are documented elsewhere, but there are "
"likely to be variants of the following commands run from the root "
"directory of the gdal repository:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:60
#: ../../source/api/csharp/csharp_compile_cmake.rst:115
msgid ""
"The C# bindings and sample apps are installed in the install directory "
"(in the above case that would be `../install`, in the `share/csharp` sub "
"folder. There would be the following files:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:62
#: ../../source/api/csharp/csharp_compile_cmake.rst:117
#: ../../source/api/csharp/csharp_compile_legacy.rst:66
msgid ":file:`gdal_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:63
#: ../../source/api/csharp/csharp_compile_cmake.rst:118
#: ../../source/api/csharp/csharp_compile_legacy.rst:67
msgid ":file:`ogr_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:64
#: ../../source/api/csharp/csharp_compile_cmake.rst:119
#: ../../source/api/csharp/csharp_compile_legacy.rst:68
msgid ":file:`osr_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:65
#: ../../source/api/csharp/csharp_compile_cmake.rst:120
#: ../../source/api/csharp/csharp_compile_legacy.rst:69
msgid ":file:`gdalconst_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:66
#: ../../source/api/csharp/csharp_compile_cmake.rst:121
msgid ""
":file:`gdal_wrap.dll` or :file:`libgdal_wrap.so` or "
":file:`libgdal_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:67
#: ../../source/api/csharp/csharp_compile_cmake.rst:122
msgid ""
":file:`ogr_wrap.dll` or :file:`libogr_wrap.so` or "
":file:`libogr_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:68
#: ../../source/api/csharp/csharp_compile_cmake.rst:69
#: ../../source/api/csharp/csharp_compile_cmake.rst:123
#: ../../source/api/csharp/csharp_compile_cmake.rst:124
msgid ""
":file:`osr_wrap.dll` or :file:`libosr_wrap.so` or "
":file:`libosr_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:70
#: ../../source/api/csharp/csharp_compile_cmake.rst:125
msgid ""
":file:`gdalconst_wrap.dll` or :file:`libgdalconst_wrap.so` or "
":file:`libgdalconst_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:71
msgid ""
"various sample applications - as \\*.exe on Windows, or just as \\* on "
"Unix, along with \\*.dll for each app and the runtime config files."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:73
msgid ""
"There are also subdirectories for each of the sample apps, holding the "
"config files."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:75
msgid "There are also the following NuGET packages:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:77
msgid ":file:`OSGeo.GDAL`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:78
msgid ":file:`OSGeo.OGR`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:79
msgid ":file:`OSgeo.OSR`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:80
msgid ":file:`OSGeo.GDAL.CONST`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:81
msgid "various sample application"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:84
msgid "Using the .NET Bindings"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:86
msgid ""
"The easiest way to use the bindings in development would be use the NuGET"
" packages created."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:88
msgid ""
"To do this you need to add a local repistory pointing to the GDAL install"
" directory. `This is explained here <https://docs.microsoft.com/en-"
"us/nuget/hosting-packages/local-feeds>`__ ."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:90
msgid "Once this is done, you add the GDAL packages into your project as normal."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:92
msgid ""
"These packages only install the bindings and do not install core GDAL. It"
" is for you as the developer to make sure that the GDAL binaries are "
"available in the search path."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:95
msgid ""
"The NuGET packages are created with the same version number as the "
"version of GDAL in the build system. If you are building in a GIT "
"repository, then the build system automatically makes the version with a "
"x.y.z-dev pre-release tag. This means that to load the package into "
"Visual Studio (for instance), you have to tick the pre-release box. This "
"is all intentional and not a bug."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:102
msgid "Building on Mono"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:104
msgid ""
"If the build environment does not have .NET 5.0 or msbuild installed and "
"GDAL is built, then the c# bindings will be built using Mono by default. "
"Mono building can also be forced by setting CSHARP_MONO."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:107
msgid ""
"The details of building GDAL are documented elsewhere, but the there are "
"likely to be variants of the following commands run from the root "
"directory of the gdal repository:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:126
msgid "various sample applications as \\*.exe on all platforms."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:129
msgid "Using the Mono Bindings"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:131
msgid "Note that the bindings created by this process will only work with Mono."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:133
#: ../../source/api/csharp/csharp_compile_legacy.rst:177
msgid ""
"To run one of the prebuilt executables - you can run them with Mono as "
"follows :"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:135
#: ../../source/api/csharp/csharp_compile_legacy.rst:179
msgid ":program:`mono GDALInfo.exe`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:137
#: ../../source/api/csharp/csharp_compile_legacy.rst:181
msgid ""
"Both the managed libraries (i.e. the DLLs) and the unmanaged libraries "
"must be available to Mono. This is in more detail in `the Mono "
"documentation <https://www.mono-project.com/docs/advanced/pinvoke/>`__"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:141
msgid "Building Standalone"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:143
msgid ""
"The Bindings using both the .NET or Mono toolchains can be build on top "
"of an existing implementation of GDAL that includes the include files and"
" libs - for instance the Conda distribution."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:146
msgid ""
"To do this, Cmake must be run with the GDAL_CSHARP_ONLY flag set and only"
" one of the following targets should be built:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:150
msgid "csharp_binding"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:150
msgid "Just the bindings"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:152
msgid "csharp_samples"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:152
msgid "The bindings and the sample apps"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:155
msgid "Do not build the install target when running standalone, it will fail!"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:157
msgid ""
"Do not run a bare ctest command on this build, it will likely fail! Use "
"something like `ctest -R \"^csharp.*\"` instead."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:159
msgid "As an example:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:166
msgid ""
"The output from this build is axactly the same as documented as above, "
"except that the outputs will be in `../build/swig/csharp` and some of the"
" sub folders."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:169
msgid "Signing of build artifacts"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:171
msgid ""
"The CSharp assemblies are strong name signed by default with the provided"
" key file in :source_file:`swig/csharp/gdal.snk`. If authenticode signing"
" of the assemblies is wished, it should be done in a post-build manual "
"step, for example with:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:5
msgid "Compiling the C# bindings - Legacy Scripts"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:7
msgid ""
"This page describes the primary steps when creating the GDAL/OGR C# "
"binaries from the source."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:12
msgid "Building on Windows"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:14
msgid ""
"To building the C# interface, you need a compiled version of the GDAL "
"core. This can be the result of a manual compilation or can be linking to"
" one of the prebuilt binaries. In the former case the following should be"
" run in the clone of the GitHub repository used to build GDAL and the "
"steps to create the environment should not be necessary."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:22
msgid "nmake / Visual Studio"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:23
#: ../../source/api/csharp/csharp_compile_legacy.rst:110
msgid "SWIG 3/4"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:25
msgid ""
"The `GDAL test scripts "
"<https://github.com/OSGeo/gdal/blob/master/.github/workflows/windows_build.yml>`__"
" use VS 2019 (MSVC Ver 1920) so it would make sense to use the same "
"versions."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:27
msgid ""
"`SWIG <http://www.swig.org/>`__ is used to build the API bindings. The "
"GDAL test scripts use version 3 and the conda build use version 4. Both "
"Work."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:30
#: ../../source/api/csharp/csharp_compile_legacy.rst:114
msgid "Build Environment"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:32
msgid ""
"You need to set up the build environment. If you are using VS 2019, this "
"might be the command:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:34
msgid ":program:`VsDevCmd.bat -arch=x64`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:36
msgid ""
"The :program:`VsDevCmd.bat` command can usually be found in "
":file:`C:\\\\Program Files (x86)\\\\Microsoft Visual "
"Studio\\\\2019\\\\Enterprise\\\\Common7\\\\Tools` or the equivalent for "
"the Community Edition."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:38
msgid ""
"If you don't want to bother with executing the proper vcvars*.bat you "
"might use the development environment specific command prompt to "
"accomplish this task. When using a Win64 compilation be careful to "
"activate the x64 version of the command prompt installed on your system."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:40
msgid ""
"If you are not running in an environment that has been used to compile "
"GDAL locally, then there are a number of variables that need to be "
"configured. The Conda ``gdal-feedstock`` configuration app can be used as"
" a guideline about how to do that - `build.bat <https://github.com/conda-"
"forge/gdal-feedstock/blob/master/recipe/set_bld_opts.bat>`__."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:43
#: ../../source/api/csharp/csharp_compile_legacy.rst:121
msgid "Creating the SWIG interface code"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:45
msgid ""
"The first step is to generate the SWIG interface code. This will create a"
" set of ``.cs`` definitions that will be compiled into the ``.dll`` files"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:47
msgid ""
"To create the interface execute the following command (from the "
"``swig\\csharp`` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:53
msgid ""
"You should edit nmake.opt adding the actual location of the "
":file:`swig.exe` file."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:56
#: ../../source/api/csharp/csharp_compile_legacy.rst:134
msgid "Compiling the code"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:58
msgid ""
"After creating the interface the code can be compiled using this command "
"(from the ``swig\\csharp`` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:64
#: ../../source/api/csharp/csharp_compile_legacy.rst:142
msgid "Upon a successful compilation the following files are created:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:70
msgid ":file:`gdal_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:71
msgid ":file:`ogr_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:72
msgid ":file:`osr_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:73
msgid ":file:`gdalconst_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:74
msgid "various sample applications"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:76
msgid ""
"The :file:`\\*_csharp.dll` binaries are the managed part of the "
"interface. You should add a reference to these assemblies for using the "
"classes of the interface. These :file:`\\*_csharp.dll` files will load "
"the corresponding :file:`\\*_wrap.dll` files, which are the unmanaged "
"part of the interface hosting the code of the gdal core."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:79
#: ../../source/api/csharp/csharp_compile_legacy.rst:160
msgid "Testing the successful compilation"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:81
#: ../../source/api/csharp/csharp_compile_legacy.rst:162
msgid "To test the compiled binaries, you can use:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:87
#: ../../source/api/csharp/csharp_compile_legacy.rst:168
msgid "This command will invoke some of the sample applications."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:89
msgid ""
"For the tests to work the location of the proj and gdal DLLs should be "
"available in the PATH."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:92
msgid "Using MONO on Windows"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:94
msgid ""
"If you have the Windows version of the MONO package installed you can "
"compile the C# code using the MONO compiler. In this case uncomment the "
"following entry in csharp.opt:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:96
msgid ":program:`MONO = YES`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:98
msgid "mcs.exe must be in the PATH."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:102
msgid "Building on Linux/OSX"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:109
msgid "make"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:111
msgid "mono (probably any reasonable version)"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:116
msgid ""
"The build environment needs to be correctly configured. If you are not "
"running in an environment that has been used to locally build GDAL then "
"you should run the :program:`configure` command from the GDAL root "
"directory."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:118
msgid ""
"The conda gdal-feedstock recipe provides an example of how to do that - "
"`build.sh <https://github.com/conda-forge/gdal-"
"feedstock/blob/master/recipe/build.sh>`__"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:123
msgid ""
"The first step is to generate the SWIG interface code. This will create a"
" set of :file:`.cs` definitions that will be compiled into the "
":file:`.dll` files"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:125
msgid ""
"To create the interface execute the following command (from the "
":file:`swig/    csharp` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:131
msgid ""
"In versions of GDAL < 3.3.0 - this command will create incorrect "
"interfaces without the correct namespace. See `#3670 "
"<https://github.com/OSGeo/gdal/pull/3670/commits/777c9d0e86602740199cf9a4ab44e040c52c2283>`__."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:136
msgid ""
"After creating the interface the code can be compiled using this command "
"(from the :file:`swig/csharp` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:144
msgid ":file:`gdal_csharp.dll` and :file:`gdal_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:145
msgid ":file:`ogr_csharp.dll` and :file:`ogr_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:146
msgid ":file:`osr_csharp.dll` and :file:`osr_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:147
msgid ":file:`gdalconst_csharp.dll` and :file:`gdalconst_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:148
msgid ":file:`libgdalcsharp.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:149
msgid ":file:`libogrcsharp.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:150
msgid ":file:`libosrcsharp.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:151
msgid ":file:`libgdalconst_wrap.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:152
msgid "various sample applications (:file:`\\*.exe`)"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:154
msgid ""
"The :file:`\\*_csharp.dll` binaries are the managed part of the "
"interface. You should add a reference to these assemblies for using the "
"classes of the interface."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:156
msgid ""
"The :file:`\\*_csharp.dll` files will try to load the corresponding "
":file:`\\*_wrap.dll` and are redirected to the :file:`libxxxcsharp.\\*` "
"libraries, which are the unmanaged part of the interface hosting the code"
" of the gdal core, by the :file:`\\*.dll.config` definitions."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:170
msgid ""
"For the tests to work the location of the proj and gdal libraries should "
"be available in the PATH."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:173
msgid "Using The Bindings on Unix"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:175
msgid ""
"Note that the bindings created by this process will only work with Mono "
"at the moment."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:184
msgid ""
"This document was amended from the previous version at "
"`https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpCompile "
"<https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpCompile>`__"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:5
msgid "C# Bindings Conda Package"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:7
msgid "The GDAL C# Bindings Conda Package is a community supported project."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:10
#: ../../source/api/python_bindings.rst:22
msgid "Installation"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:12
msgid "GDAL with the C# bindings and example applications can be loaded using"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:19
#: ../../source/api/csharp/csharp_conda.rst:51
#: ../../source/api/python_bindings.rst:116
msgid "Usage"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:21
msgid ""
"The Conda package for GDAL version 3.5.0 and later uses the CMAKE build "
"scripts and therefore there have been changes in the build process and "
"the artifacts produced."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:23
msgid ":ref:`csharp_conda_35`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:25
msgid ":ref:`csharp_conda_34`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:32
msgid "GDAL 3.5.0 and later"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:34
msgid ""
"The Conda package for GDAL version 3.5.0 and later is built using the new"
" Cmake build scripts."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:37
msgid ".NET Target Framework"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:39
msgid ""
"On all architectures (i.e. Windows, Linux and Mac), the bindings are "
"compiled using .NET6.0 as the current (at the time of writing) LTS "
"version."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:42
msgid "Package Artifacts"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:44
msgid "The Conda package contains two sets of artifacts:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:46
msgid ""
"The SWIG wrapper Dynamic Shared Objects (DSO) - :file:`gdal_wrap.dll` or "
":file:`libgdal_wrap.so` or :file:`libgdal_wrap.dylib` etc. These are "
"loaded as one would expect for a Conda package (i.e. in the :file:`bin` "
"folder in Windows and the :file:`lib` folder in Unix) and thus will "
"automatically link to the correct version of the GDAL DSO and the "
"dependencies, and"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:48
msgid ""
"Local NuGet packages for the actual C# bindings (i.e. "
":file:`gdal_csharp.dll`, :file:`gdalconst_csharp.dll`, "
":file:`osr_csharp.dll` and :file:`ogr_csharp.dll`). These are created as "
"packages called :file:`OSGeo.GDAL`, :file:`OSGeo.OSR` and "
":file:`OSGeo.OGR`. These are loaded into the :file:`share/gdal` folder."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:53
msgid ""
"To use the bindings in your application, you will need to basically do "
"the following:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:55
msgid "Add the relevant Packages to you application as local packages, and"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:56
msgid "Add the DSOs to the search path for the application."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:58
msgid ""
"The former is not complicated and can be done by defining a local source,"
" either global (as `is explained here <https://docs.microsoft.com/en-"
"us/nuget/hosting-packages/local-feeds>`__ ) or in the build command as is"
" shown below."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:60
msgid ""
"The latter can be based on Conda for a console application, as is shown "
"below, but if you are working in an IDE (which being a .NET IDE knows "
"nothing about Conda) and/or working on a GUI application (which is not "
"going to be running in a Conda environment) you are going to have to sort"
" out the DSOs your self; probably involving copying the relevant DSOs "
"into the application package."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:63
msgid "Usage Example - Windows"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:65
msgid "The most simple example would be:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:67
#: ../../source/api/csharp/csharp_conda.rst:104
msgid "Create a new application (in a dedicated empty folder)"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:69
#: ../../source/api/csharp/csharp_conda.rst:106
msgid ":program:`dotnet new console`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:71
#: ../../source/api/csharp/csharp_conda.rst:108
msgid ""
"Create a small application (by replacing the contents of "
":file:`Program.cs`)."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:91
#: ../../source/api/csharp/csharp_conda.rst:128
msgid "Add the GDAL package"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:93
msgid ""
":program:`dotnet add package OSGeo.GDAL -s "
"%CONDA_PREFIX%\\\\Library\\\\share\\\\gdal`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:95
#: ../../source/api/csharp/csharp_conda.rst:132
msgid "Compile or run"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:97
#: ../../source/api/csharp/csharp_conda.rst:134
msgid ":program:`dotnet run`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:99
msgid ""
"Provided you run these commands in a Conda environment (containing the "
"gdal-csharp package) this should just work."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:102
msgid "Usage Example - Unix"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:130
msgid ":program:`dotnet add package OSGeo.GDAL -s $CONDA_PREFIX/share/gdal`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:136
msgid ""
"This will not just work under Unix since, unlike Windows, the Library "
"Search Path is separate from the Process Search path and is not set by "
"Conda."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:138
msgid ""
"To make this work, you will probably have to change the Library search "
"path, which is ok for development but should not be accepted for "
"production (which means that you will need to copy the DSOs to the "
"application search path)."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:140
msgid "Under Linux:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:142
msgid ":program:`export LD_LIBRARY_PATH=$CONDA_PREFIX/lib`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:144
msgid "Under OSX:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:146
msgid ":program:`export DYLD_LIBRARY_PATH=$CONDA_PREFIX/lib`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:153
msgid "GDAL 3.4.x and earlier"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:156
msgid "Windows"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:158
msgid ""
"You can test if the C# bindings are working in a Conda environment by "
"running :program:`%CONDA_PREFIX%\\\\Library\\\\bin\\\\gcs\\\\gdal_test`."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:160
msgid ""
"The DLLs are loaded into the :file:`%CONDA_PREFIX%\\\\Library\\\\bin` "
"folder, as is normal for a Conda environment."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:162
msgid ""
"The  C# sample .EXEs are loaded into  "
":file:`%CONDA_PREFIX%\\\\Library\\\\bin\\\\gcs`, because otherwise they "
"over write the standard GDAL tools."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:164
msgid ""
"To run a sample application - eg GDALinfo.exe - add "
":file:`%CONDA_PREFIX%\\\\Library\\\\bin\\\\gcs` to the path and just run "
":program:`gdalinfo`."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:166
msgid ""
"To link the DLLs into your code, you will need to include the DLLs into "
"the project (which will almost certainly mean copying them to the project"
" directory)."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:168
msgid ""
"For a console app that is run from within the Conda environment (i.e. run"
" :program:`conda activate`) then they should work once compiled."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:170
msgid ""
"For GUI apps or other apps that cannot be run from with the Conda "
"environment then you will have to setup the environment to make the GDAL "
"DLLs available to the app."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:174
msgid "Mac / Linux"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:176
msgid ""
"You test if the C# bindings are working in a Conda environment by running"
" :program:`mono $CONDA_PREFIX/lib/gdal_test.exe`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:178
msgid ""
"The shared objects (i.e. :file:`\\*.so` / :file:`\\*.dylib`), the .EXE "
"and .DLL files are all loaded into the :file:`$CONDA_PREFIX/lib` folder "
"(not the :file:`bin` folder as you might expect). This is in line with "
"`the Mono documentation <https://www.mono-project.com/docs/getting-"
"started/application-deployment/>`__."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:181
msgid ""
"To run one of the sample applications (e.g. :file:`GDALinfo.exe`), run "
":program:`mono $CONDA_PREFIX/lib/GDALinfo.exe`."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:183
msgid ""
"To build a console app in Mono, you can do this in a conda environment "
"simple using a command similar to this (changing the source name to your "
"own):"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:189
msgid ""
"If the compiled executable is run in the conda environment, this should "
"work. For something more portable or a GUI app, then you have to work out"
" the dependencies your self."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:191
msgid ""
"The DLLs can also be used in a .NET project, for instance built in VS. "
"Just link the DLLs in as dependencies."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:194
msgid "Differences in the Conda build"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:196
msgid ""
"The Conda build is in some ways different from the \"standard\" GDAL "
"3.4.x build:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:198
msgid ""
"On Mac and Linux, the SWIG files are built as :file:`\\*_wrap` in line "
"with the windows versions. This means that there are no :file:`.config` "
"files. Most importantly, this means that the DLLs can be used in .NET and"
" Unity projects as well as Mono."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:199
msgid "On Windows, the sample apps are built in .NET5 and not .NET CORE 2.1."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:201
msgid "These changes anticipated the standard build for GDAL 3.5.x."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:5
msgid "C# Raster Interface"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:7
msgid ""
"The GDAL C# interface supports transferring raster data between the C# "
"application and GDAL."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:9
msgid ""
"The various :file:`Band.ReadRaster`, :file:`Band.WriteRaster`, "
":file:`Dataset.ReadRaster`, :file:`Dataset.WriteRaster` overloads are "
"involved in transferring raster data between the managed and the "
"unmanaged parts of the application."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:12
msgid ""
"This page will summarize the main aspects of raster data handling related"
" exclusively to the C# interface."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:14
msgid ""
"The :file:`Band` class contains the following "
":file:`ReadRaster`/:file:`WriteRaster` overloads:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:54
msgid ""
"The only difference between these functions is the actual type of the "
"buffer parameter. The last 2 overloads are the generic overloads and the "
"caller should write the proper marshaling code for the buffer holding the"
" raster data. The overloads that have a C# array as the buffer parameter "
"implement the proper marshaling code for the caller."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:60
msgid "Reading the raster image"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:62
msgid ""
"When reading raster data from GDAL, the user will probably create a .NET "
"image to hold C# representation of the data. The raster data can be read "
"directly or in a buffered fashion."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:66
msgid "Using the buffered read approach"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:68
msgid ""
"When reading the image this way the C# API will copy the image data "
"between the C and the C# arrays:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:88
msgid ""
"In this case the interface implementation uses an internally created "
"unmanaged array to transfer the data between the C and C++ part of the "
"code, like:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:106
msgid "Using the direct read approach"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:108
msgid ""
"Raster data can be read into the C# bitmap directly using the following "
"approach:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:127
msgid ""
"This approach is more performant than the previous since there's no need "
"to allocate an intermediary array for transferring the data."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:130
msgid "Using /unsafe code and the fixed statement"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:132
msgid ""
"In the previous examples the programmer could ignore bothering with "
"implementing the marshaling code for the raster arrays. Both of the "
"examples prevent the garbage collector from relocating the array during "
"the execution of the P/Invoke call. Without using an intermediary array "
"the programmer can also use the following method to read the raster data:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:143
msgid ""
"When using this approach the application must be compiled using the "
":program:`/unsafe` command line option."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:146
msgid "Using indexed / grayscale images"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:148
msgid ""
"The :file:`PaletteInterp` enumeration can be used to distinguish between "
"the various type of the image color interpretations."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:159
msgid ""
"When reading images with indexed color representations, the programmer "
"might have to do some extra work copying the palette over:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:192
msgid ""
"When reading grayscale images, the programmer should create a sufficient "
"palette for the .NET image."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:220
#: ../../source/api/csharp/csharp_vector.rst:212
msgid "Related C# examples"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:222
msgid ""
"The following examples demonstrate the usage of the GDAL raster "
"operations mentioned previously:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:224
msgid ":source_file:`swig/csharp/apps/GDALRead.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:225
#: ../../source/api/csharp/csharp_raster.rst:226
msgid ":source_file:`swig/csharp/apps/GDALReadDirect.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:228
msgid ""
"This document was amended from the previous version at "
"`https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpRaster "
"<https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpRaster>`__"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:5
msgid "C# Bindings Usage Advice"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:8
msgid "Adding reference to the GDAL/OGR assemblies"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:10
#: ../../source/api/csharp/csharp_usage.rst:15
msgid "TODO"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:13
msgid "Using the interface classes"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:19
msgid "Modifying Local Search Path"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:22
msgid ""
"If you want to add a folder to PATH during run-time, so you don't have to"
" pollute system PATH permanently, you can do it this way, in C#"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:43
msgid "MSDN documentation:"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:45
msgid ""
"`http://msdn2.microsoft.com/en-us/library/ms686206.aspx "
"<http://msdn2.microsoft.com/en-us/library/ms686206.aspx>`__"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:46
msgid ""
"`http://msdn2.microsoft.com/en-"
"us/library/system.environment.setenvironmentvariable.aspx "
"<http://msdn2.microsoft.com/en-"
"us/library/system.environment.setenvironmentvariable.aspx>`__"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:48
msgid ""
"Instead of the P/Invoke call to :program:`SetEnvironmentVariable()`, you "
"can use C# native method :program:`Environment.SetEnvironmentVariable()`."
" Read the doc carefully, because there are two versions of this method. "
"Unlike the Win32 API call accessed through P/Invoke, the method "
":program:`Environment.SetEnvironmentVariable()` has an overload that "
"*may* change environment permanently, across processes."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:5
msgid "C# Vector and Spatial Reference Interfaces"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:8
msgid "Basic Architecture"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:10
msgid ""
"The vector interface is within the :file:`OSGeo.OGR` namespace and the "
"spatial reference interface is within the :file:`OSGeo.OSR` namespace."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:12
msgid "The **main** classes are as follows"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:35
msgid "Accessing Feature Geometries"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:37
msgid ""
"The basic process is :file:`DataSource` => :file:`Layer` => "
":file:`Feature` => :file:`Geometry`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:40
msgid "Open a DataSource"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:42
msgid ""
"A :file:`DataSource` wraps a OGR source (e.g a filename) and is created "
"as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:63
msgid "Access the Layers"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:65
msgid ""
"Each :file:`DataSource` will have one or more layers that can be iterated"
" as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:85
msgid "Access a Layer's Features"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:87
msgid ""
"Each :file:`Layer` can have zero or more :file:`Feature` s. These should "
"be accessed as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:100
msgid "Access a Features's Geometry"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:107
msgid ":file:`Geometry` objects are nested - so for instance:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:109
msgid ""
"a :file:`Geometry` of type :file:`wkbGeometryType.wkbTIN` has multiple "
"daughter :file:`Geometry` objects of type "
":file:`wkbGeometryType.wkbTriangle`,"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:110
msgid ""
"each :file:`Geometry` object of type :file:`wkbGeometryType.wkbTriangle` "
"has a daughter :file:`Geometry` object of type "
":file:`wkbGeometryType.LinearRing`,"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:111
msgid ""
"each :file:`Geometry` of type :file:`wkbGeometryType.LinearRing` contains"
" a number of points."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:113
msgid ""
"When you get to the most basic type - which usually seems to be "
":file:`wkbGeometryType.wkbPoint`, :file:`wkbGeometryType.wkbLineString` "
"or :file:`wkbGeometryType.wkbLinearRing` or their multi- versions or 25D "
"or ZM versions, you can access the point coordinates as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:126
msgid ""
"The size of the :file:`double[]` depends on the number of dimensions of "
"the :file:`Geometry`."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:129
msgid "Access a Feature's data fields"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:131
msgid ""
"Each :file:`Feature` object can have a number of data fields associated. "
"The schema for the data fields is defined in a :file:`FieldDefn` object. "
"The fields can be fetched a follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:162
msgid "Access a Geometry's CRS"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:164
msgid ""
"If there is a CRS (aka SRS) defined for the :file:`Geometry` it can be "
"retrieved as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:170
msgid ""
"The :file:`SpatialReference` is the main class for representing the CRS /"
" projection. The CRS can be turned into a WKT string, e.g. for display "
"purposes, as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:178
msgid ""
"Sometimes the CRS defined on the layer does not cascade down to the "
"Feature - you need to refer bak to the Layer"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:182
msgid "Reproject a Geometry"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:184
msgid ""
"If the :file:`Geometry` has a valid :file:`SpatialReference` defined, "
"then the :file:`Geometry` can be transformed to a new CRS using this "
"command:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:192
msgid ""
"However, often it is better to explicitly define the "
":file:`CoordinateTransform` to be used"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:214
msgid ""
"The following examples demonstrate the usage of the OGR vector operations"
" mentioned above:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:216
msgid ":source_file:`swig/csharp/apps/ogrinfo.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:217
msgid ":source_file:`swig/csharp/apps/OGRLayerAlg.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:218
msgid ":source_file:`swig/csharp/apps/OGRFeatureEdit.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:219
msgid ":source_file:`swig/csharp/apps/OSRTransform.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:220
msgid ":source_file:`swig/csharp/apps/GetCRSInfo.cs`"
msgstr ""

#: ../../source/api/csharp/index.rst:5
msgid "C# bindings"
msgstr ""

#: ../../source/api/csharp/index.rst:7
msgid ""
"The GDAL project (primarily Tamas Szekeres) maintains SWIG generated C# "
"bindings for GDAL and OGR."
msgstr ""

#: ../../source/api/csharp/index.rst:9
msgid ""
"Generally speaking the classes and methods mostly match those of the GDAL"
" and OGR C++ classes, but there is currently no C# specific documentation"
" beyond this site."
msgstr ""

#: ../../source/api/csharp/index.rst:11
msgid "The C# bindings are also usable from other .NET languages, such as VB.Net."
msgstr ""

#: ../../source/api/csharp/index.rst:13
msgid ""
"The C# interface has been built upon the same libraries as the other SWIG"
" generated wrappers (like Python, Java). Therefore, the class names, "
"class member names, and the method signatures are driven by the GDAL+SWIG"
" conventions and might not follow the conventional .NET naming "
"guidelines. However, one can easily identify the matching members in the "
"GDAL/OGR API documentation."
msgstr ""

#: ../../source/api/csharp/index.rst:17
msgid ""
"The GDAL/OGR C# classes use the .NET P/Invoke mechanism for the "
"communication between the managed and unmanaged code. Every class "
"implements the IDisposable interface to control the finalization of the "
"underlying unmanaged memory referenced by every the wrapper class."
msgstr ""

#: ../../source/api/csharp/index.rst:21
msgid "Supported platforms"
msgstr ""

#: ../../source/api/csharp/index.rst:23
msgid "Currently the interface is compilable on and supports:"
msgstr ""

#: ../../source/api/csharp/index.rst:25
msgid ""
"the various Win32 and Win64 platforms targeting the Microsoft.NET and the"
" MONO frameworks,"
msgstr ""

#: ../../source/api/csharp/index.rst:26
msgid "GNU Linux/OSX systems using the MONO framework, and"
msgstr ""

#: ../../source/api/csharp/index.rst:27
msgid ""
"Unity systems on Windows, OSX and Linux (currently only the MONO "
"framework and not IL2CPP)."
msgstr ""

#: ../../source/api/csharp/index.rst:30
msgid "Getting GDAL for C#"
msgstr ""

#: ../../source/api/csharp/index.rst:32
msgid ""
"There are a number of ways to get the C# bindings, including but not "
"limited to:"
msgstr ""

#: ../../source/api/csharp/index.rst:34
msgid ""
"The `gisinternals <http://www.gisinternals.com/sdk>`__ site, see below "
"under \"Windows Build SDK\","
msgstr ""

#: ../../source/api/csharp/index.rst:35
msgid ""
"The `Conda package <https://anaconda.org/conda-forge/gdal-csharp>`__, see"
" instructions below"
msgstr ""

#: ../../source/api/csharp/index.rst:36
msgid "The gdal.netcore NuGet package, see link below, and"
msgstr ""

#: ../../source/api/csharp/index.rst:37
msgid ""
"For Unity, there is a UPM package that installs GDAL, `available from "
"here <https://openupm.com/packages/com.virgis.gdal/?subPage=readme>`__ "
"(available on Windows, Mac and Linux)"
msgstr ""

#: ../../source/api/csharp/index.rst:39
msgid "(all of these are community supported)"
msgstr ""

#: ../../source/api/csharp/index.rst:43
msgid "Related Documents"
msgstr ""

#: ../../source/api/csharp/index.rst:56 ../../source/api/java/index.rst:69
msgid "Useful Links"
msgstr ""

#: ../../source/api/csharp/index.rst:58
msgid ""
"A variety of example programs in CSharp are available at the "
"`/swig/csharp/apps "
"<https://github.com/OSGeo/gdal/tree/master/swig/csharp/apps>`__ folder of"
" the GDAL project tree."
msgstr ""

#: ../../source/api/csharp/index.rst:60
msgid "The Conda Feedstock"
msgstr ""

#: ../../source/api/csharp/index.rst:62
msgid ""
"A simple (as is) build engine of GDAL 3.2 library for .NET Core. `MaxRev-"
"Dev/gdal.netcore <https://github.com/MaxRev-Dev/gdal.netcore>`__"
msgstr ""

#: ../../source/api/csharp/index.rst:64
msgid ""
"The `ViRGiS project <https://www.virgis.org/>`__ makes extensive use of "
"GDAL in c# in a Unity environment."
msgstr ""

#: ../../source/api/csharp/index.rst:66
msgid "(Please add your project to this section)"
msgstr ""

#: ../../source/api/csharp/index.rst:70
msgid "Windows Build SDKs"
msgstr ""

#: ../../source/api/csharp/index.rst:72
msgid ""
"Tamas Szekeres maintains `build SDK packages "
"<http://www.gisinternals.com/sdk>`__ in order to compile GDAL from the "
"sources on Windows. The build system provides daily build binary packages"
" for the latest stable and development versions."
msgstr ""

#: ../../source/api/gdal_alg.rst:5
msgid "gdal_alg.h: GDAL Algorithms C API"
msgstr ""

#: ../../source/api/gdal_alg.rst:8
msgid "gdal_alg.h"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param pTransformerArg"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param bDstToSrc"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param nPointCount"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param x"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param y"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param z"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param panSuccess"
msgstr ""

#: ../../source/api/gdal_utils.rst:5
msgid "gdal_utils.h: GDAL Algorithms C API"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst:5
msgid "GDALAbstractMDArray C++ API"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param array"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param chunkArrayStartIdx"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param chunkCount"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param iCurChunk"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param nChunkCount"
msgstr ""

#: ../../source/api/gdalattribute_cpp.rst:5
msgid "GDALAttribute C++ API"
msgstr ""

#: ../../source/api/gdalattribute_cpp.rst:8
msgid "GDALAttribute class"
msgstr ""

#: ../../source/api/gdalattribute_cpp.rst:15
msgid "GDALIHasAttribute interface"
msgstr ""

#: ../../source/api/gdaldataset_cpp.rst:5
msgid "GDALDataset C++ API"
msgstr ""

#: ../../source/api/gdaldimension_cpp.rst:5
msgid "GDALDimension C++ API"
msgstr ""

#: ../../source/api/gdaldriver_cpp.rst:5
msgid "GDALDriver C++ API"
msgstr ""

#: ../../source/api/gdaldriver_cpp.rst:8
msgid "GDALDriver class"
msgstr ""

#: ../../source/api/gdaldriver_cpp.rst:15
msgid "GDALDriverManager class"
msgstr ""

#: ../../source/api/gdalextendeddatatype_cpp.rst:5
msgid "GDALExtendedDataType C++ API"
msgstr ""

#: ../../source/api/gdalextendeddatatype_cpp.rst:8
msgid "GDALExtendedDataType class"
msgstr ""

#: ../../source/api/gdalextendeddatatype_cpp.rst:15
msgid "GDALEDTComponent class"
msgstr ""

#: ../../source/api/gdalgroup_cpp.rst:5
msgid "GDALGroup C++ API"
msgstr ""

#: ../../source/api/gdalmdarray_cpp.rst:5
msgid "GDALMDArray C++ API"
msgstr ""

#: ../../source/api/gdalrasterband_cpp.rst:5
msgid "GDALRasterBand C++ API"
msgstr ""

#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst
msgid "Protected Functions"
msgstr ""

#: ../../source/api/gdalwarp_cpp.rst:5
msgid "Warper C++ API"
msgstr ""

#: ../../source/api/gdalwarp_cpp.rst
msgid "Friends"
msgstr ""

#: ../../source/api/gnm_cpp.rst:5
msgid "Geographic Network C++ API"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Go"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Julia"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Lua"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Original Node.js bindings"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Node.js fork with full Promise-based async and TypeScript support"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Perl"
msgstr ""

#: ../../source/api/index.rst:115
msgid "PHP"
msgstr ""

#: ../../source/api/index.rst:115
msgid "R"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Rust"
msgstr ""

#: ../../source/api/index.rst:135
msgid "Fiona"
msgstr ""

#: ../../source/api/index.rst:135
msgid "Rasterio"
msgstr ""

#: ../../source/api/index.rst:143
msgid "Godal"
msgstr ""

#: ../../source/api/index.rst:5 ../../source/api/python_bindings.rst:132
msgid "API"
msgstr ""

#: ../../source/api/index.rst:10
msgid "`Full Doxygen output <../doxygen/index.html>`_"
msgstr ""

#: ../../source/api/index.rst:13
msgid "C API"
msgstr ""

#: ../../source/api/index.rst:26
msgid "C++ API"
msgstr ""

#: ../../source/api/index.rst:29
msgid "Raster API"
msgstr ""

#: ../../source/api/index.rst:40
msgid "Vector API"
msgstr ""

#: ../../source/api/index.rst:51
msgid "Spatial reference system API"
msgstr ""

#: ../../source/api/index.rst:59
msgid "Multi-dimensional array API"
msgstr ""

#: ../../source/api/index.rst:72
msgid "Miscellaneous C++ API"
msgstr ""

#: ../../source/api/index.rst:81
msgid "Python API"
msgstr ""

#: ../../source/api/index.rst:99
msgid "`Java API <../java/index.html>`_"
msgstr ""

#: ../../source/api/index.rst:103
msgid "GDAL/OGR In Other Languages"
msgstr ""

#: ../../source/api/index.rst:105
msgid ""
"There is a set of generic `SWIG <http://www.swig.org/>`__ interface files"
" in the GDAL source tree (subdirectory swig) and a set of language "
"bindings based on those. Currently active ones are:"
msgstr ""

#: ../../source/api/index.rst:113
msgid ""
"There are also other bindings that are developed outside of the GDAL "
"source tree (**note**: those offer APIs not strictly coupled to the "
"GDAL/OGR C/C++ API). These include bindings for"
msgstr ""

#: ../../source/api/index.rst:129
msgid ""
"For Perl, since GDAL 3.5 the link `Perl "
"<https://trac.osgeo.org/gdal/wiki/GdalOgrInPerl>`__ is deprecated, use "
"above link instead."
msgstr ""

#: ../../source/api/index.rst:133
msgid "There are also more Pythonic ways of using the vector/OGR functions with"
msgstr ""

#: ../../source/api/index.rst:141
msgid "There is a more idiomatic Golang way of using the raster functions with"
msgstr ""

#: ../../source/api/index.rst:150
msgid ""
"API is omitted in this PDF document. You can consult it on "
"https://gdal.org/api/index.html"
msgstr ""

#: ../../source/api/java/index.rst:5
msgid "Java bindings"
msgstr ""

#: ../../source/api/java/index.rst:7
msgid "The GDAL project has SWIG generated Java bindings for GDAL and OGR."
msgstr ""

#: ../../source/api/java/index.rst:9
msgid ""
"Generally speaking the classes and methods mostly match those of the GDAL"
" and OGR C++ classes. You can find the `​Javadoc "
"<http://gdal.org/java>`__ of the API of the Java bindings."
msgstr ""

#: ../../source/api/java/index.rst:11
msgid ""
"Due to the fact the Java garbage collector works in a separate thread "
"from the main thread, it is necessary to configure GDAL with multi-"
"threading support, even if you do not use GDAL API from several Java "
"threads."
msgstr ""

#: ../../source/api/java/index.rst:14
msgid "How to build bindings"
msgstr ""

#: ../../source/api/java/index.rst:16
msgid ""
"Please consult the CMake :ref:`building_from_source_java` paragraph for "
"CMake options controlling how to enable the Java bindings and where to "
"install its artifacts"
msgstr ""

#: ../../source/api/java/index.rst:21
msgid "How to use the bindings"
msgstr ""

#: ../../source/api/java/index.rst:23
msgid ""
"The result of the build of the Java bindings will be both a "
":file:`gdal.jar` and a companion :file:`libgdalalljni.so` / "
":file:`libgdalalljni.dylib` / :file:`gdalalljni.dll` native library. To "
"limit potential compatibility problems, you should ensure that gdal.jar "
"and gdalalljni come from the same GDAL sources."
msgstr ""

#: ../../source/api/java/index.rst:28
msgid ""
"The native gdalalljni library, as well as the core libgdal library (and "
"its dependencies) should be accessible through the mechanism of the "
"operating system to locate shared libraries. Typically on Linux, this "
"means that the path to those libraries should be set in the "
"``LD_LIBRARY_PATH`` environment variable (or in :file:`/etc/ld.so.conf`)."
" On MacOSX, it should be in the ``DYLD_LIBRARY_PATH`` environment "
"variable. And on Windows, in the ``PATH`` environment variable."
msgstr ""

#: ../../source/api/java/index.rst:36
msgid ""
"For example, to test on Linux that the bindings are working, you can "
"lanch, from the build directory:"
msgstr ""

#: ../../source/api/java/index.rst:44
msgid "On Windows:"
msgstr ""

#: ../../source/api/java/index.rst:53
msgid "Maven Users"
msgstr ""

#: ../../source/api/java/index.rst:55
msgid ""
"The Java bindings are available from the ​`Maven Central "
"<http://search.maven.org/>`__ repository. All that is needed is to "
"declare a dependency."
msgstr ""

#: ../../source/api/java/index.rst:71
msgid "​`Javadoc <http://gdal.org/java>`__ of the API of the Java bindings."
msgstr ""

#: ../../source/api/java/index.rst:72
msgid ""
"`gdalinfo.java "
"<https://github.com/OSGeo/gdal/tree/master/swig/java/apps/gdalinfo.java>`__"
" Sample Java program similar to gdalinfo utility."
msgstr ""

#: ../../source/api/java/index.rst:73
msgid ""
"`All Java sample programs "
"<https://github.com/OSGeo/gdal/tree/master/swig/java/apps/>`__"
msgstr ""

#: ../../source/api/java/index.rst:74
msgid ""
"`Tamas Szekeres' Windows daily builds "
"<http://www.gisinternals.com/sdk>`__ : Tamas Szekeres maintains a "
"complete set of Win32 and Win64 binary packages that include the GDAL "
"Java bindings. These packages are based on the current development and "
"stable branches built from the GDAL source repository."
msgstr ""

#: ../../source/api/java/index.rst:75
msgid ""
"`Image I/O-Ext <https://imageio-ext.dev.java.net/>`__ : The main core "
"module of the project is gdalframework, a framework leveraging on GDAL "
"via SWIG's generated JAVA bindings to provide support for a reach set of "
"data formats. (**Note**: this framework doesn't necessarily ship the "
"latest released GDAL version)"
msgstr ""

#: ../../source/api/ogr_srs_api.rst:5
msgid "ogr_srs_api.h: Spatial Reference System C API"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:5
msgid "OGRFeature C++ API"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:8
msgid "OGRFeature class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:15
msgid "OGRFeatureDefn class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:22
msgid "OGRFieldDefn class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:29
msgid "OGRGeomFieldDefn class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:36
msgid "OGRFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:43
msgid "OGRCodedFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:50
msgid "OGRRangeFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:57
msgid "OGRGlobFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeaturestyle_cpp.rst:5
msgid "OGRFeature Style C++ API"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:5
msgid "OGRGeometry C++ API"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:7
msgid "Include file: ogr_geometry.h"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:10
msgid "OGRGeometryFactory class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:17
msgid "OGRGeometry class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:24
msgid "OGRPoint class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:31
msgid "OGRLineString class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:38
msgid "OGRLinearRing class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:45
msgid "OGRCircularString class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:52
msgid "OGRCurve class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:59
msgid "OGRSurface class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:66
msgid "OGRPolygon class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:73
msgid "OGRCurvePolygon class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:80
msgid "OGRMultiPoint class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:87
msgid "OGRMultiLineString class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:94
msgid "OGRMultiPolygon class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:101
msgid "OGRGeometryCollection class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:108
msgid "OGRMultiCurve class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:115
msgid "OGRMultiSurface class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:122
msgid "OGRPolyhedralSurface class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:129
msgid "OGRTriangle class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:136
msgid "OGRTriangulatedSurface class"
msgstr ""

#: ../../source/api/ogrlayer_cpp.rst:5
msgid "OGRLayer C++ API"
msgstr ""

#: ../../source/api/ogrlayer_cpp.rst ../../source/api/ogrspatialref.rst
msgid "Public Static Attributes"
msgstr ""

#: ../../source/api/ogrspatialref.rst:5
msgid "Spatial Reference System C++ API"
msgstr ""

#: ../../source/api/python/general.rst:4
msgid "Python General API"
msgstr ""

#: ../../source/api/python/general.rst:7
msgid "Configuration Management"
msgstr ""

#: ../../source/api/python/general.rst:53
msgid "Error Handling"
msgstr ""

#: of osgeo.gdal.ConfigurePythonLogging:1
msgid "Configure GDAL to use Python's logging framework"
msgstr ""

#: ../../source/api/python/general.rst:91
msgid "File Management"
msgstr ""

#: of osgeo.gdal.DirEntry:1
msgid "Proxy of C++ DirEntry class."
msgstr ""

#: of osgeo.gdal.DirEntry.extra:1
msgid "p.p.char"
msgstr ""

#: of osgeo.gdal.Band.DataType osgeo.gdal.Band.XSize osgeo.gdal.Band.YSize
#: osgeo.gdal.ColorEntry.c1 osgeo.gdal.ColorEntry.c2 osgeo.gdal.ColorEntry.c3
#: osgeo.gdal.ColorEntry.c4 osgeo.gdal.Dataset.RasterCount
#: osgeo.gdal.Dataset.RasterXSize osgeo.gdal.Dataset.RasterYSize
#: osgeo.gdal.DirEntry.extra osgeo.gdal.DirEntry.mode
#: osgeo.gdal.DirEntry.modeKnown osgeo.gdal.DirEntry.mtime
#: osgeo.gdal.DirEntry.mtimeKnown osgeo.gdal.DirEntry.name
#: osgeo.gdal.DirEntry.size osgeo.gdal.DirEntry.sizeKnown
#: osgeo.gdal.Driver.HelpTopic osgeo.gdal.Driver.LongName
#: osgeo.gdal.Driver.ShortName osgeo.gdal.GCP.GCPLine osgeo.gdal.GCP.GCPPixel
#: osgeo.gdal.GCP.GCPX osgeo.gdal.GCP.GCPY osgeo.gdal.GCP.GCPZ
#: osgeo.gdal.GCP.Id osgeo.gdal.GCP.Info osgeo.gdal.StatBuf.mode
#: osgeo.gdal.StatBuf.mtime osgeo.gdal.StatBuf.size osgeo.gdal.Statistics.max
#: osgeo.gdal.Statistics.mean osgeo.gdal.Statistics.min
#: osgeo.gdal.Statistics.std_dev osgeo.gdal.Statistics.valid_count
#: osgeo.ogr.DataSource.name osgeo.ogr.Driver.name
#: osgeo.osr.AreaOfUse.east_lon_degree osgeo.osr.AreaOfUse.name
#: osgeo.osr.AreaOfUse.north_lat_degree osgeo.osr.AreaOfUse.south_lat_degree
#: osgeo.osr.AreaOfUse.west_lon_degree osgeo.osr.CRSInfo.area_name
#: osgeo.osr.CRSInfo.auth_name osgeo.osr.CRSInfo.bbox_valid
#: osgeo.osr.CRSInfo.code osgeo.osr.CRSInfo.deprecated
#: osgeo.osr.CRSInfo.east_lon_degree osgeo.osr.CRSInfo.name
#: osgeo.osr.CRSInfo.north_lat_degree osgeo.osr.CRSInfo.projection_method
#: osgeo.osr.CRSInfo.south_lat_degree osgeo.osr.CRSInfo.type
#: osgeo.osr.CRSInfo.type:3 osgeo.osr.CRSInfo.west_lon_degree
msgid "type"
msgstr ""

#: of osgeo.gdal.DirEntry.extra:3
msgid "extra"
msgstr ""

#: of osgeo.gdal.Band.XSize:1 osgeo.gdal.Band.YSize:1
#: osgeo.gdal.Dataset.RasterCount:1 osgeo.gdal.Dataset.RasterXSize:1
#: osgeo.gdal.Dataset.RasterYSize:1 osgeo.gdal.DirEntry.mode:1
#: osgeo.gdal.StatBuf.mode:1
msgid "int"
msgstr ""

#: of osgeo.gdal.DirEntry.mode:3 osgeo.gdal.StatBuf.mode:3
msgid "mode"
msgstr ""

#: of osgeo.gdal.DirEntry.modeKnown:1 osgeo.gdal.DirEntry.mtimeKnown:1
#: osgeo.gdal.DirEntry.sizeKnown:1 osgeo.osr.CRSInfo.bbox_valid:1
#: osgeo.osr.CRSInfo.deprecated:1
msgid "bool"
msgstr ""

#: of osgeo.gdal.DirEntry.modeKnown:3
msgid "modeKnown"
msgstr ""

#: of osgeo.gdal.DirEntry.mtime:1 osgeo.gdal.DirEntry.size:1
#: osgeo.gdal.StatBuf.mtime:1 osgeo.gdal.StatBuf.size:1
#: osgeo.gdal.Statistics.valid_count:1
msgid "GIntBig"
msgstr ""

#: of osgeo.gdal.DirEntry.mtime:3 osgeo.gdal.StatBuf.mtime:3
msgid "mtime"
msgstr ""

#: of osgeo.gdal.DirEntry.mtimeKnown:3
msgid "mtimeKnown"
msgstr ""

#: of osgeo.gdal.DirEntry.name:1 osgeo.gdal.GCP.Id:1 osgeo.gdal.GCP.Info:1
#: osgeo.osr.AreaOfUse.name:1 osgeo.osr.CRSInfo.area_name:1
#: osgeo.osr.CRSInfo.auth_name:1 osgeo.osr.CRSInfo.code:1
#: osgeo.osr.CRSInfo.name:1 osgeo.osr.CRSInfo.projection_method:1
msgid "p.char"
msgstr ""

#: of osgeo.gdal.DirEntry.name:3 osgeo.ogr.DataSource.name:3
#: osgeo.ogr.Driver.name:3 osgeo.osr.AreaOfUse.name:3 osgeo.osr.CRSInfo.name:3
msgid "name"
msgstr ""

#: of osgeo.gdal.DirEntry.size:3 osgeo.gdal.StatBuf.size:3
msgid "size"
msgstr ""

#: of osgeo.gdal.DirEntry.sizeKnown:3
msgid "sizeKnown"
msgstr ""

#: of osgeo.gdal.DirEntry.thisown:1 osgeo.gdal_array.VirtualMem.thisown:1
#: osgeo.gnm.GenericNetwork.thisown:1 osgeo.gnm.Network.thisown:1
#: osgeo.ogr.DataSource.thisown:1 osgeo.ogr.Driver.thisown:1
#: osgeo.ogr.GeomTransformer.thisown:1 osgeo.ogr.MajorObject.thisown:1
#: osgeo.ogr.PreparedGeometry.thisown:1
msgid "The membership flag"
msgstr ""

#: ../../source/api/python/mdim_api.rst:4
msgid "Python Multi-dimensional array API"
msgstr ""

#: of osgeo.gdal.Group:1
msgid "Proxy of C++ GDALGroupHS class."
msgstr ""

#: of osgeo.gdal.Dimension:1
msgid "Proxy of C++ GDALDimensionHS class."
msgstr ""

#: of osgeo.gdal.MDArray:1
msgid "Proxy of C++ GDALMDArrayHS class."
msgstr ""

#: of osgeo.gdal.MDArray.GetShape:1
msgid "Return the shape of the array"
msgstr ""

#: of osgeo.gdal.MDArray.ReadAsMaskedArray:1
msgid "Return a numpy masked array of ReadAsArray() with GetMask()"
msgstr ""

#: of osgeo.gdal.MDArray.shape:1
msgid "Returns the shape of the array."
msgstr ""

#: of osgeo.gdal.Attribute:1
msgid "Proxy of C++ GDALAttributeHS class."
msgstr ""

#: of osgeo.gdal.Attribute.Read:1
msgid "Read an attribute and return it with the most appropriate type"
msgstr ""

#: of osgeo.gdal.ExtendedDataType:1
msgid "Proxy of C++ GDALExtendedDataTypeHS class."
msgstr ""

#: ../../source/api/python/osgeo.rst:4
msgid "Miscellaneous Python API"
msgstr ""

#: ../../source/api/python/osgeo.rst:8
msgid "Submodules"
msgstr ""

#: ../../source/api/python/osgeo.rst:21
msgid "Module contents"
msgstr ""

#: ../../source/api/python/osgeo.gdal.rst:2
msgid "osgeo.gdal module"
msgstr ""

#: of osgeo.gdal.AsyncReader:1 osgeo.gdal.EDTComponent:1
#: osgeo.gdal.GDALTransformerInfoShadow:1 osgeo.gdal.MajorObject:1
#: osgeo.gdal.StatBuf:1 osgeo.gdal.Statistics:1 osgeo.gdal.VSILFILE:1
#: osgeo.gdal.VirtualMem:1 osgeo.gdal_array.VirtualMem:1
#: osgeo.ogr.GeomTransformer:1 osgeo.ogr.MajorObject:1
#: osgeo.ogr.PreparedGeometry:1 osgeo.osr.AreaOfUse:1 osgeo.osr.CRSInfo:1
msgid "Bases: :py:class:`object`"
msgstr ""

#: of osgeo.gdal.AsyncReader:1
msgid "Proxy of C++ GDALAsyncReaderShadow class."
msgstr ""

#: of osgeo.gdal.EDTComponent:1
msgid "Proxy of C++ GDALEDTComponentHS class."
msgstr ""

#: of osgeo.gdal.GDALTransformerInfoShadow:1
msgid "Proxy of C++ GDALTransformerInfoShadow class."
msgstr ""

#: of osgeo.gdal.MajorObject:1 osgeo.ogr.MajorObject:1
msgid "Proxy of C++ GDALMajorObjectShadow class."
msgstr ""

#: of osgeo.gdal.StatBuf:1
msgid "Proxy of C++ StatBuf class."
msgstr ""

#: of osgeo.gdal.Statistics:1
msgid "Proxy of C++ Statistics class."
msgstr ""

#: of osgeo.gdal.GCP.GCPLine:1 osgeo.gdal.GCP.GCPPixel:1 osgeo.gdal.GCP.GCPX:1
#: osgeo.gdal.GCP.GCPY:1 osgeo.gdal.GCP.GCPZ:1 osgeo.gdal.Statistics.max:1
#: osgeo.gdal.Statistics.mean:1 osgeo.gdal.Statistics.min:1
#: osgeo.gdal.Statistics.std_dev:1 osgeo.osr.AreaOfUse.east_lon_degree:1
#: osgeo.osr.AreaOfUse.north_lat_degree:1
#: osgeo.osr.AreaOfUse.south_lat_degree:1 osgeo.osr.AreaOfUse.west_lon_degree:1
#: osgeo.osr.CRSInfo.east_lon_degree:1 osgeo.osr.CRSInfo.north_lat_degree:1
#: osgeo.osr.CRSInfo.south_lat_degree:1 osgeo.osr.CRSInfo.west_lon_degree:1
msgid "double"
msgstr ""

#: of osgeo.gdal.Statistics.max:3
msgid "max"
msgstr ""

#: of osgeo.gdal.Statistics.mean:3
msgid "mean"
msgstr ""

#: of osgeo.gdal.Statistics.min:3
msgid "min"
msgstr ""

#: of osgeo.gdal.Statistics.std_dev:3
msgid "std_dev"
msgstr ""

#: of osgeo.gdal.Statistics.valid_count:3
msgid "valid_count"
msgstr ""

#: of osgeo.gdal.VSILFILE:1
msgid "Proxy of C++ VSILFILE class."
msgstr ""

#: of osgeo.gdal.VirtualMem:1 osgeo.gdal_array.VirtualMem:1
msgid "Proxy of C++ CPLVirtualMemShadow class."
msgstr ""

#: of osgeo.gdal.listdir:1
msgid "Iterate over a directory."
msgstr ""

#: of osgeo.gdal.listdir:3
msgid "recursionLevel = -1 means unlimited level of recursion."
msgstr ""

#: ../../source/api/python/osgeo.gdal_array.rst:2
msgid "osgeo.gdal\\_array module"
msgstr ""

#: of osgeo.gdal_array.BandReadAsArray:1
msgid ""
"Pure python implementation of reading a chunk of a GDAL file into a numpy"
" array.  Used by the gdal.Band.ReadAsArray method."
msgstr ""

#: of osgeo.gdal_array.BandWriteArray:1
msgid ""
"Pure python implementation of writing a chunk of a GDAL file from a numpy"
" array.  Used by the gdal.Band.WriteArray method."
msgstr ""

#: of osgeo.gdal_array.CopyDatasetInfo:1
msgid ""
"Copy georeferencing information and metadata from one dataset to another."
" src: input dataset dst: output dataset - It can be a ROI - xoff, yoff:  "
"dst's offset with respect to src in pixel/line."
msgstr ""

#: of osgeo.gdal_array.CopyDatasetInfo:6
msgid "Notes: Destination dataset must have update access.  Certain formats"
msgstr ""

#: of osgeo.gdal_array.CopyDatasetInfo:7
msgid "do not support creation of geotransforms and/or gcps."
msgstr ""

#: of osgeo.gdal_array.DatasetReadAsArray:1
msgid ""
"Pure python implementation of reading a chunk of a GDAL file into a numpy"
" array.  Used by the gdal.Dataset.ReadAsArray method."
msgstr ""

#: of osgeo.gdal_array.DatasetWriteArray:1
msgid ""
"Pure python implementation of writing a chunk of a GDAL file from a numpy"
" array.  Used by the gdal.Dataset.WriteArray method."
msgstr ""

#: of osgeo.gdal_array.RATReadArray:1
msgid ""
"Pure Python implementation of reading a chunk of the RAT into a numpy "
"array. Called from RasterAttributeTable.ReadAsArray"
msgstr ""

#: of osgeo.gdal_array.RATWriteArray:1
msgid ""
"Pure Python implementation of writing a chunk of the RAT from a numpy "
"array. Type of array is coerced to one of the types (int, double, string)"
" supported. Called from RasterAttributeTable.WriteArray"
msgstr ""

#: ../../source/api/python/osgeo.gdalconst.rst:2
msgid "osgeo.gdalconst module"
msgstr ""

#: ../../source/api/python/osgeo.gnm.rst:2
msgid "osgeo.gnm module"
msgstr ""

#: of osgeo.gnm.GenericNetwork:1
msgid "Bases: :py:class:`~osgeo.gnm.Network`"
msgstr ""

#: of osgeo.gnm.GenericNetwork:1
msgid "Proxy of C++ GNMGenericNetworkShadow class."
msgstr ""

#: of osgeo.gnm.Network:1 osgeo.ogr.DataSource:1 osgeo.ogr.Driver:1
msgid "Bases: :py:class:`~osgeo.ogr.MajorObject`"
msgstr ""

#: of osgeo.gnm.Network:1
msgid "Proxy of C++ GNMNetworkShadow class."
msgstr ""

#: ../../source/api/python/osgeo.ogr.rst:2
msgid "osgeo.ogr module"
msgstr ""

#: of osgeo.ogr.DataSource:1
msgid "Proxy of C++ OGRDataSourceShadow class."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:1
msgid ""
"OGRLayerH OGR_DS_CopyLayer(OGRDataSourceH hDS, OGRLayerH hSrcLayer, const"
" char *pszNewName, char **papszOptions)"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:5
msgid "Duplicate an existing layer."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:7
msgid ""
"This function creates a new layer, duplicate the field definitions of the"
" source layer and then duplicate each features of the source layer. The "
"papszOptions argument can be used to control driver specific creation "
"options. These options are normally documented in the format specific "
"documentation. The source layer may come from another dataset."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:14
msgid "Deprecated Use GDALDatasetCopyLayer() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:17 osgeo.ogr.DataSource.CreateLayer:16
#: osgeo.ogr.DataSource.ExecuteSQL:23 osgeo.ogr.DataSource.GetDriver:13
#: osgeo.ogr.DataSource.GetLayerByName:12 osgeo.ogr.DataSource.GetLayerCount:9
#: osgeo.ogr.DataSource.GetName:14 osgeo.ogr.DataSource.ReleaseResultSet:14
#: osgeo.ogr.DataSource.TestCapability:27 osgeo.ogr.Feature.Clone:12
#: osgeo.ogr.Feature.DumpReadable:14 osgeo.ogr.Feature.Equal:13
#: osgeo.ogr.Feature.FillUnsetWithDefault:11 osgeo.ogr.Feature.GetDefnRef:9
#: osgeo.ogr.Feature.GetFID:11 osgeo.ogr.Feature.GetFieldAsBinary:12
#: osgeo.ogr.Feature.GetFieldAsDateTime:15
#: osgeo.ogr.Feature.GetFieldAsDouble:14
#: osgeo.ogr.Feature.GetFieldAsDoubleList:13
#: osgeo.ogr.Feature.GetFieldAsInteger:14
#: osgeo.ogr.Feature.GetFieldAsInteger64:15
#: osgeo.ogr.Feature.GetFieldAsInteger64List:13
#: osgeo.ogr.Feature.GetFieldAsIntegerList:13
#: osgeo.ogr.Feature.GetFieldAsString:14
#: osgeo.ogr.Feature.GetFieldAsStringList:15 osgeo.ogr.Feature.GetFieldCount:11
#: osgeo.ogr.Feature.GetFieldDefnRef:10 osgeo.ogr.Feature.GetFieldIndex:12
#: osgeo.ogr.Feature.GetGeomFieldCount:11
#: osgeo.ogr.Feature.GetGeomFieldDefnRef:10
#: osgeo.ogr.Feature.GetGeomFieldIndex:12 osgeo.ogr.Feature.GetGeomFieldRef:10
#: osgeo.ogr.Feature.GetGeometryRef:11 osgeo.ogr.Feature.GetNativeData:25
#: osgeo.ogr.Feature.GetNativeMediaType:15 osgeo.ogr.Feature.GetStyleString:14
#: osgeo.ogr.Feature.IsFieldNull:9 osgeo.ogr.Feature.IsFieldSet:9
#: osgeo.ogr.Feature.IsFieldSetAndNotNull:10 osgeo.ogr.Feature.SetFID:14
#: osgeo.ogr.Feature.SetFieldDoubleList:19
#: osgeo.ogr.Feature.SetFieldInteger64:20
#: osgeo.ogr.Feature.SetFieldInteger64List:19
#: osgeo.ogr.Feature.SetFieldIntegerList:19 osgeo.ogr.Feature.SetFieldNull:10
#: osgeo.ogr.Feature.SetFieldString:22 osgeo.ogr.Feature.SetFieldStringList:18
#: osgeo.ogr.Feature.SetFrom:15 osgeo.ogr.Feature.SetFromWithMap:19
#: osgeo.ogr.Feature.SetGeomField:13 osgeo.ogr.Feature.SetGeomFieldDirectly:15
#: osgeo.ogr.Feature.SetGeometry:19 osgeo.ogr.Feature.SetGeometryDirectly:20
#: osgeo.ogr.Feature.SetNativeData:15 osgeo.ogr.Feature.SetNativeMediaType:16
#: osgeo.ogr.Feature.SetStyleString:14 osgeo.ogr.Feature.UnsetField:9
#: osgeo.ogr.Feature.Validate:17 osgeo.ogr.FeatureDefn.AddFieldDefn:17
#: osgeo.ogr.FeatureDefn.AddGeomFieldDefn:19
#: osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:17
#: osgeo.ogr.FeatureDefn.GetFieldCount:9 osgeo.ogr.FeatureDefn.GetFieldDefn:10
#: osgeo.ogr.FeatureDefn.GetFieldIndex:13
#: osgeo.ogr.FeatureDefn.GetGeomFieldCount:10
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn:10
#: osgeo.ogr.FeatureDefn.GetGeomFieldIndex:14
#: osgeo.ogr.FeatureDefn.GetGeomType:13 osgeo.ogr.FeatureDefn.GetName:9
#: osgeo.ogr.FeatureDefn.GetReferenceCount:10
#: osgeo.ogr.FeatureDefn.IsGeometryIgnored:13 osgeo.ogr.FeatureDefn.IsSame:7
#: osgeo.ogr.FeatureDefn.IsStyleIgnored:10 osgeo.ogr.FeatureDefn.SetGeomType:19
#: osgeo.ogr.FeatureDefn.SetGeometryIgnored:13
#: osgeo.ogr.FeatureDefn.SetStyleIgnored:10
#: osgeo.ogr.FieldDefn.GetAlternativeNameRef:18
#: osgeo.ogr.FieldDefn.GetDefault:10 osgeo.ogr.FieldDefn.GetJustify:12
#: osgeo.ogr.FieldDefn.GetNameRef:10 osgeo.ogr.FieldDefn.GetPrecision:12
#: osgeo.ogr.FieldDefn.GetSubType:10 osgeo.ogr.FieldDefn.GetType:9
#: osgeo.ogr.FieldDefn.GetWidth:9
#: osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:15
#: osgeo.ogr.FieldDefn.IsIgnored:9 osgeo.ogr.FieldDefn.IsNullable:16
#: osgeo.ogr.FieldDefn.IsUnique:11 osgeo.ogr.FieldDefn.SetAlternativeName:19
#: osgeo.ogr.FieldDefn.SetDefault:28 osgeo.ogr.FieldDefn.SetIgnored:9
#: osgeo.ogr.FieldDefn.SetJustify:12 osgeo.ogr.FieldDefn.SetName:9
#: osgeo.ogr.FieldDefn.SetNullable:15 osgeo.ogr.FieldDefn.SetPrecision:12
#: osgeo.ogr.FieldDefn.SetSubType:13 osgeo.ogr.FieldDefn.SetType:12
#: osgeo.ogr.FieldDefn.SetUnique:16 osgeo.ogr.FieldDefn.SetWidth:9
#: osgeo.ogr.FieldDefn.justify:13 osgeo.ogr.FieldDefn.precision:13
#: osgeo.ogr.FieldDefn.type:10 osgeo.ogr.FieldDefn.width:10
#: osgeo.ogr.Geometry.AssignSpatialReference:24 osgeo.ogr.Geometry.Boundary:17
#: osgeo.ogr.Geometry.Buffer:25 osgeo.ogr.Geometry.Clone:11
#: osgeo.ogr.Geometry.CloseRings:11 osgeo.ogr.Geometry.Contains:20
#: osgeo.ogr.Geometry.ConvexHull:17 osgeo.ogr.Geometry.CoordinateDimension:10
#: osgeo.ogr.Geometry.Crosses:20 osgeo.ogr.Geometry.DelaunayTriangulation:15
#: osgeo.ogr.Geometry.Difference:21 osgeo.ogr.Geometry.Disjoint:20
#: osgeo.ogr.Geometry.Distance:17 osgeo.ogr.Geometry.Distance3D:16
#: osgeo.ogr.Geometry.Empty:13 osgeo.ogr.Geometry.Equals:19
#: osgeo.ogr.Geometry.ExportToIsoWkb:17 osgeo.ogr.Geometry.ExportToIsoWkt:15
#: osgeo.ogr.Geometry.ExportToWkb:19 osgeo.ogr.Geometry.ExportToWkt:17
#: osgeo.ogr.Geometry.FlattenTo2D:12
#: osgeo.ogr.Geometry.GetCoordinateDimension:10
#: osgeo.ogr.Geometry.GetDimension:15 osgeo.ogr.Geometry.GetEnvelope:11
#: osgeo.ogr.Geometry.GetEnvelope3D:11 osgeo.ogr.Geometry.GetGeometryName:12
#: osgeo.ogr.Geometry.GetGeometryType:14
#: osgeo.ogr.Geometry.GetSpatialReference:13 osgeo.ogr.Geometry.Intersection:23
#: osgeo.ogr.Geometry.Intersects:13 osgeo.ogr.Geometry.Is3D:8
#: osgeo.ogr.Geometry.IsEmpty:8 osgeo.ogr.Geometry.IsMeasured:9
#: osgeo.ogr.Geometry.IsRing:12 osgeo.ogr.Geometry.IsSimple:18
#: osgeo.ogr.Geometry.IsValid:12 osgeo.ogr.Geometry.MakeValid:16
#: osgeo.ogr.Geometry.Overlaps:21 osgeo.ogr.Geometry.PointOnSurface:16
#: osgeo.ogr.Geometry.Polygonize:19 osgeo.ogr.Geometry.Segmentize:13
#: osgeo.ogr.Geometry.Set3D:12 osgeo.ogr.Geometry.SetCoordinateDimension:15
#: osgeo.ogr.Geometry.SetMeasured:12 osgeo.ogr.Geometry.Simplify:14
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:15 osgeo.ogr.Geometry.SwapXY:6
#: osgeo.ogr.Geometry.SymDifference:22 osgeo.ogr.Geometry.Touches:20
#: osgeo.ogr.Geometry.Transform:22 osgeo.ogr.Geometry.TransformTo:25
#: osgeo.ogr.Geometry.Union:21 osgeo.ogr.Geometry.UnionCascaded:19
#: osgeo.ogr.Geometry.Within:20 osgeo.ogr.Geometry.WkbSize:14
#: osgeo.ogr.Layer.AlterFieldDefn:27 osgeo.ogr.Layer.Clip:34
#: osgeo.ogr.Layer.CommitTransaction:15 osgeo.ogr.Layer.CreateFeature:16
#: osgeo.ogr.Layer.CreateField:29 osgeo.ogr.Layer.CreateGeomField:29
#: osgeo.ogr.Layer.DeleteFeature:15 osgeo.ogr.Layer.DeleteField:24
#: osgeo.ogr.Layer.Erase:33 osgeo.ogr.Layer.GetExtent:25
#: osgeo.ogr.Layer.GetFIDColumn:10 osgeo.ogr.Layer.GetFeature:29
#: osgeo.ogr.Layer.GetFeatureCount:23 osgeo.ogr.Layer.GetGeomType:20
#: osgeo.ogr.Layer.GetGeometryColumn:16 osgeo.ogr.Layer.GetLayerDefn:13
#: osgeo.ogr.Layer.GetName:14 osgeo.ogr.Layer.GetNextFeature:32
#: osgeo.ogr.Layer.GetSpatialFilter:13 osgeo.ogr.Layer.GetSpatialRef:12
#: osgeo.ogr.Layer.Identity:48 osgeo.ogr.Layer.Intersection:54
#: osgeo.ogr.Layer.ReorderField:36 osgeo.ogr.Layer.ReorderFields:31
#: osgeo.ogr.Layer.ResetReading:11 osgeo.ogr.Layer.RollbackTransaction:16
#: osgeo.ogr.Layer.SetAttributeFilter:25 osgeo.ogr.Layer.SetFeature:15
#: osgeo.ogr.Layer.SetIgnoredFields:21 osgeo.ogr.Layer.SetNextByIndex:23
#: osgeo.ogr.Layer.SetSpatialFilter:32 osgeo.ogr.Layer.SetSpatialFilterRect:24
#: osgeo.ogr.Layer.StartTransaction:21 osgeo.ogr.Layer.SymDifference:42
#: osgeo.ogr.Layer.SyncToDisk:21 osgeo.ogr.Layer.TestCapability:83
#: osgeo.ogr.Layer.Union:50 osgeo.ogr.Layer.Update:41
msgid "Parameters:"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:19
msgid "hDS:  handle to the data source where to create the new layer"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:21
msgid "hSrcLayer:  handle to the source layer."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:23
msgid "pszNewName:  the name of the layer to create."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:25
msgid ""
"papszOptions:  a StringList of name=value options. Options are driver "
"specific."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:28
msgid "a handle to the layer, or NULL if an error occurs."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:1
msgid ""
"OGRLayerH OGR_DS_CreateLayer(OGRDataSourceH hDS, const char *pszName, "
"OGRSpatialReferenceH hSpatialRef, OGRwkbGeometryType eType, char "
"**papszOptions)"
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:6
msgid ""
"This function attempts to create a new layer on the data source with the "
"indicated name, coordinate system, geometry type."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:9
msgid ""
"The papszOptions argument can be used to control driver specific creation"
" options. These options are normally documented in the format specific "
"documentation."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:13
msgid "Deprecated Use GDALDatasetCreateLayer() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:18
msgid "hDS:  The dataset handle."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:20
msgid ""
"pszName:  the name for the new layer. This should ideally not match any "
"existing layer on the datasource."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:23
msgid ""
"hSpatialRef:  handle to the coordinate system to use for the new layer, "
"or NULL if no coordinate system is available. The driver might only "
"increase the reference counter of the object to take ownership, and not "
"make a full copy, so do not use OSRDestroySpatialReference(), but "
"OSRRelease() instead when you are done with the object."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:29
msgid ""
"eType:  the geometry type for the layer. Use wkbUnknown if there are no "
"constraints on the types geometry to be written."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:32
msgid ""
"papszOptions:  a StringList of name=value options. Options are driver "
"specific, and driver information can be found at the following "
"url:http://www.gdal.org/ogr_formats.html"
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:36
msgid "NULL is returned on failure, or a new OGRLayer handle on success. Example:"
msgstr ""

#: of osgeo.gdal.Dataset.DeleteLayer:1 osgeo.ogr.DataSource.DeleteLayer:1
msgid "Deletes the layer given an index or layer name"
msgstr ""

#: of osgeo.ogr.DataSource.Dereference:1 osgeo.ogr.DataSource.Reference:1
#: osgeo.ogr.Layer.Dereference:1 osgeo.ogr.Layer.Reference:1
msgid "For backwards compatibility only."
msgstr ""

#: of osgeo.ogr.DataSource.Destroy:1 osgeo.ogr.DataSource.Release:1
#: osgeo.ogr.Feature.Destroy:1 osgeo.ogr.FeatureDefn.Destroy:1
#: osgeo.ogr.FieldDefn.Destroy:1
msgid ""
"Once called, self has effectively been destroyed.  Do not access. For "
"backwards compatibility only"
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:1
msgid ""
"OGRLayerH OGR_DS_ExecuteSQL(OGRDataSourceH hDS, const char *pszStatement,"
" OGRGeometryH hSpatialFilter, const char *pszDialect)"
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:5
msgid "Execute an SQL statement against the data store."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:7
msgid ""
"The result of an SQL query is either NULL for statements that are in "
"error, or that have no results set, or an OGRLayer handle representing a "
"results set from the query. Note that this OGRLayer is in addition to the"
" layers in the data store and must be destroyed with "
"OGR_DS_ReleaseResultSet() before the data source is closed (destroyed)."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:14
msgid ""
"For more information on the SQL dialect supported internally by OGR "
"review theOGR SQL document. Some drivers (i.e. Oracle and PostGIS) pass "
"the SQL directly through to the underlying RDBMS."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:18
msgid "Starting with OGR 1.10, theSQLITE dialect can also be used."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:20
msgid "Deprecated Use GDALDatasetExecuteSQL() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:25
msgid "hDS:  handle to the data source on which the SQL query is executed."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:27
msgid "pszSQLCommand:  the SQL statement to execute."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:29
msgid ""
"hSpatialFilter:  handle to a geometry which represents a spatial filter. "
"Can be NULL."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:32
msgid ""
"pszDialect:  allows control of the statement dialect. If set to NULL, the"
" OGR SQL engine will be used, except for RDBMS drivers that will use "
"their dedicated SQL engine, unless OGRSQL is explicitly passed as the "
"dialect. Starting with OGR 1.10, the SQLITE dialect can also be used."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:38
msgid ""
"a handle to a OGRLayer containing the results of the query. Deallocate "
"with OGR_DS_ReleaseResultSet()."
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:1
msgid "OGRSFDriverH OGR_DS_GetDriver(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:4
msgid "Returns the driver that the dataset was opened with."
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:6
msgid ""
"NOTE: Starting with GDAL 2.0, it is NOT safe to cast the returned handle "
"to OGRSFDriver*. If a C++ object is needed, the handle should be cast to "
"GDALDriver*."
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:10
msgid "Deprecated Use GDALGetDatasetDriver() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:15
msgid "hDS:  handle to the datasource"
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:17
msgid ""
"NULL if driver info is not available, or pointer to a driver owned by the"
" OGRSFDriverManager."
msgstr ""

#: of osgeo.gdal.Dataset.GetLayer:1 osgeo.ogr.DataSource.GetLayer:1
msgid "Return the layer given an index or a name"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:1
msgid "OGRLayerH OGR_DS_GetLayerByName(OGRDataSourceH hDS, const char *pszName)"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:4
msgid "Fetch a layer by name."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:6
msgid ""
"The returned layer remains owned by the OGRDataSource and should not be "
"deleted by the application."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:9
msgid "Deprecated Use GDALDatasetGetLayerByName() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:14
msgid "hDS:  handle to the data source from which to get the layer."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:16
msgid "pszLayerName:  Layer the layer name of the layer to fetch."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:18
msgid ""
"a handle to the layer, or NULL if the layer is not found or an error "
"occurs."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:1
msgid "int OGR_DS_GetLayerCount(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:4
msgid "Get the number of layers in this data source."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:6
msgid "Deprecated Use GDALDatasetGetLayerCount() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:11
msgid "hDS:  handle to the data source from which to get the number of layers."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:14
msgid "layer count."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:1
msgid "const char* OGR_DS_GetName(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetName:4
msgid "Returns the name of the data source."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:6
msgid ""
"This string should be sufficient to open the data source if passed to the"
" same OGRSFDriver that this data source was opened with, but it need not "
"be exactly the same string that was used to open the data source. "
"Normally this is a filename."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:11
msgid "Deprecated Use GDALGetDescription() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetName:16
msgid "hDS:  handle to the data source to get the name from."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:18
msgid ""
"pointer to an internal name string which should not be modified or freed "
"by the caller."
msgstr ""

#: of osgeo.ogr.DataSource.GetRefCount:1
msgid "int OGR_DS_GetRefCount(OGRDataSourceH hDataSource)"
msgstr ""

#: of osgeo.ogr.DataSource.GetStyleTable:1
msgid "OGRStyleTableH OGR_DS_GetStyleTable(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetStyleTable:4 osgeo.ogr.Layer.GetStyleTable:4
msgid "Get style table."
msgstr ""

#: of osgeo.ogr.DataSource.GetSummaryRefCount:1
msgid "int OGR_DS_GetSummaryRefCount(OGRDataSourceH hDataSource)"
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:1
msgid "void OGR_DS_ReleaseResultSet(OGRDataSourceH hDS, OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:4
msgid "Release results of OGR_DS_ExecuteSQL()."
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:6
msgid ""
"This function should only be used to deallocate OGRLayers resulting from "
"an OGR_DS_ExecuteSQL() call on the same OGRDataSource. Failure to "
"deallocate a results set before destroying the OGRDataSource may cause "
"errors."
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:11
msgid "Deprecated Use GDALDatasetReleaseResultSet() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:16
msgid "hDS:  a handle to the data source on which was executed an SQL query."
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:18
msgid "hLayer:  handle to the result of a previous OGR_DS_ExecuteSQL() call."
msgstr ""

#: of osgeo.ogr.DataSource.SetStyleTable:1
msgid "void OGR_DS_SetStyleTable(OGRDataSourceH hDS, OGRStyleTableH hStyleTable)"
msgstr ""

#: of osgeo.ogr.DataSource.SetStyleTable:4 osgeo.ogr.Layer.SetStyleTable:4
msgid "Set style table."
msgstr ""

#: of osgeo.ogr.DataSource.SyncToDisk:1
msgid "OGRErr OGR_DS_SyncToDisk(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.SyncToDisk:4 osgeo.ogr.Layer.SyncToDisk:4
msgid "Flush pending changes to disk."
msgstr ""

#: of osgeo.ogr.DataSource.SyncToDisk:6
msgid "See GDALDataset::FlushCache()"
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:1
msgid "int OGR_DS_TestCapability(OGRDataSourceH hDS, const char *pszCap)"
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:4
msgid "Test if capability is available."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:6
msgid ""
"One of the following data source capability names can be passed into this"
" function, and a TRUE or FALSE value will be returned indicating whether "
"or not the capability is available for this object."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:10
msgid "ODsCCreateLayer: True if this datasource can create new layers."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:12
msgid "ODsCDeleteLayer: True if this datasource can delete existing layers."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:14
msgid ""
"ODsCCreateGeomFieldAfterCreateLayer: True if the layers of this "
"datasource support CreateGeomField() just after layer creation."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:17
msgid ""
"ODsCCurveGeometries: True if this datasource supports writing curve "
"geometries. (GDAL 2.0). In that case, OLCCurveGeometries must also be "
"declared in layers of that dataset."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:21
msgid ""
"The #define macro forms of the capability names should be used in "
"preference to the strings themselves to avoid misspelling."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:24
msgid "Deprecated Use GDALDatasetTestCapability() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:29
msgid "hDS:  handle to the data source against which to test the capability."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:31
msgid "pszCapability:  the capability to test."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:33
msgid "TRUE if capability available otherwise FALSE."
msgstr ""

#: of osgeo.gdal.Driver.HelpTopic:1 osgeo.gdal.Driver.LongName:1
#: osgeo.gdal.Driver.ShortName:1 osgeo.ogr.DataSource.name:1
#: osgeo.ogr.Driver.name:1
msgid "p.q(const).char"
msgstr ""

#: of osgeo.ogr.Driver:1
msgid "Proxy of C++ OGRDriverShadow class."
msgstr ""

#: of osgeo.ogr.GeomTransformer:1
msgid "Proxy of C++ OGRGeomTransformerShadow class."
msgstr ""

#: of osgeo.ogr.PreparedGeometry:1
msgid "Proxy of C++ OGRPreparedGeometryShadow class."
msgstr ""

#: ../../source/api/python/osgeo.osr.rst:2
msgid "osgeo.osr module"
msgstr ""

#: of osgeo.osr.AreaOfUse:1
msgid "Proxy of C++ OSRAreaOfUse class."
msgstr ""

#: of osgeo.osr.AreaOfUse.east_lon_degree:3 osgeo.osr.CRSInfo.east_lon_degree:3
msgid "east_lon_degree"
msgstr ""

#: of osgeo.osr.AreaOfUse.north_lat_degree:3
#: osgeo.osr.CRSInfo.north_lat_degree:3
msgid "north_lat_degree"
msgstr ""

#: of osgeo.osr.AreaOfUse.south_lat_degree:3
#: osgeo.osr.CRSInfo.south_lat_degree:3
msgid "south_lat_degree"
msgstr ""

#: of osgeo.osr.AreaOfUse.west_lon_degree:3 osgeo.osr.CRSInfo.west_lon_degree:3
msgid "west_lon_degree"
msgstr ""

#: of osgeo.osr.CRSInfo:1
msgid "Proxy of C++ OSRCRSInfo class."
msgstr ""

#: of osgeo.osr.CRSInfo.area_name:3
msgid "area_name"
msgstr ""

#: of osgeo.osr.CRSInfo.auth_name:3
msgid "auth_name"
msgstr ""

#: of osgeo.osr.CRSInfo.bbox_valid:3
msgid "bbox_valid"
msgstr ""

#: of osgeo.osr.CRSInfo.code:3
msgid "code"
msgstr ""

#: of osgeo.osr.CRSInfo.deprecated:3
msgid "deprecated"
msgstr ""

#: of osgeo.osr.CRSInfo.projection_method:3
msgid "projection_method"
msgstr ""

#: of osgeo.osr.CRSInfo.type:1
msgid "OSRCRSType"
msgstr ""

#: ../../source/api/python/raster_api.rst:4
msgid "Python Raster API"
msgstr ""

#: ../../source/api/python/raster_api.rst:6
msgid ""
"This page contains classes, methods, functions that relate to the GDAL "
":ref:`raster_data_model`:"
msgstr ""

#: ../../source/api/python/raster_api.rst:8
msgid "`Driver`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:9
msgid "`Dataset`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:10
msgid "`Band`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:11
msgid "`Other`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:16
msgid "Driver"
msgstr ""

#: of osgeo.gdal.Driver:1
msgid "Proxy of C++ GDALDriverShadow class."
msgstr ""

#: of osgeo.gdal.Driver.HelpTopic:3
msgid "HelpTopic"
msgstr ""

#: of osgeo.gdal.Driver.LongName:3
msgid "LongName"
msgstr ""

#: of osgeo.gdal.Driver.ShortName:3
msgid "ShortName"
msgstr ""

#: ../../source/api/python/raster_api.rst:36
msgid "Dataset"
msgstr ""

#: of osgeo.gdal.Dataset:1
msgid "Proxy of C++ GDALDatasetShadow class."
msgstr ""

#: of osgeo.gdal.Dataset.GetTiledVirtualMemArray:1
msgid ""
"Return a NumPy array for the dataset, seen as a virtual memory mapping "
"with a tile organization. If there are several bands and "
"tile_organization = gdal.GTO_TIP, an element is accessed with "
"array[tiley][tilex][y][x][band]. If there are several bands and "
"tile_organization = gdal.GTO_BIT, an element is accessed with "
"array[tiley][tilex][band][y][x]. If there are several bands and "
"tile_organization = gdal.GTO_BSQ, an element is accessed with "
"array[band][tiley][tilex][y][x]. If there is only one band, an element is"
" accessed with array[tiley][tilex][y][x]. Any reference to the array must"
" be dropped before the last reference to the related dataset is also "
"dropped."
msgstr ""

#: of osgeo.gdal.Dataset.GetVirtualMemArray:1
msgid ""
"Return a NumPy array for the dataset, seen as a virtual memory mapping. "
"If there are several bands and band_sequential = True, an element is "
"accessed with array[band][y][x]. If there are several bands and "
"band_sequential = False, an element is accessed with array[y][x][band]. "
"If there is only one band, an element is accessed with array[y][x]. Any "
"reference to the array must be dropped before the last reference to the "
"related dataset is also dropped."
msgstr ""

#: of osgeo.gdal.Dataset.RasterCount:3
msgid "RasterCount"
msgstr ""

#: of osgeo.gdal.Dataset.RasterXSize:3
msgid "RasterXSize"
msgstr ""

#: of osgeo.gdal.Dataset.RasterYSize:3
msgid "RasterYSize"
msgstr ""

#: of osgeo.gdal.Band.ReadAsArray:1 osgeo.gdal.Dataset.ReadAsArray:1
msgid ""
"Reading a chunk of a GDAL band into a numpy array. The optional "
"(buf_xsize,buf_ysize,buf_type) parameters should generally not be "
"specified if buf_obj is specified. The array is returned"
msgstr ""

#: ../../source/api/python/raster_api.rst:50
msgid "Band"
msgstr ""

#: of osgeo.gdal.Band:1
msgid "Proxy of C++ GDALRasterBandShadow class."
msgstr ""

#: of osgeo.gdal.Band.DataType:1
msgid "GDALDataType"
msgstr ""

#: of osgeo.gdal.Band.DataType:3
msgid "DataType"
msgstr ""

#: of osgeo.gdal.Band.GetTiledVirtualMemArray:1
msgid ""
"Return a NumPy array for the band, seen as a virtual memory mapping with "
"a tile organization. An element is accessed with "
"array[tiley][tilex][y][x]. Any reference to the array must be dropped "
"before the last reference to the related dataset is also dropped."
msgstr ""

#: of osgeo.gdal.Band.GetVirtualMemArray:1
#: osgeo.gdal.Band.GetVirtualMemAutoArray:1
msgid ""
"Return a NumPy array for the band, seen as a virtual memory mapping. An "
"element is accessed with array[y][x]. Any reference to the array must be "
"dropped before the last reference to the related dataset is also dropped."
msgstr ""

#: of osgeo.gdal.Band.XSize:3
msgid "XSize"
msgstr ""

#: of osgeo.gdal.Band.YSize:3
msgid "YSize"
msgstr ""

#: ../../source/api/python/raster_api.rst:62
msgid "Other"
msgstr ""

#: of osgeo.gdal.RasterAttributeTable:1
msgid "Proxy of C++ GDALRasterAttributeTableShadow class."
msgstr ""

#: of osgeo.gdal.ColorTable:1
msgid "Proxy of C++ GDALColorTableShadow class."
msgstr ""

#: of osgeo.gdal.ColorEntry:1
msgid "Proxy of C++ GDALColorEntry class."
msgstr ""

#: of osgeo.gdal.ColorEntry.c1:1 osgeo.gdal.ColorEntry.c2:1
#: osgeo.gdal.ColorEntry.c3:1 osgeo.gdal.ColorEntry.c4:1
msgid "short"
msgstr ""

#: of osgeo.gdal.ColorEntry.c1:3
msgid "c1"
msgstr ""

#: of osgeo.gdal.ColorEntry.c2:3
msgid "c2"
msgstr ""

#: of osgeo.gdal.ColorEntry.c3:3
msgid "c3"
msgstr ""

#: of osgeo.gdal.ColorEntry.c4:3
msgid "c4"
msgstr ""

#: of osgeo.gdal.GCP:1
msgid "Proxy of C++ GDAL_GCP class."
msgstr ""

#: of osgeo.gdal.GCP.GCPLine:3
msgid "GCPLine"
msgstr ""

#: of osgeo.gdal.GCP.GCPPixel:3
msgid "GCPPixel"
msgstr ""

#: of osgeo.gdal.GCP.GCPX:3
msgid "GCPX"
msgstr ""

#: of osgeo.gdal.GCP.GCPY:3
msgid "GCPY"
msgstr ""

#: of osgeo.gdal.GCP.GCPZ:3
msgid "GCPZ"
msgstr ""

#: of osgeo.gdal.GCP.Id:3
msgid "Id"
msgstr ""

#: of osgeo.gdal.GCP.Info:3
msgid "Info"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:4
msgid "Python Spatial Reference System API"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:6
msgid ""
"This page contains classes, methods and functions that relate to spatial "
"reference systems:"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:8
msgid "`SpatialReference`_"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:9
msgid "`CoordinateTransformation`_"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:12
msgid "SpatialReference"
msgstr ""

#: of osgeo.osr.SpatialReference:1
msgid "Proxy of C++ OSRSpatialReferenceShadow class."
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:20
msgid "CoordinateTransformation"
msgstr ""

#: of osgeo.osr.CoordinateTransformation:1
msgid "Proxy of C++ OSRCoordinateTransformationShadow class."
msgstr ""

#: of osgeo.osr.CoordinateTransformationOptions:1
msgid "Proxy of C++ OGRCoordinateTransformationOptions class."
msgstr ""

#: ../../source/api/python/utilities.rst:4
msgid "Python Utilities"
msgstr ""

#: ../../source/api/python/utilities.rst:7
msgid "Raster Utilities"
msgstr ""

#: of osgeo.gdal.BuildVRT:1
msgid "Build a VRT from a list of datasets. Arguments are :"
msgstr ""

#: of osgeo.gdal.BuildVRT:3 osgeo.gdal.MultiDimTranslate:3
msgid ""
"destName --- Output dataset name srcDSOrSrcDSTab --- an array of Dataset "
"objects or filenames, or a Dataset object or a filename"
msgstr ""

#: of osgeo.gdal.BuildVRT:6 osgeo.gdal.DEMProcessing:7 osgeo.gdal.Grid:6
#: osgeo.gdal.Info:5 osgeo.gdal.MultiDimInfo:5 osgeo.gdal.MultiDimTranslate:6
#: osgeo.gdal.Nearblack:6 osgeo.gdal.Rasterize:6 osgeo.gdal.Translate:6
#: osgeo.gdal.VectorTranslate:6 osgeo.gdal.Warp:6
msgid "Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.BuildVRT:6
msgid ""
"options --- return of gdal.BuildVRTOptions(), string or array of strings "
"other keywords arguments of gdal.BuildVRTOptions()"
msgstr ""

#: of osgeo.gdal.BuildVRT:8
msgid ""
"If options is provided as a gdal.BuildVRTOptions() object, other keywords"
" are ignored."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:1
msgid ""
"Create a BuildVRTOptions() object that can be passed to gdal.BuildVRT() "
"Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords.. resolution --- 'highest', 'lowest', "
"'average', 'user'. outputBounds --- output bounds as (minX, minY, maxX, "
"maxY) in target SRS. xRes, yRes --- output resolution in target SRS. "
"targetAlignedPixels --- whether to force output bounds to be multiple of "
"output resolution. separate --- whether each source file goes into a "
"separate stacked band in the VRT band. bandList --- array of band numbers"
" (index start at 1). addAlpha --- whether to add an alpha mask band to "
"the VRT when the source raster have none. resampleAlg --- resampling "
"mode. outputSRS --- assigned output SRS. allowProjectionDifference --- "
"whether to accept input datasets have not the same projection. Note: they"
" will *not* be reprojected. srcNodata --- source nodata value(s). "
"VRTNodata --- nodata values at the VRT band level. hideNodata --- whether"
" to make the VRT band not report the NoData value. callback --- callback "
"method. callback_data --- user data for callback."
msgstr ""

#: of osgeo.gdal.DEMProcessing:1
msgid "Apply a DEM processing. Arguments are :"
msgstr ""

#: of osgeo.gdal.DEMProcessing:3
msgid ""
"destName --- Output dataset name srcDS --- a Dataset object or a filename"
" processing --- one of \"hillshade\", \"slope\", \"aspect\", \"color-"
"relief\", \"TRI\", \"TPI\", \"Roughness\""
msgstr ""

#: of osgeo.gdal.DEMProcessing:7
msgid ""
"options --- return of gdal.DEMProcessingOptions(), string or array of "
"strings other keywords arguments of gdal.DEMProcessingOptions()"
msgstr ""

#: of osgeo.gdal.DEMProcessing:9
msgid ""
"If options is provided as a gdal.DEMProcessingOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:1
msgid ""
"Create a DEMProcessingOptions() object that can be passed to "
"gdal.DEMProcessing() Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. colorFilename --- (mandatory for \"color-"
"relief\") name of file that contains palette definition for the \"color-"
"relief\" processing. format --- output format (\"GTiff\", etc...) "
"creationOptions --- list of creation options computeEdges --- whether to "
"compute values at raster edges. alg --- 'Horn' (default) or "
"'ZevenbergenThorne' for hillshade, slope or aspect. 'Wilson' (default) or"
" 'Riley' for TRI band --- source band number to use zFactor --- "
"(hillshade only) vertical exaggeration used to pre-multiply the "
"elevations. scale --- ratio of vertical units to horizontal. azimuth --- "
"(hillshade only) azimuth of the light, in degrees. 0 if it comes from the"
" top of the raster, 90 from the east, ... The default value, 315, should "
"rarely be changed as it is the value generally used to generate shaded "
"maps. altitude ---(hillshade only) altitude of the light, in degrees. 90 "
"if the light comes from above the DEM, 0 if it is raking light. combined "
"--- (hillshade only) whether to compute combined shading, a combination "
"of slope and oblique shading. Only one of combined, multiDirectional and "
"igor can be specified. multiDirectional --- (hillshade only) whether to "
"compute multi-directional shading. Only one of combined, multiDirectional"
" and igor can be specified. igor --- (hillshade only) whether to use "
"Igor's hillshading from Maperitive.  Only one of combined, "
"multiDirectional and igor can be specified. slopeformat --- (slope only) "
"\"degree\" or \"percent\". trigonometric --- (aspect only) whether to "
"return trigonometric angle instead of azimuth. Thus 0deg means East, "
"90deg North, 180deg West, 270deg South. zeroForFlat --- (aspect only) "
"whether to return 0 for flat areas with slope=0, instead of -9999. "
"addAlpha --- adds an alpha band to the output file (only for processing ="
" 'color-relief') colorSelection --- (color-relief only) Determines how "
"color entries are selected from an input value. Can be "
"\"nearest_color_entry\", \"exact_color_entry\" or "
"\"linear_interpolation\". Defaults to \"linear_interpolation\" callback "
"--- callback method callback_data --- user data for callback"
msgstr ""

#: of osgeo.gdal.Grid:1
msgid "Create raster from the scattered data. Arguments are :"
msgstr ""

#: of osgeo.gdal.Grid:3 osgeo.gdal.Translate:3
msgid "destName --- Output dataset name srcDS --- a Dataset object or a filename"
msgstr ""

#: of osgeo.gdal.Grid:6
msgid ""
"options --- return of gdal.GridOptions(), string or array of strings "
"other keywords arguments of gdal.GridOptions()"
msgstr ""

#: of osgeo.gdal.Grid:8
msgid ""
"If options is provided as a gdal.GridOptions() object, other keywords are"
" ignored."
msgstr ""

#: of osgeo.gdal.GridOptions:1
msgid ""
"Create a GridOptions() object that can be passed to gdal.Grid() Keyword "
"arguments are :"
msgstr ""

#: of osgeo.gdal.GridOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"GTiff\", etc...) "
"outputType --- output type (gdalconst.GDT_Byte, etc...) width --- width "
"of the output raster in pixel height --- height of the output raster in "
"pixel creationOptions --- list of creation options outputBounds --- "
"assigned output bounds: [ulx, uly, lrx, lry] outputSRS --- assigned "
"output SRS noData --- nodata value algorithm --- e.g "
"\"invdist:power=2.0:smoothing=0.0:radius1=0.0:radius2=0.0:angle=0.0:max_points=0:min_points=0:nodata=0.0\""
" layers --- list of layers to convert SQLStatement --- SQL statement to "
"apply to the source dataset where --- WHERE clause to apply to source "
"layer(s) spatFilter --- spatial filter as (minX, minY, maxX, maxY) "
"bounding box zfield --- Identifies an attribute field on the features to "
"be used to get a Z value from. This value overrides Z value read from "
"feature geometry record. z_increase --- Addition to the attribute field "
"on the features to be used to get a Z value from. The addition should be "
"the same unit as Z value. The result value will be Z value + Z increase "
"value. The default value is 0. z_multiply - Multiplication ratio for Z "
"field. This can be used for shift from e.g. foot to meters or from  "
"elevation to deep. The result value will be (Z value + Z increase value) "
"* Z multiply value.  The default value is 1. callback --- callback method"
" callback_data --- user data for callback"
msgstr ""

#: of osgeo.gdal.Info:1 osgeo.gdal.MultiDimInfo:1
msgid "Return information on a dataset. Arguments are :"
msgstr ""

#: of osgeo.gdal.Info:3 osgeo.gdal.MultiDimInfo:3
msgid "ds --- a Dataset object or a filename"
msgstr ""

#: of osgeo.gdal.Info:5
msgid ""
"options --- return of gdal.InfoOptions(), string or array of strings "
"other keywords arguments of gdal.InfoOptions()"
msgstr ""

#: of osgeo.gdal.Info:7
msgid ""
"If options is provided as a gdal.InfoOptions() object, other keywords are"
" ignored."
msgstr ""

#: of osgeo.gdal.InfoOptions:1
msgid ""
"Create a InfoOptions() object that can be passed to gdal.Info() options "
"can be be an array of strings, a string or let empty and filled from "
"other keywords."
msgstr ""

#: of osgeo.gdal.Nearblack:1
msgid "Convert nearly black/white borders to exact value. Arguments are :"
msgstr ""

#: of osgeo.gdal.Nearblack:3 osgeo.gdal.Rasterize:3
#: osgeo.gdal.VectorTranslate:3
msgid ""
"destNameOrDestDS --- Output dataset name or object srcDS --- a Dataset "
"object or a filename"
msgstr ""

#: of osgeo.gdal.Nearblack:6
msgid ""
"options --- return of gdal.NearblackOptions(), string or array of strings"
" other keywords arguments of gdal.NearblackOptions()"
msgstr ""

#: of osgeo.gdal.Nearblack:8
msgid ""
"If options is provided as a gdal.NearblackOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.NearblackOptions:1
msgid ""
"Create a NearblackOptions() object that can be passed to gdal.Nearblack()"
" Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.NearblackOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"GTiff\", etc...) "
"creationOptions --- list of creation options white --- whether to search "
"for nearly white (255) pixels instead of nearly black pixels. colors --- "
"list of colors  to search for, e.g. ((0,0,0),(255,255,255)). The pixels "
"that are considered as the collar are set to 0 maxNonBlack --- number of "
"non-black (or other searched colors specified with white / colors) pixels"
" that can be encountered before the giving up search inwards. Defaults to"
" 2. nearDist --- select how far from black, white or custom colors the "
"pixel values can be and still considered near black, white or custom "
"color.  Defaults to 15. setAlpha --- adds an alpha band to the output "
"file. setMask --- adds a mask band to the output file. callback --- "
"callback method callback_data --- user data for callback"
msgstr ""

#: of osgeo.gdal.Rasterize:1
msgid "Burns vector geometries into a raster Arguments are :"
msgstr ""

#: of osgeo.gdal.Rasterize:6
msgid ""
"options --- return of gdal.RasterizeOptions(), string or array of strings"
" other keywords arguments of gdal.RasterizeOptions()"
msgstr ""

#: of osgeo.gdal.Rasterize:8
msgid ""
"If options is provided as a gdal.RasterizeOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:1
msgid ""
"Create a RasterizeOptions() object that can be passed to gdal.Rasterize()"
" Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"GTiff\", etc...) "
"outputType --- output type (gdalconst.GDT_Byte, etc...) creationOptions "
"--- list of creation options outputBounds --- assigned output bounds: "
"[minx, miny, maxx, maxy] outputSRS --- assigned output SRS "
"transformerOptions --- list of transformer options width --- width of the"
" output raster in pixel height --- height of the output raster in pixel "
"xRes, yRes --- output resolution in target SRS targetAlignedPixels --- "
"whether to force output bounds to be multiple of output resolution noData"
" --- nodata value initValues --- Value or list of values to pre-"
"initialize the output image bands with.  However, it is not marked as the"
" nodata value in the output file.  If only one value is given, the same "
"value is used in all the bands. bands --- list of output bands to burn "
"values into inverse --- whether to invert rasterization, i.e. burn the "
"fixed burn value, or the burn value associated  with the first feature "
"into all parts of the image not inside the provided a polygon. allTouched"
" -- whether to enable the ALL_TOUCHED rasterization option so that all "
"pixels touched by lines or polygons will be updated, not just those on "
"the line render path, or whose center point is within the polygon. "
"burnValues -- list of fixed values to burn into each band for all "
"objects. Excusive with attribute. attribute --- identifies an attribute "
"field on the features to be used for a burn-in value. The value will be "
"burned into all output bands. Excusive with burnValues. useZ --- whether "
"to indicate that a burn value should be extracted from the \"Z\" values "
"of the feature. These values are added to the burn value given by "
"burnValues or attribute if provided. As of now, only points and lines are"
" drawn in 3D. layers --- list of layers from the datasource that will be "
"used for input features. SQLStatement --- SQL statement to apply to the "
"source dataset SQLDialect --- SQL dialect ('OGRSQL', 'SQLITE', ...) where"
" --- WHERE clause to apply to source layer(s) optim --- optimization mode"
" ('RASTER', 'VECTOR') add --- set to True to use additive mode instead of"
" replace when burning values callback --- callback method callback_data "
"--- user data for callback"
msgstr ""

#: of osgeo.gdal.Translate:1
msgid "Convert a dataset. Arguments are :"
msgstr ""

#: of osgeo.gdal.Translate:6
msgid ""
"options --- return of gdal.TranslateOptions(), string or array of strings"
" other keywords arguments of gdal.TranslateOptions()"
msgstr ""

#: of osgeo.gdal.Translate:8
msgid ""
"If options is provided as a gdal.TranslateOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.TranslateOptions:1
msgid ""
"Create a TranslateOptions() object that can be passed to gdal.Translate()"
" Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.TranslateOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"GTiff\", etc...) "
"outputType --- output type (gdalconst.GDT_Byte, etc...) bandList --- "
"array of band numbers (index start at 1) maskBand --- mask band to "
"generate or not (\"none\", \"auto\", \"mask\", 1, ...) width --- width of"
" the output raster in pixel height --- height of the output raster in "
"pixel widthPct --- width of the output raster in percentage (100 = "
"original width) heightPct --- height of the output raster in percentage "
"(100 = original height) xRes --- output horizontal resolution yRes --- "
"output vertical resolution creationOptions --- list of creation options "
"srcWin --- subwindow in pixels to extract: [left_x, top_y, width, height]"
" projWin --- subwindow in projected coordinates to extract: [ulx, uly, "
"lrx, lry] projWinSRS --- SRS in which projWin is expressed strict --- "
"strict mode unscale --- unscale values with scale and offset metadata "
"scaleParams --- list of scale parameters, each of the form "
"[src_min,src_max] or [src_min,src_max,dst_min,dst_max] exponents --- list"
" of exponentiation parameters outputBounds --- assigned output bounds: "
"[ulx, uly, lrx, lry] metadataOptions --- list of metadata options "
"outputSRS --- assigned output SRS nogcp --- ignore GCP in the raster GCPs"
" --- list of GCPs noData --- nodata value (or \"none\" to unset it) "
"rgbExpand --- Color palette expansion mode: \"gray\", \"rgb\", \"rgba\" "
"stats --- whether to calculate statistics rat --- whether to write source"
" RAT resampleAlg --- resampling mode callback --- callback method "
"callback_data --- user data for callback"
msgstr ""

#: of osgeo.gdal.Warp:1
msgid "Warp one or several datasets. Arguments are :"
msgstr ""

#: of osgeo.gdal.Warp:3
msgid ""
"destNameOrDestDS --- Output dataset name or object srcDSOrSrcDSTab --- an"
" array of Dataset objects or filenames, or a Dataset object or a filename"
msgstr ""

#: of osgeo.gdal.Warp:6
msgid ""
"options --- return of gdal.WarpOptions(), string or array of strings "
"other keywords arguments of gdal.WarpOptions()"
msgstr ""

#: of osgeo.gdal.Warp:8
msgid ""
"If options is provided as a gdal.WarpOptions() object, other keywords are"
" ignored."
msgstr ""

#: of osgeo.gdal.WarpOptions:1
msgid ""
"Create a WarpOptions() object that can be passed to gdal.Warp() Keyword "
"arguments are :"
msgstr ""

#: of osgeo.gdal.WarpOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"GTiff\", etc...) "
"outputBounds --- output bounds as (minX, minY, maxX, maxY) in target SRS "
"outputBoundsSRS --- SRS in which output bounds are expressed, in the case"
" they are not expressed in dstSRS xRes, yRes --- output resolution in "
"target SRS targetAlignedPixels --- whether to force output bounds to be "
"multiple of output resolution width --- width of the output raster in "
"pixel height --- height of the output raster in pixel srcSRS --- source "
"SRS dstSRS --- output SRS coordinateOperation -- coordinate operation as "
"a PROJ string or WKT string srcAlpha --- whether to force the last band "
"of the input dataset to be considered as an alpha band dstAlpha --- "
"whether to force the creation of an output alpha band outputType --- "
"output type (gdalconst.GDT_Byte, etc...) workingType --- working type "
"(gdalconst.GDT_Byte, etc...) warpOptions --- list of warping options "
"errorThreshold --- error threshold for approximation transformer (in "
"pixels) warpMemoryLimit --- size of working buffer in MB resampleAlg --- "
"resampling mode creationOptions --- list of creation options srcNodata "
"--- source nodata value(s) dstNodata --- output nodata value(s) "
"multithread --- whether to multithread computation and I/O operations tps"
" --- whether to use Thin Plate Spline GCP transformer rpc --- whether to "
"use RPC transformer geoloc --- whether to use GeoLocation array "
"transformer polynomialOrder --- order of polynomial GCP interpolation "
"transformerOptions --- list of transformer options cutlineDSName --- "
"cutline dataset name cutlineLayer --- cutline layer name cutlineWhere ---"
" cutline WHERE clause cutlineSQL --- cutline SQL statement cutlineBlend "
"--- cutline blend distance in pixels cropToCutline --- whether to use "
"cutline extent for output bounds copyMetadata --- whether to copy source "
"metadata metadataConflictValue --- metadata data conflict value "
"setColorInterpretation --- whether to force color interpretation of input"
" bands to output bands overviewLevel --- To specify which overview level "
"of source files must be used callback --- callback method callback_data "
"--- user data for callback"
msgstr ""

#: ../../source/api/python/utilities.rst:70
msgid "Multidimensional Raster Utilities"
msgstr ""

#: of osgeo.gdal.MultiDimInfo:5
msgid ""
"options --- return of gdal.MultiDimInfoOptions(), string or array of "
"strings other keywords arguments of gdal.MultiDimInfoOptions()"
msgstr ""

#: of osgeo.gdal.MultiDimInfo:7
msgid ""
"If options is provided as a gdal.MultiDimInfoOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.MultiDimInfoOptions:1
msgid ""
"Create a MultiDimInfoOptions() object that can be passed to "
"gdal.MultiDimInfo() options can be be an array of strings, a string or "
"let empty and filled from other keywords."
msgstr ""

#: of osgeo.gdal.MultiDimTranslate:1
msgid "MultiDimTranslate one or several datasets. Arguments are :"
msgstr ""

#: of osgeo.gdal.MultiDimTranslate:6
msgid ""
"options --- return of gdal.MultiDimTranslateOptions(), string or array of"
" strings other keywords arguments of gdal.MultiDimTranslateOptions()"
msgstr ""

#: of osgeo.gdal.MultiDimTranslate:8
msgid ""
"If options is provided as a gdal.MultiDimTranslateOptions() object, other"
" keywords are ignored."
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:1
msgid ""
"Create a MultiDimTranslateOptions() object that can be passed to "
"gdal.MultiDimTranslate() Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"GTiff\", etc...) "
"creationOptions --- list of creation options arraySpecs -- list of array "
"specifications, each of them being an array name or "
"\"name={src_array_name},dstname={dst_name},transpose=[1,0],view=[:,::-1]\""
" groupSpecs -- list of group specifications, each of them being a group "
"name or \"name={src_array_name},dstname={dst_name},recursive=no\" "
"subsetSpecs -- list of subset specifications, each of them being like "
"\"{dim_name}({min_val},{max_val})\" or \"{dim_name}({slice_va})\" "
"scaleAxesSpecs -- list of dimension scaling specifications, each of them "
"being like \"{dim_name}({scale_factor})\" callback --- callback method "
"callback_data --- user data for callback"
msgstr ""

#: ../../source/api/python/utilities.rst:81
msgid "Vector Utilities"
msgstr ""

#: of osgeo.gdal.VectorTranslate:1
msgid "Convert one vector dataset Arguments are :"
msgstr ""

#: of osgeo.gdal.VectorTranslate:6
msgid ""
"options --- return of gdal.VectorTranslateOptions(), string or array of "
"strings other keywords arguments of gdal.VectorTranslateOptions()"
msgstr ""

#: of osgeo.gdal.VectorTranslate:8
msgid ""
"If options is provided as a gdal.VectorTranslateOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:1
msgid ""
"Create a VectorTranslateOptions() object that can be passed to "
"gdal.VectorTranslate() Keyword arguments are :"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:3
msgid ""
"options --- can be be an array of strings, a string or let empty and "
"filled from other keywords. format --- output format (\"ESRI Shapefile\","
" etc...) accessMode --- None for creation, 'update', 'append', "
"'overwrite' srcSRS --- source SRS dstSRS --- output SRS (with "
"reprojection if reproject = True) coordinateOperation -- coordinate "
"operation as a PROJ string or WKT string reproject --- whether to do "
"reprojection SQLStatement --- SQL statement to apply to the source "
"dataset SQLDialect --- SQL dialect ('OGRSQL', 'SQLITE', ...) where --- "
"WHERE clause to apply to source layer(s) selectFields --- list of fields "
"to select addFields --- whether to add new fields found in source layers "
"(to be used with accessMode == 'append') forceNullable --- whether to "
"drop NOT NULL constraints on newly created fields emptyStrAsNull --- "
"whether to treat empty string values as NULL spatFilter --- spatial "
"filter as (minX, minY, maxX, maxY) bounding box spatSRS --- SRS in which "
"the spatFilter is expressed. If not specified, it is assumed to be the "
"one of the layer(s) datasetCreationOptions --- list of dataset creation "
"options layerCreationOptions --- list of layer creation options layers "
"--- list of layers to convert layerName --- output layer name "
"geometryType --- output layer geometry type ('POINT', ....) dim --- "
"output dimension ('XY', 'XYZ', 'XYM', 'XYZM', 'layer_dim') "
"segmentizeMaxDist --- maximum distance between consecutive nodes of a "
"line geometry makeValid --- run MakeValid() on geometries zField --- name"
" of field to use to set the Z component of geometries resolveDomains --- "
"whether to create an additional field for each field associated with a "
"coded field domain. skipFailures --- whether to skip failures limit -- "
"maximum number of features to read per layer callback --- callback method"
" callback_data --- user data for callback"
msgstr ""

#: ../../source/api/python/vector_api.rst:4
msgid "Python Vector API"
msgstr ""

#: ../../source/api/python/vector_api.rst:6
msgid ""
"This page contains classes, methods, functions that relate to the GDAL "
":ref:`vector_data_model`. The :py:class:`Driver` and :py:class:`Dataset` "
"classes, which applies to both vector and raster data, are documented "
"with the :ref:`python_raster_api`."
msgstr ""

#: ../../source/api/python/vector_api.rst:8
msgid "`Layer`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:9
msgid "`Feature`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:10
msgid "`Geometry`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:11
msgid "`FeatureDefn`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:12
msgid "`FieldDefn`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:13
msgid "`GeomFieldDefn`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:14
msgid "`FieldDomain`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:15
msgid "`Relationship`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:16
msgid "`StyleTable`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:19
msgid "Layer"
msgstr ""

#: of osgeo.ogr.Layer:1
msgid "Proxy of C++ OGRLayerShadow class."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:1
msgid ""
"OGRErr OGR_L_AlterFieldDefn(OGRLayerH hLayer, int iField, OGRFieldDefnH "
"hNewFieldDefn, int nFlags)"
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:5
msgid "Alter the definition of an existing field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:7
msgid ""
"You must use this to alter the definition of an existing field of a real "
"layer. Internally the OGRFeatureDefn for the layer will be updated to "
"reflect the altered field. Applications should never modify the "
"OGRFeatureDefn used by a layer directly."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:12 osgeo.ogr.Layer.CreateField:12
#: osgeo.ogr.Layer.CreateGeomField:12 osgeo.ogr.Layer.DeleteField:11
#: osgeo.ogr.Layer.ReorderField:15 osgeo.ogr.Layer.ReorderFields:11
msgid ""
"This function should not be called while there are feature objects in "
"existence that were obtained or created with the previous layer "
"definition."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:16
msgid ""
"Not all drivers support this function. You can query a layer to check if "
"it supports it with the OLCAlterFieldDefn capability. Some drivers may "
"only support this method while there are still no features in the layer. "
"When it is supported, the existing features of the backing file/database "
"should be updated accordingly. Some drivers might also not support all "
"update flags."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:23
msgid "This function is the same as the C++ method OGRLayer::AlterFieldDefn()."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:29 osgeo.ogr.Layer.DeleteField:26
#: osgeo.ogr.Layer.GetGeomType:22 osgeo.ogr.Layer.GetName:16
#: osgeo.ogr.Layer.ReorderField:38 osgeo.ogr.Layer.ReorderFields:33
msgid "hLayer:  handle to the layer."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:31
msgid "iField:  index of the field whose definition must be altered."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:33
msgid "hNewFieldDefn:  new field definition"
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:35
msgid ""
"nFlags:  combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, "
"ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to"
" indicate which of the name and/or type and/or width and precision fields"
" and/or nullability from the new field definition must be taken into "
"account."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:41 osgeo.ogr.Layer.CommitTransaction:19
#: osgeo.ogr.Layer.CreateFeature:22 osgeo.ogr.Layer.CreateField:38
#: osgeo.ogr.Layer.CreateGeomField:38 osgeo.ogr.Layer.DeleteField:30
#: osgeo.ogr.Layer.ReorderField:46 osgeo.ogr.Layer.ReorderFields:39
#: osgeo.ogr.Layer.RollbackTransaction:20 osgeo.ogr.Layer.StartTransaction:25
msgid "OGRERR_NONE on success."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:17 osgeo.ogr.Geometry.Polygonize:26
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:23
#: osgeo.ogr.Layer.AlterFieldDefn:43 osgeo.ogr.Layer.DeleteField:32
#: osgeo.ogr.Layer.ReorderField:48 osgeo.ogr.Layer.ReorderFields:41
msgid "OGR 1.9.0"
msgstr ""

#: of osgeo.ogr.Layer.Clip:1
msgid ""
"OGRErr OGR_L_Clip(OGRLayerH pLayerInput, OGRLayerH pLayerMethod, "
"OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.Clip:5
msgid "Clip off areas that are not covered by the method layer."
msgstr ""

#: of osgeo.ogr.Layer.Clip:7
msgid ""
"The result layer contains features whose geometries represent areas that "
"are in the input layer and in the method layer. The features in the "
"result layer have the (possibly clipped) areas of features in the input "
"layer and the attributes from the same features. The schema of the result"
" layer can be set by the user or, if it is empty, is initialized to "
"contain all fields in the input layer."
msgstr ""

#: of osgeo.ogr.Layer.Clip:14 osgeo.ogr.Layer.Erase:13
#: osgeo.ogr.Layer.Identity:19 osgeo.ogr.Layer.Intersection:20
#: osgeo.ogr.Layer.SymDifference:22 osgeo.ogr.Layer.Union:21
#: osgeo.ogr.Layer.Update:21
msgid ""
"For best performance use the minimum amount of features in the method "
"layer and copy it into a memory layer."
msgstr ""

#: of osgeo.ogr.Layer.Clip:17 osgeo.ogr.Layer.Erase:16
#: osgeo.ogr.Layer.Identity:22 osgeo.ogr.Layer.Intersection:23
#: osgeo.ogr.Layer.SymDifference:25 osgeo.ogr.Layer.Union:24
#: osgeo.ogr.Layer.Update:24
msgid ""
"This method relies on GEOS support. Do not use unless the GEOS support is"
" compiled in.  The recognized list of options is : SKIP_FAILURES=YES/NO. "
"Set it to YES to go on, even when a feature could not be inserted or a "
"GEOS call failed."
msgstr ""

#: of osgeo.ogr.Layer.Clip:22 osgeo.ogr.Layer.Erase:21
#: osgeo.ogr.Layer.Identity:27 osgeo.ogr.Layer.Intersection:28
#: osgeo.ogr.Layer.SymDifference:30 osgeo.ogr.Layer.Union:29
#: osgeo.ogr.Layer.Update:29
msgid ""
"PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into "
"MultiPolygons, or LineStrings to MultiLineStrings."
msgstr ""

#: of osgeo.ogr.Layer.Clip:25 osgeo.ogr.Layer.Erase:24
#: osgeo.ogr.Layer.Identity:30 osgeo.ogr.Layer.Intersection:31
#: osgeo.ogr.Layer.SymDifference:33 osgeo.ogr.Layer.Union:32
#: osgeo.ogr.Layer.Update:32
msgid ""
"INPUT_PREFIX=string. Set a prefix for the field names that will be "
"created from the fields of the input layer."
msgstr ""

#: of osgeo.ogr.Layer.Clip:28 osgeo.ogr.Layer.Erase:27
#: osgeo.ogr.Layer.Identity:33 osgeo.ogr.Layer.Intersection:34
#: osgeo.ogr.Layer.SymDifference:36 osgeo.ogr.Layer.Union:35
#: osgeo.ogr.Layer.Update:35
msgid ""
"METHOD_PREFIX=string. Set a prefix for the field names that will be "
"created from the fields of the method layer."
msgstr ""

#: of osgeo.ogr.Layer.Clip:31
msgid "This function is the same as the C++ method OGRLayer::Clip()."
msgstr ""

#: of osgeo.ogr.Layer.Clip:36 osgeo.ogr.Layer.Erase:35
#: osgeo.ogr.Layer.Identity:50 osgeo.ogr.Layer.Intersection:56
#: osgeo.ogr.Layer.SymDifference:44 osgeo.ogr.Layer.Union:52
#: osgeo.ogr.Layer.Update:43
msgid "pLayerInput:  the input layer. Should not be NULL."
msgstr ""

#: of osgeo.ogr.Layer.Clip:38 osgeo.ogr.Layer.Erase:37
#: osgeo.ogr.Layer.Identity:52 osgeo.ogr.Layer.Intersection:58
#: osgeo.ogr.Layer.SymDifference:46 osgeo.ogr.Layer.Union:54
#: osgeo.ogr.Layer.Update:45
msgid "pLayerMethod:  the method layer. Should not be NULL."
msgstr ""

#: of osgeo.ogr.Layer.Clip:40 osgeo.ogr.Layer.Erase:39
#: osgeo.ogr.Layer.Identity:54 osgeo.ogr.Layer.Intersection:60
#: osgeo.ogr.Layer.SymDifference:48 osgeo.ogr.Layer.Union:56
#: osgeo.ogr.Layer.Update:47
msgid ""
"pLayerResult:  the layer where the features resulting from the operation "
"are inserted. Should not be NULL. See above the note about the schema."
msgstr ""

#: of osgeo.ogr.Layer.Clip:44 osgeo.ogr.Layer.Erase:43
#: osgeo.ogr.Layer.Identity:58 osgeo.ogr.Layer.Intersection:64
#: osgeo.ogr.Layer.SymDifference:52 osgeo.ogr.Layer.Union:60
#: osgeo.ogr.Layer.Update:51
msgid "papszOptions:  NULL terminated list of options (may be NULL)."
msgstr ""

#: of osgeo.ogr.Layer.Clip:46 osgeo.ogr.Layer.Erase:45
#: osgeo.ogr.Layer.Identity:60 osgeo.ogr.Layer.Intersection:66
#: osgeo.ogr.Layer.SymDifference:54 osgeo.ogr.Layer.Union:62
#: osgeo.ogr.Layer.Update:53
msgid ""
"pfnProgress:  a GDALProgressFunc() compatible callback function for "
"reporting progress or NULL."
msgstr ""

#: of osgeo.ogr.Layer.Clip:49 osgeo.ogr.Layer.Erase:48
#: osgeo.ogr.Layer.Identity:63 osgeo.ogr.Layer.Intersection:69
#: osgeo.ogr.Layer.SymDifference:57 osgeo.ogr.Layer.Union:65
#: osgeo.ogr.Layer.Update:56
msgid "pProgressArg:  argument to be passed to pfnProgress. May be NULL."
msgstr ""

#: of osgeo.ogr.Layer.Clip:51 osgeo.ogr.Layer.Erase:50
#: osgeo.ogr.Layer.Identity:65 osgeo.ogr.Layer.Intersection:71
#: osgeo.ogr.Layer.SymDifference:59 osgeo.ogr.Layer.Union:67
#: osgeo.ogr.Layer.Update:58
msgid ""
"an error code if there was an error or the execution was interrupted, "
"OGRERR_NONE otherwise."
msgstr ""

#: of osgeo.ogr.Layer.Clip:54 osgeo.ogr.Layer.Erase:53
#: osgeo.ogr.Layer.Identity:68 osgeo.ogr.Layer.Intersection:74
#: osgeo.ogr.Layer.SymDifference:62 osgeo.ogr.Layer.Union:70
#: osgeo.ogr.Layer.Update:61
msgid "The first geometry field is always used."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:22 osgeo.ogr.Layer.Clip:56
#: osgeo.ogr.Layer.Erase:55 osgeo.ogr.Layer.Identity:70
#: osgeo.ogr.Layer.Intersection:76 osgeo.ogr.Layer.SymDifference:64
#: osgeo.ogr.Layer.Union:72 osgeo.ogr.Layer.Update:63
msgid "OGR 1.10"
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:1
msgid "OGRErr OGR_L_CommitTransaction(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:4
msgid ""
"For datasources which support transactions, CommitTransaction commits a "
"transaction."
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:7
msgid ""
"If no transaction is active, or the commit fails, will return "
"OGRERR_FAILURE. Datasources which do not support transactions will always"
" return OGRERR_NONE."
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:11
msgid "This function is the same as the C++ method OGRLayer::CommitTransaction()."
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:17 osgeo.ogr.Layer.DeleteFeature:17
#: osgeo.ogr.Layer.GetFIDColumn:12 osgeo.ogr.Layer.GetGeometryColumn:18
#: osgeo.ogr.Layer.RollbackTransaction:18 osgeo.ogr.Layer.SetNextByIndex:25
#: osgeo.ogr.Layer.StartTransaction:23 osgeo.ogr.Layer.SyncToDisk:23
msgid "hLayer:  handle to the layer"
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:1
msgid "OGRErr OGR_L_CreateFeature(OGRLayerH hLayer, OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:4
msgid "Create and write a new feature within a layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:6
msgid ""
"The passed feature is written to the layer as a new feature, rather than "
"overwriting an existing one. If the feature has a feature id other than "
"OGRNullFID, then the native implementation may use that as the feature id"
" of the new feature, but not necessarily. Upon successful return the "
"passed feature will have been updated with the new feature id."
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:13
msgid "This function is the same as the C++ method OGRLayer::CreateFeature()."
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:18
msgid "hLayer:  handle to the layer to write the feature to."
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:20
msgid "hFeat:  the handle of the feature to write to disk."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:1
msgid ""
"OGRErr OGR_L_CreateField(OGRLayerH hLayer, OGRFieldDefnH hField, int "
"bApproxOK)"
msgstr ""

#: of osgeo.ogr.Layer.CreateField:5
msgid "Create a new field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:7
msgid ""
"You must use this to create new fields on a real layer. Internally the "
"OGRFeatureDefn for the layer will be updated to reflect the new field. "
"Applications should never modify the OGRFeatureDefn used by a layer "
"directly."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:16 osgeo.ogr.Layer.CreateGeomField:16
msgid ""
"Not all drivers support this function. You can query a layer to check if "
"it supports it with the OLCCreateField capability. Some drivers may only "
"support this method while there are still no features in the layer. When "
"it is supported, the existing features of the backing file/database "
"should be updated accordingly."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:22 osgeo.ogr.Layer.CreateGeomField:22
msgid ""
"Drivers may or may not support not-null constraints. If they support "
"creating fields with not-null constraints, this is generally before "
"creating any feature to the layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:26 osgeo.ogr.Layer.CreateGeomField:26
msgid "This function is the same as the C++ method OGRLayer::CreateField()."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:31 osgeo.ogr.Layer.CreateGeomField:31
msgid "hLayer:  handle to the layer to write the field definition."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:33
msgid "hField:  handle of the field definition to write to disk."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:35 osgeo.ogr.Layer.CreateGeomField:35
msgid ""
"bApproxOK:  If TRUE, the field may be created in a slightly different "
"form depending on the limitations of the format driver."
msgstr ""

#: of osgeo.ogr.Layer.CreateFields:1
msgid "Create a list of fields on the Layer"
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:1
msgid ""
"OGRErr OGR_L_CreateGeomField(OGRLayerH hLayer, OGRGeomFieldDefnH hField, "
"int bApproxOK)"
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:5
msgid "Create a new geometry field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:7
msgid ""
"You must use this to create new geometry fields on a real layer. "
"Internally the OGRFeatureDefn for the layer will be updated to reflect "
"the new field. Applications should never modify the OGRFeatureDefn used "
"by a layer directly."
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:33
msgid "hField:  handle of the geometry field definition to write to disk."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:16 osgeo.ogr.Layer.CreateGeomField:40
msgid "OGR 1.11"
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:1
msgid "OGRErr OGR_L_DeleteFeature(OGRLayerH hLayer, GIntBig nFID)"
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:4
msgid "Delete feature from layer."
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:6
msgid ""
"The feature with the indicated feature id is deleted from the layer if "
"supported by the driver. Most drivers do not support feature deletion, "
"and will return OGRERR_UNSUPPORTED_OPERATION. The OGR_L_TestCapability() "
"function may be called with OLCDeleteFeature to check if the driver "
"supports feature deletion."
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:12
msgid "This method is the same as the C++ method OGRLayer::DeleteFeature()."
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:19
msgid "nFID:  the feature id to be deleted from the layer"
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:21 osgeo.ogr.Layer.SetFeature:21
msgid ""
"OGRERR_NONE if the operation works, otherwise an appropriate error code "
"(e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist)."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:1
msgid "OGRErr OGR_L_DeleteField(OGRLayerH hLayer, int iField)"
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:4
msgid "Delete an existing field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:6
msgid ""
"You must use this to delete existing fields on a real layer. Internally "
"the OGRFeatureDefn for the layer will be updated to reflect the deleted "
"field. Applications should never modify the OGRFeatureDefn used by a "
"layer directly."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:15
msgid ""
"Not all drivers support this function. You can query a layer to check if "
"it supports it with the OLCDeleteField capability. Some drivers may only "
"support this method while there are still no features in the layer. When "
"it is supported, the existing features of the backing file/database "
"should be updated accordingly."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:21
msgid "This function is the same as the C++ method OGRLayer::DeleteField()."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:28
msgid "iField:  index of the field to delete."
msgstr ""

#: of osgeo.ogr.Layer.Erase:1
msgid ""
"OGRErr OGR_L_Erase(OGRLayerH pLayerInput, OGRLayerH pLayerMethod, "
"OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.Erase:5
msgid "Remove areas that are covered by the method layer."
msgstr ""

#: of osgeo.ogr.Layer.Erase:7
msgid ""
"The result layer contains features whose geometries represent areas that "
"are in the input layer but not in the method layer. The features in the "
"result layer have attributes from the input layer. The schema of the "
"result layer can be set by the user or, if it is empty, is initialized to"
" contain all fields in the input layer."
msgstr ""

#: of osgeo.ogr.Layer.Erase:30
msgid "This function is the same as the C++ method OGRLayer::Erase()."
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:1
msgid ""
"int OGR_L_FindFieldIndex(OGRLayerH hLayer, const char *pszFieldName, int "
"bExactMatch)"
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:5
msgid "Find the index of field in a layer."
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:7
msgid ""
"The returned number is the index of the field in the layers, or -1 if the"
" field doesn't exist."
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:10
msgid ""
"If bExactMatch is set to FALSE and the field doesn't exists in the given "
"form the driver might apply some changes to make it match, like those it "
"might do if the layer was created (eg. like LAUNDER in the OCI driver)."
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:15
msgid "This method is the same as the C++ method OGRLayer::FindFieldIndex()."
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:17
msgid "field index, or -1 if the field doesn't exist"
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:1
msgid ""
"OGRErr OGR_L_GetExtent(OGRLayerH hLayer, OGREnvelope *psExtent, int "
"bForce)"
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:4
msgid "Fetch the extent of this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:6
msgid ""
"Returns the extent (MBR) of the data in the layer. If bForce is FALSE, "
"and it would be expensive to establish the extent then OGRERR_FAILURE "
"will be returned indicating that the extent isn't know. If bForce is TRUE"
" then some implementations will actually scan the entire layer once to "
"compute the MBR of all the features in the layer."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:12
msgid ""
"Depending on the drivers, the returned extent may or may not take the "
"spatial filter into account. So it is safer to call OGR_L_GetExtent() "
"without setting a spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:16
msgid ""
"Layers without any geometry may return OGRERR_FAILURE just indicating "
"that no meaningful extents could be collected."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:19 osgeo.ogr.Layer.GetFeatureCount:15
msgid ""
"Note that some implementations of this method may alter the read cursor "
"of the layer."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:22
msgid "This function is the same as the C++ method OGRLayer::GetExtent()."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:27
msgid "hLayer:  handle to the layer from which to get extent."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:29
msgid "psExtent:  the structure in which the extent value will be returned."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:31
msgid ""
"bForce:  Flag indicating whether the extent should be computed even if it"
" is expensive."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:34
msgid "OGRERR_NONE on success, OGRERR_FAILURE if extent not known."
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:1
msgid "const char* OGR_L_GetFIDColumn(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:4
msgid ""
"This method returns the name of the underlying database column being used"
" as the FID column, or \"\" if not supported."
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:7
msgid "This method is the same as the C++ method OGRLayer::GetFIDColumn()"
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:14
msgid "fid column name."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:1
msgid "OGRFeatureH OGR_L_GetFeature(OGRLayerH hLayer, GIntBig nFeatureId)"
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:4
msgid "Fetch a feature by its identifier."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:6
msgid ""
"This function will attempt to read the identified feature. The nFID value"
" cannot be OGRNullFID. Success or failure of this operation is unaffected"
" by the spatial or attribute filters (and specialized implementations in "
"drivers should make sure that they do not take into account spatial or "
"attribute filters)."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:12
msgid ""
"If this function returns a non-NULL feature, it is guaranteed that its "
"feature id ( OGR_F_GetFID()) will be the same as nFID."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:15
msgid ""
"Use OGR_L_TestCapability(OLCRandomRead) to establish if this layer "
"supports efficient random access reading via OGR_L_GetFeature(); however,"
" the call should always work if the feature exists as a fallback "
"implementation just scans all the features in the layer looking for the "
"desired feature."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:21
msgid ""
"Sequential reads (with OGR_L_GetNextFeature()) are generally considered "
"interrupted by a OGR_L_GetFeature() call."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:24
msgid "The returned feature should be free with OGR_F_Destroy()."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:26
msgid "This function is the same as the C++ method OGRLayer::GetFeature( )."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:31
msgid "hLayer:  handle to the layer that owned the feature."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:33
msgid "nFeatureId:  the feature id of the feature to read."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:35
msgid "a handle to a feature now owned by the caller, or NULL on failure."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:1
msgid "GIntBig OGR_L_GetFeatureCount(OGRLayerH hLayer, int bForce)"
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:4
msgid "Fetch the feature count in this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:6
msgid ""
"Returns the number of features in the layer. For dynamic databases the "
"count may not be exact. If bForce is FALSE, and it would be expensive to "
"establish the feature count a value of -1 may be returned indicating that"
" the count isn't know. If bForce is TRUE some implementations will "
"actually scan the entire layer once to count objects."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:13
msgid "The returned count takes the spatial filter into account."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:18
msgid "This function is the same as the CPP OGRLayer::GetFeatureCount()."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:20
msgid "Note: since GDAL 2.0, this method returns a GIntBig (previously a int)"
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:25
msgid "hLayer:  handle to the layer that owned the features."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:27
msgid ""
"bForce:  Flag indicating whether the count should be computed even if it "
"is expensive."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:30
msgid "feature count, -1 if count not known."
msgstr ""

#: of osgeo.ogr.Layer.GetFeaturesRead:1
msgid "GIntBig OGR_L_GetFeaturesRead(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:1
msgid "OGRwkbGeometryType OGR_L_GetGeomType(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:4
msgid "Return the layer geometry type."
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:6
msgid ""
"This returns the same result as "
"OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, "
"calling OGR_L_GetGeomType() directly can avoid lengthy layer definition "
"initialization."
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:11
msgid ""
"For layers with multiple geometry fields, this method only returns the "
"geometry type of the first geometry column. For other columns, use "
"OGR_GFld_GetType(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i))."
" For layers without any geometry field, this method returns wkbNone."
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:17
msgid "This function is the same as the C++ method OGRLayer::GetGeomType()."
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:24
msgid "the geometry type"
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:24 osgeo.ogr.Geometry.Simplify:22
#: osgeo.ogr.Geometry.SymDifference:31 osgeo.ogr.Layer.GetGeomType:26
#: osgeo.ogr.Layer.GetName:20
msgid "OGR 1.8.0"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:1
msgid "const char* OGR_L_GetGeometryColumn(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:4
msgid ""
"This method returns the name of the underlying database column being used"
" as the geometry column, or \"\" if not supported."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:7
msgid ""
"For layers with multiple geometry fields, this method only returns the "
"geometry type of the first geometry column. For other columns, use OGR "
"_GFld_GetNameRef(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i))."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:12
msgid "This method is the same as the C++ method OGRLayer::GetGeometryColumn()"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:20
msgid "geometry column name."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:1
msgid "OGRFeatureDefnH OGR_L_GetLayerDefn(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:4
msgid "Fetch the schema information for this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:6
msgid ""
"The returned handle to the OGRFeatureDefn is owned by the OGRLayer, and "
"should not be modified or freed by the application. It encapsulates the "
"attribute schema of the features of the layer."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:10
msgid "This function is the same as the C++ method OGRLayer::GetLayerDefn()."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:15
msgid "hLayer:  handle to the layer to get the schema information."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:17
msgid "a handle to the feature definition."
msgstr ""

#: of osgeo.ogr.Layer.GetName:1
msgid "const char* OGR_L_GetName(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetName:4
msgid "Return the layer name."
msgstr ""

#: of osgeo.ogr.Layer.GetName:6
msgid ""
"This returns the same content as "
"OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, "
"calling OGR_L_GetName() directly can avoid lengthy layer definition "
"initialization."
msgstr ""

#: of osgeo.ogr.Layer.GetName:11
msgid "This function is the same as the C++ method OGRLayer::GetName()."
msgstr ""

#: of osgeo.ogr.Layer.GetName:18
msgid "the layer name (must not been freed)"
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:1
msgid "OGRFeatureH OGR_L_GetNextFeature(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:4
msgid "Fetch the next available feature from this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:6
msgid ""
"The returned feature becomes the responsibility of the caller to delete "
"with OGR_F_Destroy(). It is critical that all features associated with an"
" OGRLayer (more specifically an OGRFeatureDefn) be deleted before that "
"layer/datasource is deleted."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:11
msgid ""
"Only features matching the current spatial filter (set with "
"SetSpatialFilter()) will be returned."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:14
msgid ""
"This function implements sequential access to the features of a layer. "
"The OGR_L_ResetReading() function can be used to start at the beginning "
"again."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:18
msgid ""
"Features returned by OGR_GetNextFeature() may or may not be affected by "
"concurrent modifications depending on drivers. A guaranteed way of seeing"
" modifications in effect is to call OGR_L_ResetReading() on layers where "
"OGR_GetNextFeature() has been called, before reading again. Structural "
"changes in layers (field addition, deletion, ...) when a read is in "
"progress may or may not be possible depending on drivers. If a "
"transaction is committed/aborted, the current sequential reading may or "
"may not be valid after that operation and a call to OGR_L_ResetReading() "
"might be needed."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:28
msgid "This function is the same as the C++ method OGRLayer::GetNextFeature()."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:34
msgid "hLayer:  handle to the layer from which feature are read."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:36
msgid "a handle to a feature, or NULL if no more features are available."
msgstr ""

#: of osgeo.ogr.Layer.GetRefCount:1
msgid "int OGR_L_GetRefCount(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:1
msgid "OGRGeometryH OGR_L_GetSpatialFilter(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:4
msgid "This function returns the current spatial filter for this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:6
msgid ""
"The returned pointer is to an internally owned object, and should not be "
"altered or deleted by the caller."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:9
msgid "This function is the same as the C++ method OGRLayer::GetSpatialFilter()."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:15
msgid "hLayer:  handle to the layer to get the spatial filter from."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:17
msgid "a handle to the spatial filter geometry."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:1
msgid "OGRSpatialReferenceH OGR_L_GetSpatialRef(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:4
msgid "Fetch the spatial reference system for this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:6
msgid ""
"The returned object is owned by the OGRLayer and should not be modified "
"or freed by the application."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:9
msgid "This function is the same as the C++ method OGRLayer::GetSpatialRef()."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:14
msgid "hLayer:  handle to the layer to get the spatial reference from."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:16
msgid "spatial reference, or NULL if there isn't one."
msgstr ""

#: of osgeo.ogr.Layer.GetStyleTable:1
msgid "OGRStyleTableH OGR_L_GetStyleTable(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.Identity:1
msgid ""
"OGRErr OGR_L_Identity(OGRLayerH pLayerInput, OGRLayerH pLayerMethod, "
"OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.Identity:5
msgid "Identify the features of this layer with the ones from the identity layer."
msgstr ""

#: of osgeo.ogr.Layer.Identity:8
msgid ""
"The result layer contains features whose geometries represent areas that "
"are in the input layer. The features in the result layer have attributes "
"from both input and method layers. The schema of the result layer can be "
"set by the user or, if it is empty, is initialized to contain all fields "
"in input and method layers."
msgstr ""

#: of osgeo.ogr.Layer.Identity:14 osgeo.ogr.Layer.SymDifference:17
#: osgeo.ogr.Layer.Union:16
msgid ""
"If the schema of the result is set by user and contains fields that have "
"the same name as a field in input and in method layer, then the attribute"
" in the result feature will get the value from the feature of the method "
"layer (even if it is undefined)."
msgstr ""

#: of osgeo.ogr.Layer.Identity:36 osgeo.ogr.Layer.Intersection:37
#: osgeo.ogr.Layer.Union:38
msgid ""
"USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries "
"to pretest intersection of features of method layer with features of this"
" layer."
msgstr ""

#: of osgeo.ogr.Layer.Identity:40 osgeo.ogr.Layer.Intersection:46
#: osgeo.ogr.Layer.Union:42
msgid ""
"KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features"
" with lower dimension geometry that would otherwise be added to the "
"result layer. The default is to add but only if the result layer has an "
"unknown geometry type."
msgstr ""

#: of osgeo.ogr.Layer.Identity:45
msgid "This function is the same as the C++ method OGRLayer::Identity()."
msgstr ""

#: of osgeo.ogr.Layer.Intersection:1
msgid ""
"OGRErr OGR_L_Intersection(OGRLayerH pLayerInput, OGRLayerH pLayerMethod, "
"OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.Intersection:6
msgid "Intersection of two layers."
msgstr ""

#: of osgeo.ogr.Layer.Intersection:8
msgid ""
"The result layer contains features whose geometries represent areas that "
"are common between features in the input layer and in the method layer. "
"The features in the result layer have attributes from both input and "
"method layers. The schema of the result layer can be set by the user or, "
"if it is empty, is initialized to contain all fields in the input and "
"method layers."
msgstr ""

#: of osgeo.ogr.Layer.Intersection:15
msgid ""
"If the schema of the result is set by user and contains fields that have "
"the same name as a field in input and in method layer, then the attribute"
" in the result feature will get the value from the feature of the method "
"layer."
msgstr ""

#: of osgeo.ogr.Layer.Intersection:41
msgid ""
"PRETEST_CONTAINMENT=YES/NO. Set to YES to pretest the containment of "
"features of method layer within the features of this layer. This will "
"speed up the method significantly in some cases. Requires that the "
"prepared geometries are in effect."
msgstr ""

#: of osgeo.ogr.Layer.Intersection:51
msgid "This function is the same as the C++ method OGRLayer::Intersection()."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:1
msgid ""
"OGRErr OGR_L_ReorderField(OGRLayerH hLayer, int iOldFieldPos, int "
"iNewFieldPos)"
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:5
msgid "Reorder an existing field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:7
msgid ""
"This function is a convenience wrapper of OGR_L_ReorderFields() dedicated"
" to move a single field."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:10 osgeo.ogr.Layer.ReorderFields:6
msgid ""
"You must use this to reorder existing fields on a real layer. Internally "
"the OGRFeatureDefn for the layer will be updated to reflect the "
"reordering of the fields. Applications should never modify the "
"OGRFeatureDefn used by a layer directly."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:19
msgid ""
"The field definition that was at initial position iOldFieldPos will be "
"moved at position iNewFieldPos, and elements between will be shuffled "
"accordingly."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:23
msgid ""
"For example, let suppose the fields were \"0\",\"1\",\"2\",\"3\",\"4\" "
"initially. ReorderField(1, 3) will reorder them as "
"\"0\",\"2\",\"3\",\"1\",\"4\"."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:27 osgeo.ogr.Layer.ReorderFields:22
msgid ""
"Not all drivers support this function. You can query a layer to check if "
"it supports it with the OLCReorderFields capability. Some drivers may "
"only support this method while there are still no features in the layer. "
"When it is supported, the existing features of the backing file/database "
"should be updated accordingly."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:33
msgid "This function is the same as the C++ method OGRLayer::ReorderField()."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:40
msgid ""
"iOldFieldPos:  previous position of the field to move. Must be in the "
"range [0,GetFieldCount()-1]."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:43
msgid ""
"iNewFieldPos:  new position of the field to move. Must be in the range "
"[0,GetFieldCount()-1]."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:1
msgid "OGRErr OGR_L_ReorderFields(OGRLayerH hLayer, int *panMap)"
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:4
msgid "Reorder all the fields of a layer."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:15
msgid ""
"panMap is such that,for each field definition at position i after "
"reordering, its position before reordering was panMap[i]."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:18
msgid ""
"For example, let suppose the fields were \"0\",\"1\",\"2\",\"3\",\"4\" "
"initially. ReorderFields([0,2,3,1,4]) will reorder them as "
"\"0\",\"2\",\"3\",\"1\",\"4\"."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:28
msgid "This function is the same as the C++ method OGRLayer::ReorderFields()."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:35
msgid ""
"panMap:  an array of GetLayerDefn()-> OGRFeatureDefn::GetFieldCount() "
"elements which is a permutation of [0, GetLayerDefn()-> "
"OGRFeatureDefn::GetFieldCount()-1]."
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:1
msgid "void OGR_L_ResetReading(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:4
msgid "Reset feature reading to start on the first feature."
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:6
msgid "This affects GetNextFeature()."
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:8
msgid "This function is the same as the C++ method OGRLayer::ResetReading()."
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:13
msgid "hLayer:  handle to the layer on which features are read."
msgstr ""

#: of osgeo.ogr.Layer.RollbackTransaction:1
msgid "OGRErr OGR_L_RollbackTransaction(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.RollbackTransaction:4
msgid ""
"For datasources which support transactions, RollbackTransaction will roll"
" back a datasource to its state before the start of the current "
"transaction."
msgstr ""

#: of osgeo.ogr.Layer.RollbackTransaction:8
msgid ""
"If no transaction is active, or the rollback fails, will return "
"OGRERR_FAILURE. Datasources which do not support transactions will always"
" return OGRERR_NONE."
msgstr ""

#: of osgeo.ogr.Layer.RollbackTransaction:12
msgid ""
"This function is the same as the C++ method "
"OGRLayer::RollbackTransaction()."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:1
msgid "OGRErr OGR_L_SetAttributeFilter(OGRLayerH hLayer, const char *pszQuery)"
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:4
msgid "Set a new attribute query."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:6
msgid ""
"This function sets the attribute query string to be used when fetching "
"features via the OGR_L_GetNextFeature() function. Only features for which"
" the query evaluates as true will be returned."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:10
msgid ""
"The query string should be in the format of an SQL WHERE clause. For "
"instance \"population > 1000000 and population < 5000000\" where "
"population is an attribute in the layer. The query format is a restricted"
" form of SQL WHERE clause as defined \"eq_format=restricted_where\" about"
" half way through this document:"
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:16
msgid "http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html"
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:18
msgid ""
"Note that installing a query string will generally result in resetting "
"the current reading position (ala OGR_L_ResetReading())."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:21
msgid ""
"This function is the same as the C++ method "
"OGRLayer::SetAttributeFilter()."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:27
msgid "hLayer:  handle to the layer on which attribute query will be executed."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:30
msgid ""
"pszQuery:  query in restricted SQL WHERE format, or NULL to clear the "
"current query."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:33
msgid ""
"OGRERR_NONE if successfully installed, or an error code if the query "
"expression is in error, or some other failure occurs."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:1
msgid "OGRErr OGR_L_SetFeature(OGRLayerH hLayer, OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:4
msgid "Rewrite an existing feature."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:6
msgid ""
"This function will write a feature to the layer, based on the feature id "
"within the OGRFeature."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:9
msgid ""
"Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer "
"supports random access writing via OGR_L_SetFeature()."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:12
msgid "This function is the same as the C++ method OGRLayer::SetFeature()."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:17
msgid "hLayer:  handle to the layer to write the feature."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:19
msgid "hFeat:  the feature to write."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:1
msgid "OGRErr OGR_L_SetIgnoredFields(OGRLayerH hLayer, const char **papszFields)"
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:4
msgid "Set which fields can be omitted when retrieving features from the layer."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:7
msgid ""
"If the driver supports this functionality (testable using OLCIgnoreFields"
" capability), it will not fetch the specified fields in subsequent calls "
"to GetFeature() / GetNextFeature() and thus save some processing time "
"and/or bandwidth."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:12
msgid ""
"Besides field names of the layers, the following special fields can be "
"passed: \"OGR_GEOMETRY\" to ignore geometry and \"OGR_STYLE\" to ignore "
"layer style."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:16
msgid "By default, no fields are ignored."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:18
msgid "This method is the same as the C++ method OGRLayer::SetIgnoredFields()"
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:23
msgid ""
"papszFields:  an array of field names terminated by NULL item. If NULL is"
" passed, the ignored list is cleared."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:26
msgid ""
"OGRERR_NONE if all field names have been resolved (even if the driver "
"does not support this method)"
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:1
msgid "OGRErr OGR_L_SetNextByIndex(OGRLayerH hLayer, GIntBig nIndex)"
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:4
msgid "Move read cursor to the nIndex'th feature in the current resultset."
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:6
msgid ""
"This method allows positioning of a layer such that the GetNextFeature() "
"call will read the requested feature, where nIndex is an absolute index "
"into the current result set. So, setting it to 3 would mean the next "
"feature read with GetNextFeature() would have been the 4th feature to "
"have been read if sequential reading took place from the beginning of the"
" layer, including accounting for spatial and attribute filters."
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:14
msgid ""
"Only in rare circumstances is SetNextByIndex() efficiently implemented. "
"In all other cases the default implementation which calls ResetReading() "
"and then calls GetNextFeature() nIndex times is used. To determine if "
"fast seeking is available on the current layer use the TestCapability() "
"method with a value of OLCFastSetNextByIndex."
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:20
msgid "This method is the same as the C++ method OGRLayer::SetNextByIndex()"
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:27
msgid "nIndex:  the index indicating how many steps into the result set to seek."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:28 osgeo.ogr.Layer.SetNextByIndex:30
msgid "OGRERR_NONE on success or an error code."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:1
msgid "void OGR_L_SetSpatialFilter(OGRLayerH hLayer, OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:4
msgid "Set a new spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:6
msgid ""
"This function set the geometry to be used as a spatial filter when "
"fetching features via the OGR_L_GetNextFeature() function. Only features "
"that geometrically intersect the filter geometry will be returned."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:11
msgid ""
"Currently this test is may be inaccurately implemented, but it is "
"guaranteed that all features whose envelope (as returned by "
"OGR_G_GetEnvelope()) overlaps the envelope of the spatial filter will be "
"returned. This can result in more shapes being returned that should "
"strictly be the case."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:17
msgid ""
"Starting with GDAL 2.3, features with null or empty geometries will never"
" be considered as matching a spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:20
msgid ""
"This function makes an internal copy of the passed geometry. The passed "
"geometry remains the responsibility of the caller, and may be safely "
"destroyed."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:24
msgid ""
"For the time being the passed filter geometry should be in the same SRS "
"as the layer (as returned by OGR_L_GetSpatialRef()). In the future this "
"may be generalized."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:28
msgid "This function is the same as the C++ method OGRLayer::SetSpatialFilter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:34
#: osgeo.ogr.Layer.SetSpatialFilterRect:26
msgid "hLayer:  handle to the layer on which to set the spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:36
msgid ""
"hGeom:  handle to the geometry to use as a filtering region. NULL may be "
"passed indicating that the current spatial filter should be cleared, but "
"no new one instituted."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:1
msgid ""
"void OGR_L_SetSpatialFilterRect(OGRLayerH hLayer, double dfMinX, double "
"dfMinY, double dfMaxX, double dfMaxY)"
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:5
msgid "Set a new rectangular spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:7
msgid ""
"This method set rectangle to be used as a spatial filter when fetching "
"features via the OGR_L_GetNextFeature() method. Only features that "
"geometrically intersect the given rectangle will be returned."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:11
msgid ""
"The x/y values should be in the same coordinate system as the layer as a "
"whole (as returned by OGRLayer::GetSpatialRef()). Internally this method "
"is normally implemented as creating a 5 vertex closed rectangular polygon"
" and passing it to OGRLayer::SetSpatialFilter(). It exists as a "
"convenience."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:17
msgid ""
"The only way to clear a spatial filter set with this method is to call "
"OGRLayer::SetSpatialFilter(NULL)."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:20
msgid ""
"This method is the same as the C++ method "
"OGRLayer::SetSpatialFilterRect()."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:28
msgid "dfMinX:  the minimum X coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:30
msgid "dfMinY:  the minimum Y coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:32
msgid "dfMaxX:  the maximum X coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:34
msgid "dfMaxY:  the maximum Y coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetStyleTable:1
msgid "void OGR_L_SetStyleTable(OGRLayerH hLayer, OGRStyleTableH hStyleTable)"
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:1
msgid "OGRErr OGR_L_StartTransaction(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:4
msgid ""
"For datasources which support transactions, StartTransaction creates a "
"transaction."
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:7
msgid ""
"If starting the transaction fails, will return OGRERR_FAILURE. "
"Datasources which do not support transactions will always return "
"OGRERR_NONE."
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:11
msgid ""
"Note: as of GDAL 2.0, use of this API is discouraged when the dataset "
"offers dataset level transaction with GDALDataset::StartTransaction(). "
"The reason is that most drivers can only offer transactions at dataset "
"level, and not layer level. Very few drivers really support transactions "
"at layer scope."
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:17
msgid "This function is the same as the C++ method OGRLayer::StartTransaction()."
msgstr ""

#: of osgeo.ogr.Layer.SymDifference:1
msgid ""
"OGRErr OGR_L_SymDifference(OGRLayerH pLayerInput, OGRLayerH pLayerMethod,"
" OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.SymDifference:6
msgid "Symmetrical difference of two layers."
msgstr ""

#: of osgeo.ogr.Layer.SymDifference:8
msgid ""
"The result layer contains features whose geometries represent areas that "
"are in either in the input layer or in the method layer but not in both. "
"The features in the result layer have attributes from both input and "
"method layers. For features which represent areas that are only in the "
"input or in the method layer the respective attributes have undefined "
"values. The schema of the result layer can be set by the user or, if it "
"is empty, is initialized to contain all fields in the input and method "
"layers."
msgstr ""

#: of osgeo.ogr.Layer.SymDifference:39
msgid "This function is the same as the C++ method OGRLayer::SymDifference()."
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:1
msgid "OGRErr OGR_L_SyncToDisk(OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:6
msgid ""
"This call is intended to force the layer to flush any pending writes to "
"disk, and leave the disk file in a consistent state. It would not "
"normally have any effect on read-only datasources."
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:10
msgid ""
"Some layers do not implement this method, and will still return "
"OGRERR_NONE. The default implementation just returns OGRERR_NONE. An "
"error is only returned if an error occurs while attempting to flush to "
"disk."
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:15
msgid ""
"In any event, you should always close any opened datasource with "
"OGR_DS_Destroy() that will ensure all data is correctly flushed."
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:18
msgid "This method is the same as the C++ method OGRLayer::SyncToDisk()"
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:25
msgid "OGRERR_NONE if no error occurs (even if nothing is done) or an error code."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:1
msgid "int OGR_L_TestCapability(OGRLayerH hLayer, const char *pszCap)"
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:4
msgid "Test if this layer supported the named capability."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:6
msgid ""
"The capability codes that can be tested are represented as strings, but "
"#defined constants exists to ensure correct spelling. Specific layer "
"types may implement class specific capabilities, but this can't generally"
" be discovered by the caller."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:11
msgid ""
"OLCRandomRead / \"RandomRead\": TRUE if the GetFeature() method is "
"implemented in an optimized way for this layer, as opposed to the default"
" implementation using ResetReading() and GetNextFeature() to find the "
"requested feature id."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:16
msgid ""
"OLCSequentialWrite / \"SequentialWrite\": TRUE if the CreateFeature() "
"method works for this layer. Note this means that this particular layer "
"is writable. The same OGRLayer class may returned FALSE for other layer "
"instances that are effectively read-only."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:21
msgid ""
"OLCRandomWrite / \"RandomWrite\": TRUE if the SetFeature() method is "
"operational on this layer. Note this means that this particular layer is "
"writable. The same OGRLayer class may returned FALSE for other layer "
"instances that are effectively read-only."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:26
msgid ""
"OLCFastSpatialFilter / \"FastSpatialFilter\": TRUE if this layer "
"implements spatial filtering efficiently. Layers that effectively read "
"all features, and test them with the OGRFeature intersection methods "
"should return FALSE. This can be used as a clue by the application "
"whether it should build and maintain its own spatial index for features "
"in this layer."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:33
msgid ""
"OLCFastFeatureCount / \"FastFeatureCount\": TRUE if this layer can return"
" a feature count (via OGR_L_GetFeatureCount()) efficiently, i.e. without "
"counting the features. In some cases this will return TRUE until a "
"spatial filter is installed after which it will return FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:38
msgid ""
"OLCFastGetExtent / \"FastGetExtent\": TRUE if this layer can return its "
"data extent (via OGR_L_GetExtent()) efficiently, i.e. without scanning "
"all the features. In some cases this will return TRUE until a spatial "
"filter is installed after which it will return FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:43
msgid ""
"OLCFastSetNextByIndex / \"FastSetNextByIndex\": TRUE if this layer can "
"perform the SetNextByIndex() call efficiently, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:46
msgid ""
"OLCCreateField / \"CreateField\": TRUE if this layer can create new "
"fields on the current layer using CreateField(), otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:49
msgid ""
"OLCCreateGeomField / \"CreateGeomField\": (GDAL >= 1.11) TRUE if this "
"layer can create new geometry fields on the current layer using "
"CreateGeomField(), otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:53
msgid ""
"OLCDeleteField / \"DeleteField\": TRUE if this layer can delete existing "
"fields on the current layer using DeleteField(), otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:57
msgid ""
"OLCReorderFields / \"ReorderFields\": TRUE if this layer can reorder "
"existing fields on the current layer using ReorderField() or "
"ReorderFields(), otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:61
msgid ""
"OLCAlterFieldDefn / \"AlterFieldDefn\": TRUE if this layer can alter the "
"definition of an existing field on the current layer using "
"AlterFieldDefn(), otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:65
msgid ""
"OLCDeleteFeature / \"DeleteFeature\": TRUE if the DeleteFeature() method "
"is supported on this layer, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:68
msgid ""
"OLCStringsAsUTF8 / \"StringsAsUTF8\": TRUE if values of OFTString fields "
"are assured to be in UTF-8 format. If FALSE the encoding of fields is "
"uncertain, though it might still be UTF-8."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:72
msgid ""
"OLCTransactions / \"Transactions\": TRUE if the StartTransaction(), "
"CommitTransaction() and RollbackTransaction() methods work in a "
"meaningful way, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:76
msgid ""
"OLCCurveGeometries / \"CurveGeometries\": TRUE if this layer supports "
"writing curve geometries or may return such geometries. (GDAL 2.0)."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:79
msgid "This function is the same as the C++ method OGRLayer::TestCapability()."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:85
msgid "hLayer:  handle to the layer to get the capability from."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:87
msgid "pszCap:  the name of the capability to test."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:89
msgid ""
"TRUE if the layer has the requested capability, or FALSE otherwise. "
"OGRLayers will return FALSE for any unrecognized capabilities."
msgstr ""

#: of osgeo.ogr.Layer.Union:1
msgid ""
"OGRErr OGR_L_Union(OGRLayerH pLayerInput, OGRLayerH pLayerMethod, "
"OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.Union:5
msgid "Union of two layers."
msgstr ""

#: of osgeo.ogr.Layer.Union:7
msgid ""
"The result layer contains features whose geometries represent areas that "
"are in either in the input layer, in the method layer, or in both. The "
"features in the result layer have attributes from both input and method "
"layers. For features which represent areas that are only in the input or "
"in the method layer the respective attributes have undefined values. The "
"schema of the result layer can be set by the user or, if it is empty, is "
"initialized to contain all fields in the input and method layers."
msgstr ""

#: of osgeo.ogr.Layer.Union:47
msgid "This function is the same as the C++ method OGRLayer::Union()."
msgstr ""

#: of osgeo.ogr.Layer.Update:1
msgid ""
"OGRErr OGR_L_Update(OGRLayerH pLayerInput, OGRLayerH pLayerMethod, "
"OGRLayerH pLayerResult, char **papszOptions, GDALProgressFunc "
"pfnProgress, void *pProgressArg)"
msgstr ""

#: of osgeo.ogr.Layer.Update:5
msgid "Update this layer with features from the update layer."
msgstr ""

#: of osgeo.ogr.Layer.Update:7
msgid ""
"The result layer contains features whose geometries represent areas that "
"are either in the input layer or in the method layer. The features in the"
" result layer have areas of the features of the method layer or those "
"ares of the features of the input layer that are not covered by the "
"method layer. The features of the result layer get their attributes from "
"the input layer. The schema of the result layer can be set by the user "
"or, if it is empty, is initialized to contain all fields in the input "
"layer."
msgstr ""

#: of osgeo.ogr.Layer.Update:16
msgid ""
"If the schema of the result is set by user and contains fields that have "
"the same name as a field in the method layer, then the attribute in the "
"result feature the originates from the method layer will get the value "
"from the feature of the method layer."
msgstr ""

#: of osgeo.ogr.Layer.Update:38
msgid "This function is the same as the C++ method OGRLayer::Update()."
msgstr ""

#: ../../source/api/python/vector_api.rst:27
msgid "Feature"
msgstr ""

#: of osgeo.ogr.Feature:1
msgid "Proxy of C++ OGRFeatureShadow class."
msgstr ""

#: of osgeo.ogr.Feature.Clone:1
msgid "OGRFeatureH OGR_F_Clone(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.Clone:4
msgid "Duplicate feature."
msgstr ""

#: of osgeo.ogr.Feature.Clone:6
msgid ""
"The newly created feature is owned by the caller, and will have its own "
"reference to the OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.Feature.Clone:9
msgid "This function is the same as the C++ method OGRFeature::Clone()."
msgstr ""

#: of osgeo.ogr.Feature.Clone:14
msgid "hFeat:  handle to the feature to clone."
msgstr ""

#: of osgeo.ogr.Feature.Clone:16
msgid "a handle to the new feature, exactly matching this feature."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:1
msgid "void OGR_F_DumpReadable(OGRFeatureH hFeat, FILE *fpOut)"
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:4
msgid "Dump this feature in a human readable form."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:6
msgid ""
"This dumps the attributes, and geometry; however, it doesn't definition "
"information (other than field types and names), nor does it report the "
"geometry spatial reference system."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:10
msgid "This function is the same as the C++ method OGRFeature::DumpReadable()."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:16
msgid "hFeat:  handle to the feature to dump."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:18
msgid "fpOut:  the stream to write to, such as strout."
msgstr ""

#: of osgeo.ogr.Feature.Equal:1
msgid "int OGR_F_Equal(OGRFeatureH hFeat, OGRFeatureH hOtherFeat)"
msgstr ""

#: of osgeo.ogr.Feature.Equal:4
msgid "Test if two features are the same."
msgstr ""

#: of osgeo.ogr.Feature.Equal:6
msgid ""
"Two features are considered equal if the share them (handle equality) "
"same OGRFeatureDefn, have the same field values, and the same geometry "
"(as tested by OGR_G_Equal()) as well as the same feature id."
msgstr ""

#: of osgeo.ogr.Feature.Equal:10
msgid "This function is the same as the C++ method OGRFeature::Equal()."
msgstr ""

#: of osgeo.ogr.Feature.Equal:15
msgid "hFeat:  handle to one of the feature."
msgstr ""

#: of osgeo.ogr.Feature.Equal:17
msgid "hOtherFeat:  handle to the other feature to test this one against."
msgstr ""

#: of osgeo.ogr.Feature.Equal:19
msgid "TRUE if they are equal, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Feature.ExportToJson:1
msgid ""
"Exports a GeoJSON object which represents the Feature. The as_object "
"parameter determines whether the returned value should be a Python object"
" instead of a string. Defaults to False. The options parameter is passed "
"to Geometry.ExportToJson()"
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:1
msgid ""
"void OGR_F_FillUnsetWithDefault(OGRFeatureH hFeat, int bNotNullableOnly, "
"char **papszOptions)"
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:5
msgid "Fill unset fields with default values that might be defined."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:7
msgid ""
"This function is the same as the C++ method "
"OGRFeature::FillUnsetWithDefault()."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:13
#: osgeo.ogr.Feature.GetNativeData:27 osgeo.ogr.Feature.GetNativeMediaType:17
#: osgeo.ogr.Feature.SetNativeData:17 osgeo.ogr.Feature.SetNativeMediaType:18
msgid "hFeat:  handle to the feature."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:15
msgid ""
"bNotNullableOnly:  if we should fill only unset fields with a not-null "
"constraint."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:18
msgid "papszOptions:  unused currently. Must be set to NULL."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:20
#: osgeo.ogr.Feature.GetFieldAsInteger64:23
#: osgeo.ogr.Feature.GetFieldAsInteger64List:25
#: osgeo.ogr.Feature.SetFieldInteger64:28
#: osgeo.ogr.Feature.SetFieldInteger64List:29 osgeo.ogr.Feature.Validate:29
#: osgeo.ogr.FieldDefn.GetDefault:16 osgeo.ogr.FieldDefn.GetSubType:16
#: osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:21
#: osgeo.ogr.FieldDefn.IsNullable:22 osgeo.ogr.FieldDefn.SetDefault:34
#: osgeo.ogr.FieldDefn.SetNullable:21 osgeo.ogr.FieldDefn.SetSubType:19
#: osgeo.ogr.Geometry.ExportToIsoWkb:30 osgeo.ogr.Geometry.ExportToIsoWkt:25
msgid "GDAL 2.0"
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:1
msgid "OGRFeatureDefnH OGR_F_GetDefnRef(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:4
msgid "Fetch feature definition."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:6
msgid "This function is the same as the C++ method OGRFeature::GetDefnRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:11
msgid "hFeat:  handle to the feature to get the feature definition from."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:13
msgid "a handle to the feature definition object on which feature depends."
msgstr ""

#: of osgeo.ogr.Feature.GetFID:1
msgid "GIntBig OGR_F_GetFID(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetFID:4
msgid "Get feature identifier."
msgstr ""

#: of osgeo.ogr.Feature.GetFID:6
msgid ""
"This function is the same as the C++ method OGRFeature::GetFID(). Note: "
"since GDAL 2.0, this method returns a GIntBig (previously a long)"
msgstr ""

#: of osgeo.ogr.Feature.GetFID:13
msgid "hFeat:  handle to the feature from which to get the feature identifier."
msgstr ""

#: of osgeo.ogr.Feature.GetFID:16
msgid "feature id or OGRNullFID if none has been assigned."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:1
msgid "GByte* OGR_F_GetFieldAsBinary(OGRFeatureH hFeat, int iField, int *pnBytes)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:4
msgid "Fetch field value as binary."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:6
msgid "This method only works for OFTBinary and OFTString fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:8
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsBinary()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:14
#: osgeo.ogr.Feature.GetFieldAsDateTime:17
#: osgeo.ogr.Feature.GetFieldAsDouble:16
#: osgeo.ogr.Feature.GetFieldAsDoubleList:15
#: osgeo.ogr.Feature.GetFieldAsInteger:16
#: osgeo.ogr.Feature.GetFieldAsInteger64:17
#: osgeo.ogr.Feature.GetFieldAsInteger64List:15
#: osgeo.ogr.Feature.GetFieldAsIntegerList:15
#: osgeo.ogr.Feature.GetFieldAsString:16
#: osgeo.ogr.Feature.GetFieldAsStringList:17
#: osgeo.ogr.Feature.SetFieldDoubleList:21
#: osgeo.ogr.Feature.SetFieldInteger64:22
#: osgeo.ogr.Feature.SetFieldInteger64List:21
#: osgeo.ogr.Feature.SetFieldIntegerList:21 osgeo.ogr.Feature.SetFieldString:24
#: osgeo.ogr.Feature.SetFieldStringList:20
msgid "hFeat:  handle to the feature that owned the field."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:16
#: osgeo.ogr.Feature.GetFieldAsDateTime:19
#: osgeo.ogr.Feature.GetFieldAsDouble:18
#: osgeo.ogr.Feature.GetFieldAsDoubleList:17
#: osgeo.ogr.Feature.GetFieldAsInteger:18
#: osgeo.ogr.Feature.GetFieldAsInteger64:19
#: osgeo.ogr.Feature.GetFieldAsInteger64List:17
#: osgeo.ogr.Feature.GetFieldAsIntegerList:17
#: osgeo.ogr.Feature.GetFieldAsString:18
#: osgeo.ogr.Feature.GetFieldAsStringList:19
#: osgeo.ogr.Feature.SetFieldInteger64:24 osgeo.ogr.Feature.SetFieldString:26
msgid "iField:  the field to fetch, from 0 to GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:18
msgid "pnBytes:  location to place count of bytes returned."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:20
#: osgeo.ogr.Feature.GetFieldAsStringList:21
msgid ""
"the field value. This list is internal, and should not be modified, or "
"freed. Its lifetime may be very brief."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:1
msgid ""
"int OGR_F_GetFieldAsDateTime(OGRFeatureH hFeat, int iField, int *pnYear, "
"int *pnMonth, int *pnDay, int *pnHour, int *pnMinute, int *pnSecond, int "
"*pnTZFlag)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:6
msgid "Fetch field value as date and time."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:8
msgid ""
"Currently this method only works for OFTDate, OFTTime and OFTDateTime "
"fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:11
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsDateTime()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:21
msgid "pnYear:  (including century)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:23
msgid "pnMonth:  (1-12)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:25
msgid "pnDay:  (1-31)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:27
msgid "pnHour:  (0-23)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:29
msgid "pnMinute:  (0-59)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:31
msgid "pnSecond:  (0-59)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:33
msgid "pnTZFlag:  (0=unknown, 1=localtime, 100=GMT, see data model for details)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:36
msgid "TRUE on success or FALSE on failure."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:38
msgid ""
"See:  Use OGR_F_GetFieldAsDateTimeEx() for second with millisecond "
"accuracy."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:1
msgid "double OGR_F_GetFieldAsDouble(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:4
msgid "Fetch field value as a double."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:6
msgid ""
"OFTString features will be translated using CPLAtof(). OFTInteger fields "
"will be cast to double. Other field types, or errors will result in a "
"return value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:10
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsDouble()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:20
#: osgeo.ogr.Feature.GetFieldAsInteger:20
#: osgeo.ogr.Feature.GetFieldAsInteger64:21
msgid "the field value."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:1
msgid ""
"const double* OGR_F_GetFieldAsDoubleList(OGRFeatureH hFeat, int iField, "
"int *pnCount)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:5
msgid "Fetch field value as a list of doubles."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:7
msgid "Currently this function only works for OFTRealList fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsDoubleList()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:19
msgid "pnCount:  an integer to put the list count (number of doubles) into."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:21
#: osgeo.ogr.Feature.GetFieldAsInteger64List:21
#: osgeo.ogr.Feature.GetFieldAsIntegerList:21
msgid ""
"the field value. This list is internal, and should not be modified, or "
"freed. Its lifetime may be very brief. If *pnCount is zero on return the "
"returned pointer may be NULL or non-NULL."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:1
msgid "int OGR_F_GetFieldAsInteger(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:4
msgid "Fetch field value as integer."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:6
msgid ""
"OFTString features will be translated using atoi(). OFTReal fields will "
"be cast to integer. Other field types, or errors will result in a return "
"value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:10
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsInteger()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:1
msgid "GIntBig OGR_F_GetFieldAsInteger64(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:4
msgid "Fetch field value as integer 64 bit."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:6
msgid ""
"OFTInteger are promoted to 64 bit. OFTString features will be translated "
"using CPLAtoGIntBig(). OFTReal fields will be cast to integer. Other "
"field types, or errors will result in a return value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:11
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsInteger64()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:1
msgid ""
"const GIntBig* OGR_F_GetFieldAsInteger64List(OGRFeatureH hFeat, int "
"iField, int *pnCount)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:5
msgid "Fetch field value as a list of 64 bit integers."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:7
msgid "Currently this function only works for OFTInteger64List fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsInteger64List()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:19
#: osgeo.ogr.Feature.GetFieldAsIntegerList:19
msgid "pnCount:  an integer to put the list count (number of integers) into."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:1
msgid ""
"const int* OGR_F_GetFieldAsIntegerList(OGRFeatureH hFeat, int iField, int"
" *pnCount)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:5
msgid "Fetch field value as a list of integers."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:7
msgid "Currently this function only works for OFTIntegerList fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsIntegerList()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:1
msgid "const char* OGR_F_GetFieldAsString(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:4
msgid "Fetch field value as a string."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:6
msgid ""
"OFTReal and OFTInteger fields will be translated to string using "
"sprintf(), but not necessarily using the established formatting rules. "
"Other field types, or errors will result in a return value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:10
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsString()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:20
msgid ""
"the field value. This string is internal, and should not be modified, or "
"freed. Its lifetime may be very brief."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:1
msgid "char** OGR_F_GetFieldAsStringList(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:4
msgid "Fetch field value as a list of strings."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:6
msgid "Currently this method only works for OFTStringList fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:8
msgid ""
"The returned list is terminated by a NULL pointer. The number of elements"
" can also be calculated using CSLCount()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:11
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsStringList()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:1
msgid "int OGR_F_GetFieldCount(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:4
msgid ""
"Fetch number of fields on this feature This will always be the same as "
"the field count for the OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:7
msgid "This function is the same as the C++ method OGRFeature::GetFieldCount()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:13
msgid "hFeat:  handle to the feature to get the fields count from."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:15 osgeo.ogr.FeatureDefn.GetFieldCount:13
msgid "count of fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:1
msgid "OGRFieldDefnH OGR_F_GetFieldDefnRef(OGRFeatureH hFeat, int i)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:4
msgid "Fetch definition for this field."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:6
msgid "This function is the same as the C++ method OGRFeature::GetFieldDefnRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:12 osgeo.ogr.Feature.GetFieldIndex:14
#: osgeo.ogr.Feature.GetGeomFieldDefnRef:12
msgid "hFeat:  handle to the feature on which the field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:14
msgid "i:  the field to fetch, from 0 to GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:16
#: osgeo.ogr.Feature.GetGeomFieldDefnRef:16
msgid ""
"a handle to the field definition (from the OGRFeatureDefn). This is an "
"internal reference, and should not be deleted or modified."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:1
msgid "int OGR_F_GetFieldIndex(OGRFeatureH hFeat, const char *pszName)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:4
msgid "Fetch the field index given field name."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:6
msgid "This is a cover for the OGRFeatureDefn::GetFieldIndex() method."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:8
msgid "This function is the same as the C++ method OGRFeature::GetFieldIndex()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:16
msgid "pszName:  the name of the field to search for."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:18
msgid "the field index, or -1 if no matching field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:1
msgid "int OGR_F_GetGeomFieldCount(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:4
msgid ""
"Fetch number of geometry fields on this feature This will always be the "
"same as the geometry field count for the OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:7
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetGeomFieldCount()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:13
msgid "hFeat:  handle to the feature to get the geometry fields count from."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:15
#: osgeo.ogr.FeatureDefn.GetGeomFieldCount:14
msgid "count of geometry fields."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:17
#: osgeo.ogr.Feature.GetGeomFieldDefnRef:19
#: osgeo.ogr.Feature.GetGeomFieldIndex:21 osgeo.ogr.Feature.GetGeomFieldRef:19
#: osgeo.ogr.Feature.SetGeomFieldDirectly:27
#: osgeo.ogr.FeatureDefn.AddGeomFieldDefn:26
#: osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:25
#: osgeo.ogr.FeatureDefn.GetGeomFieldCount:16
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn:21
msgid "GDAL 1.11"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:1
msgid "OGRGeomFieldDefnH OGR_F_GetGeomFieldDefnRef(OGRFeatureH hFeat, int i)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:4
msgid "Fetch definition for this geometry field."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:6
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetGeomFieldDefnRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:14
msgid "i:  the field to fetch, from 0 to GetGeomFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:1
msgid "int OGR_F_GetGeomFieldIndex(OGRFeatureH hFeat, const char *pszName)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:4
msgid "Fetch the geometry field index given geometry field name."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:6
msgid "This is a cover for the OGRFeatureDefn::GetGeomFieldIndex() method."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:8
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetGeomFieldIndex()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:14
msgid "hFeat:  handle to the feature on which the geometry field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:16
msgid "pszName:  the name of the geometry field to search for."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:18
msgid "the geometry field index, or -1 if no matching geometry field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:1
msgid "OGRGeometryH OGR_F_GetGeomFieldRef(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:4 osgeo.ogr.Feature.GetGeometryRef:4
msgid "Fetch a handle to feature geometry."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:6
msgid "This function is the same as the C++ method OGRFeature::GetGeomFieldRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:12 osgeo.ogr.Feature.GetGeometryRef:13
msgid "hFeat:  handle to the feature to get geometry from."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:14
msgid "iField:  geometry field to get."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:16 osgeo.ogr.Feature.GetGeometryRef:15
msgid "a handle to internal feature geometry. This object should not be modified."
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:1
msgid "OGRGeometryH OGR_F_GetGeometryRef(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:6
msgid ""
"This function is essentially the same as the C++ method "
"OGRFeature::GetGeometryRef() (the only difference is that this C function"
" honours OGRGetNonLinearGeometriesEnabledFlag())"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:1
msgid "const char* OGR_F_GetNativeData(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:4
msgid "Returns the native data for the feature."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:6 osgeo.ogr.Feature.SetNativeData:6
msgid ""
"The native data is the representation in a \"natural\" form that comes "
"from the driver that created this feature, or that is aimed at an output "
"driver. The native data may be in different format, which is indicated by"
" OGR_F_GetNativeMediaType()."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:11
msgid ""
"Note that most drivers do not support storing the native data in the "
"feature object, and if they do, generally the NATIVE_DATA open option "
"must be passed at dataset opening."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:15
msgid ""
"The \"native data\" does not imply it is something more performant or "
"powerful than what can be obtained with the rest of the API, but it may "
"be useful in round-tripping scenarios where some characteristics of the "
"underlying format are not captured otherwise by the OGR abstraction."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:21
msgid "This function is the same as the C++ method OGRFeature::GetNativeData()."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:29
msgid "a string with the native data, or NULL if there is none."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:31
#: osgeo.ogr.Feature.GetNativeMediaType:21 osgeo.ogr.Feature.SetNativeData:22
#: osgeo.ogr.Feature.SetNativeMediaType:23
#: osgeo.ogr.Geometry.CoordinateDimension:17 osgeo.ogr.Geometry.Is3D:14
#: osgeo.ogr.Geometry.IsMeasured:15 osgeo.ogr.Geometry.Set3D:18
#: osgeo.ogr.Geometry.SetMeasured:19
msgid "GDAL 2.1"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:33
#: osgeo.ogr.Feature.GetNativeMediaType:23 osgeo.ogr.Feature.SetNativeData:24
#: osgeo.ogr.Feature.SetNativeMediaType:25
msgid "See: https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:1
msgid "const char* OGR_F_GetNativeMediaType(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:4
msgid "Returns the native media type for the feature."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:6
#: osgeo.ogr.Feature.SetNativeMediaType:7
msgid ""
"The native media type is the identifier for the format of the native "
"data. It follows the IANA RFC 2045 "
"(seehttps://en.wikipedia.org/wiki/Media_type), e.g. "
"\"application/vnd.geo+json\" for JSon."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:11
msgid "This function is the same as the C function OGR_F_GetNativeMediaType()."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:19
msgid "a string with the native media type, or NULL if there is none."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:1
msgid "const char* OGR_F_GetStyleString(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:4
msgid "Fetch style string for this feature."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:6
msgid ""
"Set the OGR Feature Style Specification for details on the format of this"
" string, and ogr_featurestyle.h for services available to parse it."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:10
msgid "This function is the same as the C++ method OGRFeature::GetStyleString()."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:16
msgid "hFeat:  handle to the feature to get the style from."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:18
msgid ""
"a reference to a representation in string format, or NULL if there isn't "
"one."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:1
msgid "int OGR_F_IsFieldNull(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:4
msgid "Test if a field is null."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:6
msgid "This function is the same as the C++ method OGRFeature::IsFieldNull()."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:11 osgeo.ogr.Feature.IsFieldSet:11
#: osgeo.ogr.Feature.IsFieldSetAndNotNull:12 osgeo.ogr.Feature.SetFieldNull:12
#: osgeo.ogr.Feature.UnsetField:11
msgid "hFeat:  handle to the feature on which the field is."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:13 osgeo.ogr.Feature.IsFieldSet:13
#: osgeo.ogr.Feature.IsFieldSetAndNotNull:14
msgid "iField:  the field to test."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:15
msgid "TRUE if the field is null, otherwise false."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:17
#: osgeo.ogr.Feature.IsFieldSetAndNotNull:18 osgeo.ogr.Feature.SetFieldNull:16
#: osgeo.ogr.Geometry.Distance3D:24
msgid "GDAL 2.2"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:1
msgid "int OGR_F_IsFieldSet(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:4
msgid "Test if a field has ever been assigned a value or not."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:6
msgid "This function is the same as the C++ method OGRFeature::IsFieldSet()."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:15
msgid "TRUE if the field has been set, otherwise false."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:1
msgid "int OGR_F_IsFieldSetAndNotNull(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:4
msgid "Test if a field is set and not null."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:6
msgid ""
"This function is the same as the C++ method "
"OGRFeature::IsFieldSetAndNotNull()."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:16
msgid "TRUE if the field is set and not null, otherwise false."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:1
msgid "OGRErr OGR_F_SetFID(OGRFeatureH hFeat, GIntBig nFID)"
msgstr ""

#: of osgeo.ogr.Feature.SetFID:4
msgid "Set the feature identifier."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:6
msgid ""
"For specific types of features this operation may fail on illegal "
"features ids. Generally it always succeeds. Feature ids should be greater"
" than or equal to zero, with the exception of OGRNullFID (-1) indicating "
"that the feature id is unknown."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:11
msgid "This function is the same as the C++ method OGRFeature::SetFID()."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:16
msgid "hFeat:  handle to the feature to set the feature id to."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:18
msgid "nFID:  the new feature identifier value to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:20
msgid "On success OGRERR_NONE, or on failure some other value."
msgstr ""

#: of osgeo.ogr.Feature.SetField:1
msgid "SetField(self, int id, int year, int month, int day, int hour, int minute,"
msgstr ""

#: of osgeo.ogr.Feature.SetField:2
msgid "int second, int tzflag)"
msgstr ""

#: of osgeo.ogr.Feature.SetField:3
msgid "SetField(self, char name, int year, int month, int day, int hour,"
msgstr ""

#: of osgeo.ogr.Feature.SetField:4
msgid "int minute, int second, int tzflag)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:1
msgid ""
"void OGR_F_SetFieldDoubleList(OGRFeatureH hFeat, int iField, int nCount, "
"const double *padfValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:5
msgid "Set field to list of doubles value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:7
msgid ""
"This function currently on has an effect of OFTIntegerList, "
"OFTInteger64List, OFTRealList fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:10
#: osgeo.ogr.Feature.SetFieldInteger64:11
#: osgeo.ogr.Feature.SetFieldInteger64List:10
#: osgeo.ogr.Feature.SetFieldIntegerList:10 osgeo.ogr.Feature.SetFieldString:13
#: osgeo.ogr.Feature.SetFieldStringList:9
msgid "This function is the same as the C++ method OGRFeature::SetField()."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:12
#: osgeo.ogr.Feature.SetFieldInteger64:13
#: osgeo.ogr.Feature.SetFieldInteger64List:12
#: osgeo.ogr.Feature.SetFieldIntegerList:12 osgeo.ogr.Feature.SetFieldString:15
#: osgeo.ogr.Feature.SetFieldStringList:11 osgeo.ogr.Feature.SetGeometry:12
#: osgeo.ogr.Feature.SetGeometryDirectly:13
msgid ""
"This method has only an effect on the in-memory feature object. If this "
"object comes from a layer and the modifications must be serialized back "
"to the datasource, OGR_L_SetFeature() must be used afterwards. Or if this"
" is a new feature, OGR_L_CreateFeature() must be used afterwards."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:23
#: osgeo.ogr.Feature.SetFieldInteger64List:23
#: osgeo.ogr.Feature.SetFieldIntegerList:23
#: osgeo.ogr.Feature.SetFieldStringList:22
msgid "iField:  the field to set, from 0 to GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:25
#: osgeo.ogr.Feature.SetFieldInteger64List:25
#: osgeo.ogr.Feature.SetFieldIntegerList:25
msgid "nCount:  the number of values in the list being assigned."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:27
msgid "padfValues:  the values to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:1
msgid ""
"void OGR_F_SetFieldInteger64(OGRFeatureH hFeat, int iField, GIntBig "
"nValue)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:4
msgid "Set field to 64 bit integer value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:6
msgid ""
"OFTInteger, OFTInteger64 and OFTReal fields will be set directly. "
"OFTString fields will be assigned a string representation of the value, "
"but not necessarily taking into account formatting constraints on this "
"field. Other field types may be unaffected."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:26
msgid "nValue:  the value to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:1
msgid ""
"void OGR_F_SetFieldInteger64List(OGRFeatureH hFeat, int iField, int "
"nCount, const GIntBig *panValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:5
msgid "Set field to list of 64 bit integers value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:7
#: osgeo.ogr.Feature.SetFieldIntegerList:7
msgid ""
"This function currently on has an effect of OFTIntegerList, "
"OFTInteger64List and OFTRealList fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:27
#: osgeo.ogr.Feature.SetFieldIntegerList:27
msgid "panValues:  the values to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldIntegerList:1
msgid ""
"void OGR_F_SetFieldIntegerList(OGRFeatureH hFeat, int iField, int nCount,"
" const int *panValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldIntegerList:5
msgid "Set field to list of integers value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:1
msgid "void OGR_F_SetFieldNull(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:4
msgid "Clear a field, marking it as null."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:6
msgid "This function is the same as the C++ method OGRFeature::SetFieldNull()."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:14
msgid "iField:  the field to set to null."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:1
msgid ""
"void OGR_F_SetFieldString(OGRFeatureH hFeat, int iField, const char "
"*pszValue)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:5
msgid "Set field to string value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:7
msgid ""
"OFTInteger fields will be set based on an atoi() conversion of the "
"string. OFTInteger64 fields will be set based on an CPLAtoGIntBig() "
"conversion of the string. OFTReal fields will be set based on an "
"CPLAtof() conversion of the string. Other field types may be unaffected."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:28
msgid "pszValue:  the value to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:1
msgid ""
"void OGR_F_SetFieldStringList(OGRFeatureH hFeat, int iField, CSLConstList"
" papszValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:5
msgid "Set field to list of strings value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:7
msgid "This function currently on has an effect of OFTStringList fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:24
msgid ""
"papszValues:  the values to assign. List of NUL-terminated string, ending"
" with a NULL pointer."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:1
msgid ""
"OGRErr OGR_F_SetFrom(OGRFeatureH hFeat, OGRFeatureH hOtherFeat, int "
"bForgiving)"
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:4 osgeo.ogr.Feature.SetFromWithMap:5
msgid "Set one feature from another."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:6
msgid ""
"Overwrite the contents of this feature from the geometry and attributes "
"of another. The hOtherFeature does not need to have the same "
"OGRFeatureDefn. Field values are copied by corresponding field names. "
"Field types do not have to exactly match. OGR_F_SetField*() function "
"conversion rules will be applied as needed."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:12 osgeo.ogr.Feature.SetFromWithMap:16
msgid "This function is the same as the C++ method OGRFeature::SetFrom()."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:17 osgeo.ogr.Feature.SetFromWithMap:21
msgid "hFeat:  handle to the feature to set to."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:19 osgeo.ogr.Feature.SetFromWithMap:23
msgid ""
"hOtherFeat:  handle to the feature from which geometry, and field values "
"will be copied."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:22 osgeo.ogr.Feature.SetFromWithMap:32
msgid ""
"bForgiving:  TRUE if the operation should continue despite lacking output"
" fields matching some of the source fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:25 osgeo.ogr.Feature.SetFromWithMap:35
msgid ""
"OGRERR_NONE if the operation succeeds, even if some values are not "
"transferred, otherwise an error code."
msgstr ""

#: of osgeo.ogr.Feature.SetFromWithMap:1
msgid ""
"OGRErr OGR_F_SetFromWithMap(OGRFeatureH hFeat, OGRFeatureH hOtherFeat, "
"int bForgiving, const int *panMap)"
msgstr ""

#: of osgeo.ogr.Feature.SetFromWithMap:7
msgid ""
"Overwrite the contents of this feature from the geometry and attributes "
"of another. The hOtherFeature does not need to have the same "
"OGRFeatureDefn. Field values are copied according to the provided indices"
" map. Field types do not have to exactly match. OGR_F_SetField*() "
"function conversion rules will be applied as needed. This is more "
"efficient than OGR_F_SetFrom() in that this doesn't lookup the fields by "
"their names. Particularly useful when the field names don't match."
msgstr ""

#: of osgeo.ogr.Feature.SetFromWithMap:26
msgid ""
"panMap:  Array of the indices of the destination feature's fields stored "
"at the corresponding index of the source feature's fields. A value of -1 "
"should be used to ignore the source's field. The array should not be NULL"
" and be as long as the number of fields in the source feature."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:1
msgid ""
"OGRErr OGR_F_SetGeomField(OGRFeatureH hFeat, int iField, OGRGeometryH "
"hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:4 osgeo.ogr.Feature.SetGeomFieldDirectly:5
msgid "Set feature geometry of a specified geometry field."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:6 osgeo.ogr.Feature.SetGeometry:6
msgid ""
"This function updates the features geometry, and operate exactly as "
"SetGeometryDirectly(), except that this function does not assume "
"ownership of the passed geometry, but instead makes a copy of it."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:10
msgid "This function is the same as the C++ OGRFeature::SetGeomField()."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:15 osgeo.ogr.Feature.SetGeometry:21
msgid "hFeat:  handle to the feature on which new geometry is applied to."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:17
#: osgeo.ogr.Feature.SetGeomFieldDirectly:19
msgid "iField:  geometry field to set."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:19
#: osgeo.ogr.Feature.SetGeomFieldDirectly:21 osgeo.ogr.Feature.SetGeometry:23
#: osgeo.ogr.Feature.SetGeometryDirectly:24
msgid "hGeom:  handle to the new geometry to apply to feature."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:21 osgeo.ogr.Feature.SetGeometry:25
#: osgeo.ogr.Feature.SetGeometryDirectly:26
msgid ""
"OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the "
"geometry type is illegal for the OGRFeatureDefn (checking not yet "
"implemented)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:1
msgid ""
"OGRErr OGR_F_SetGeomFieldDirectly(OGRFeatureH hFeat, int iField, "
"OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:7
msgid ""
"This function updates the features geometry, and operate exactly as "
"SetGeomField(), except that this function assumes ownership of the passed"
" geometry (even in case of failure of that function)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:11
msgid ""
"This function is the same as the C++ method "
"OGRFeature::SetGeomFieldDirectly."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:17
#: osgeo.ogr.Feature.SetGeometryDirectly:22
msgid "hFeat:  handle to the feature on which to apply the geometry."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:23
msgid ""
"OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid, or "
"OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the "
"OGRFeatureDefn (checking not yet implemented)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometry:1
msgid "OGRErr OGR_F_SetGeometry(OGRFeatureH hFeat, OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeometry:4 osgeo.ogr.Feature.SetGeometryDirectly:4
msgid "Set feature geometry."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometry:10
msgid "This function is the same as the C++ OGRFeature::SetGeometry()."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometryDirectly:1
msgid "OGRErr OGR_F_SetGeometryDirectly(OGRFeatureH hFeat, OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeometryDirectly:6
msgid ""
"This function updates the features geometry, and operate exactly as "
"SetGeometry(), except that this function assumes ownership of the passed "
"geometry (even in case of failure of that function)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometryDirectly:10
msgid ""
"This function is the same as the C++ method "
"OGRFeature::SetGeometryDirectly."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:1
msgid "void OGR_F_SetNativeData(OGRFeatureH hFeat, const char *pszNativeData)"
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:4
msgid "Sets the native data for the feature."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:11
msgid "This function is the same as the C++ method OGRFeature::SetNativeData()."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:19
msgid "pszNativeData:  a string with the native data, or NULL if there is none."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:1
msgid ""
"void OGR_F_SetNativeMediaType(OGRFeatureH hFeat, const char "
"*pszNativeMediaType)"
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:5
msgid "Sets the native media type for the feature."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:12
msgid ""
"This function is the same as the C++ method "
"OGRFeature::SetNativeMediaType()."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:20
msgid ""
"pszNativeMediaType:  a string with the native media type, or NULL if "
"there is none."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:1
msgid "void OGR_F_SetStyleString(OGRFeatureH hFeat, const char *pszStyle)"
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:4
msgid "Set feature style string."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:6
msgid ""
"This method operate exactly as OGR_F_SetStyleStringDirectly() except that"
" it does not assume ownership of the passed string, but instead makes a "
"copy of it."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:10
msgid "This function is the same as the C++ method OGRFeature::SetStyleString()."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:16
msgid "hFeat:  handle to the feature to set style to."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:18
msgid "pszStyle:  the style string to apply to this feature, cannot be NULL."
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:1
msgid "void OGR_F_UnsetField(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:4
msgid "Clear a field, marking it as unset."
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:6
msgid "This function is the same as the C++ method OGRFeature::UnsetField()."
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:13
msgid "iField:  the field to unset."
msgstr ""

#: of osgeo.ogr.Feature.Validate:1
msgid "int OGR_F_Validate(OGRFeatureH hFeat, int nValidateFlags, int bEmitError)"
msgstr ""

#: of osgeo.ogr.Feature.Validate:4
msgid "Validate that a feature meets constraints of its schema."
msgstr ""

#: of osgeo.ogr.Feature.Validate:6
msgid "The scope of test is specified with the nValidateFlags parameter."
msgstr ""

#: of osgeo.ogr.Feature.Validate:8
msgid ""
"Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width "
"must be interpreted as the number of UTF-8 characters. Some drivers might"
" interpret the width as the number of bytes instead. So this test is "
"rather conservative (if it fails, then it will fail for all "
"interpretations)."
msgstr ""

#: of osgeo.ogr.Feature.Validate:14
msgid "This function is the same as the C++ method OGRFeature::Validate()."
msgstr ""

#: of osgeo.ogr.Feature.Validate:19
msgid "hFeat:  handle to the feature to validate."
msgstr ""

#: of osgeo.ogr.Feature.Validate:21
msgid ""
"nValidateFlags:  OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL, "
"OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and "
"OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with '|' operator"
msgstr ""

#: of osgeo.ogr.Feature.Validate:25
msgid "bEmitError:  TRUE if a CPLError() must be emitted when a check fails"
msgstr ""

#: of osgeo.ogr.Feature.Validate:27
msgid "TRUE if all enabled validation tests pass."
msgstr ""

#: ../../source/api/python/vector_api.rst:35
msgid "Geometry"
msgstr ""

#: of osgeo.ogr.Geometry:1
msgid "Proxy of C++ OGRGeometryShadow class."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:1
msgid ""
"void OGR_G_AssignSpatialReference(OGRGeometryH hGeom, "
"OGRSpatialReferenceH hSRS)"
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:5
msgid "Assign spatial reference to this object."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:7
msgid ""
"Any existing spatial reference is replaced, but under no circumstances "
"does this result in the object being reprojected. It is just changing the"
" interpretation of the existing geometry. Note that assigning a spatial "
"reference increments the reference count on the OGRSpatialReference, but "
"does not copy it."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:13
msgid ""
"Starting with GDAL 2.3, this will also assign the spatial reference to "
"potential sub-geometries of the geometry ( OGRGeometryCollection, "
"OGRCurvePolygon/OGRPolygon, OGRCompoundCurve, OGRPolyhedralSurface and "
"their derived classes)."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:18
msgid "This is similar to the SFCOM IGeometry::put_SpatialReference() method."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:20
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::assignSpatialReference."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:26
msgid "hGeom:  handle on the geometry to apply the new spatial reference system."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:29
msgid "hSRS:  handle on the new spatial reference system to apply."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:1
msgid "OGRGeometryH OGR_G_Boundary(OGRGeometryH hTarget)"
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:4
msgid "Compute boundary."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:6
msgid ""
"A new geometry object is created and returned containing the boundary of "
"the geometry on which the method is invoked."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:9
msgid "This function is the same as the C++ method OGR_G_Boundary()."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:11 osgeo.ogr.Geometry.Buffer:19
#: osgeo.ogr.Geometry.Centroid:18 osgeo.ogr.Geometry.Contains:14
#: osgeo.ogr.Geometry.ConvexHull:11 osgeo.ogr.Geometry.Crosses:14
#: osgeo.ogr.Geometry.Difference:15 osgeo.ogr.Geometry.Disjoint:14
#: osgeo.ogr.Geometry.Distance:11 osgeo.ogr.Geometry.Intersection:17
#: osgeo.ogr.Geometry.Overlaps:15 osgeo.ogr.Geometry.Polygonize:13
#: osgeo.ogr.Geometry.Simplify:8 osgeo.ogr.Geometry.SimplifyPreserveTopology:9
#: osgeo.ogr.Geometry.SymDifference:16 osgeo.ogr.Geometry.Touches:14
#: osgeo.ogr.Geometry.Union:15 osgeo.ogr.Geometry.UnionCascaded:13
#: osgeo.ogr.Geometry.Within:14
msgid ""
"This function is built on the GEOS library, check it for the definition "
"of the geometry operation. If OGR is built without the GEOS library, this"
" function will always fail, issuing a CPLE_NotSupported error."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:19
msgid "hTarget:  The Geometry to calculate the boundary of."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:21 osgeo.ogr.Geometry.ConvexHull:21
#: osgeo.ogr.Geometry.Polygonize:23
msgid ""
"a handle to a newly allocated geometry now owned by the caller, or NULL "
"on failure."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:1
msgid ""
"OGRGeometryH OGR_G_Buffer(OGRGeometryH hTarget, double dfDist, int "
"nQuadSegs)"
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:4
msgid "Compute buffer of geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:6
msgid ""
"Builds a new geometry containing the buffer region around the geometry on"
" which it is invoked. The buffer is a polygon containing the region "
"within the buffer distance of the original geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:10
msgid ""
"Some buffer sections are properly described as curves, but are converted "
"to approximate polygons. The nQuadSegs parameter can be used to control "
"how many segments should be used to define a 90 degree curve - a quadrant"
" of a circle. A value of 30 is a reasonable default. Large values result "
"in large numbers of vertices in the resulting buffer geometry while small"
" numbers reduce the accuracy of the result."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:17
msgid "This function is the same as the C++ method OGRGeometry::Buffer()."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:27
msgid "hTarget:  the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:29
msgid ""
"dfDist:  the buffer distance to be applied. Should be expressed into the "
"same unit as the coordinates of the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:32
msgid ""
"nQuadSegs:  the number of segments used to approximate a 90 degree "
"(quadrant) of curvature."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:35
msgid "the newly created geometry, or NULL if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:1
msgid "int OGR_G_Centroid(OGRGeometryH hGeom, OGRGeometryH hCentroidPoint)"
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:4
msgid "Compute the geometry centroid."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:6
msgid ""
"The centroid location is applied to the passed in OGRPoint object. The "
"centroid is not necessarily within the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:9
msgid ""
"This method relates to the SFCOM ISurface::get_Centroid() method however "
"the current implementation based on GEOS can operate on other geometry "
"types such as multipoint, linestring, geometrycollection such as "
"multipolygons. OGC SF SQL 1.1 defines the operation for surfaces "
"(polygons). SQL/MM-Part 3 defines the operation for surfaces and "
"multisurfaces (multipolygons)."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:16
msgid "This function is the same as the C++ method OGRGeometry::Centroid()."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:23
msgid "OGRERR_NONE on success or OGRERR_FAILURE on error."
msgstr ""

#: of osgeo.ogr.Geometry.Clone:1
msgid "OGRGeometryH OGR_G_Clone(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.Clone:4
msgid "Make a copy of this object."
msgstr ""

#: of osgeo.ogr.Geometry.Clone:6
msgid "This function relates to the SFCOM IGeometry::clone() method."
msgstr ""

#: of osgeo.ogr.Geometry.Clone:8
msgid "This function is the same as the CPP method OGRGeometry::clone()."
msgstr ""

#: of osgeo.ogr.Geometry.Clone:13
msgid "hGeom:  handle on the geometry to clone from."
msgstr ""

#: of osgeo.ogr.Geometry.Clone:15
msgid ""
"a handle on the copy of the geometry with the spatial reference system as"
" the original."
msgstr ""

#: of osgeo.ogr.Geometry.CloseRings:1
msgid "void OGR_G_CloseRings(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.CloseRings:4
msgid "Force rings to be closed."
msgstr ""

#: of osgeo.ogr.Geometry.CloseRings:6
msgid ""
"If this geometry, or any contained geometries has polygon rings that are "
"not closed, they will be closed by adding the starting point at the end."
msgstr ""

#: of osgeo.ogr.Geometry.CloseRings:13
msgid "hGeom:  handle to the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:1
msgid "int OGR_G_Contains(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Contains:4 osgeo.ogr.Geometry.Within:4
msgid "Test for containment."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:6
msgid "Tests if this geometry contains the other geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:8 osgeo.ogr.Geometry.Crosses:8
#: osgeo.ogr.Geometry.Difference:9 osgeo.ogr.Geometry.Disjoint:8
#: osgeo.ogr.Geometry.Intersection:10 osgeo.ogr.Geometry.Overlaps:9
#: osgeo.ogr.Geometry.SymDifference:9 osgeo.ogr.Geometry.Touches:8
#: osgeo.ogr.Geometry.Union:9 osgeo.ogr.Geometry.UnionCascaded:6
#: osgeo.ogr.Geometry.Within:8
msgid ""
"Geometry validity is not checked. In case you are unsure of the validity "
"of the input geometries, call IsValid() before, otherwise the result "
"might be wrong."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:12
msgid "This function is the same as the C++ method OGRGeometry::Contains()."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:22 osgeo.ogr.Geometry.Crosses:22
#: osgeo.ogr.Geometry.Disjoint:22 osgeo.ogr.Geometry.Overlaps:23
#: osgeo.ogr.Geometry.Touches:22 osgeo.ogr.Geometry.Within:22
msgid "hThis:  the geometry to compare."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:24 osgeo.ogr.Geometry.Crosses:24
#: osgeo.ogr.Geometry.Disjoint:24 osgeo.ogr.Geometry.Overlaps:25
#: osgeo.ogr.Geometry.Touches:24 osgeo.ogr.Geometry.Within:24
msgid "hOther:  the other geometry to compare."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:26
msgid "TRUE if hThis contains hOther geometry, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:1
msgid "OGRGeometryH OGR_G_ConvexHull(OGRGeometryH hTarget)"
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:4
msgid "Compute convex hull."
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:6
msgid ""
"A new geometry object is created and returned containing the convex hull "
"of the geometry on which the method is invoked."
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:9
msgid "This function is the same as the C++ method OGRGeometry::ConvexHull()."
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:19
msgid "hTarget:  The Geometry to calculate the convex hull of."
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:1
msgid "int OGR_G_CoordinateDimension(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:4
#: osgeo.ogr.Geometry.GetCoordinateDimension:4
msgid "Get the dimension of the coordinates in this geometry."
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:6
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::CoordinateDimension()."
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:12
#: osgeo.ogr.Geometry.GetCoordinateDimension:12
msgid ""
"hGeom:  handle on the geometry to get the dimension of the coordinates "
"from."
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:15
msgid "this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data."
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:1
msgid "int OGR_G_Crosses(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:4
msgid "Test for crossing."
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:6
msgid "Tests if this geometry and the other geometry are crossing."
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:12
msgid "This function is the same as the C++ method OGRGeometry::Crosses()."
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:26
msgid "TRUE if they are crossing, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:1
msgid ""
"OGRGeometryH OGR_G_DelaunayTriangulation(OGRGeometryH hThis, double "
"dfTolerance, int bOnlyEdges)"
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:5
msgid "Return a Delaunay triangulation of the vertices of the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:7
msgid ""
"This function is the same as the C++ method "
"OGRGeometry::DelaunayTriangulation()."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:10
msgid ""
"This function is built on the GEOS library, v3.4 or above. If OGR is "
"built without the GEOS library, this function will always fail, issuing a"
" CPLE_NotSupported error."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:17
#: osgeo.ogr.Geometry.Difference:23 osgeo.ogr.Geometry.Intersection:25
#: osgeo.ogr.Geometry.Simplify:16
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:17
#: osgeo.ogr.Geometry.SymDifference:24 osgeo.ogr.Geometry.Union:23
#: osgeo.ogr.Geometry.UnionCascaded:21
msgid "hThis:  the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:19
msgid "dfTolerance:  optional snapping tolerance to use for improved robustness"
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:22
msgid ""
"bOnlyEdges:  if TRUE, will return a MULTILINESTRING, otherwise it will "
"return a GEOMETRYCOLLECTION containing triangular POLYGONs."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:25
msgid ""
"the geometry resulting from the Delaunay triangulation or NULL if an "
"error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:28
msgid "OGR 2.1"
msgstr ""

#: of osgeo.ogr.Geometry.Difference:1
msgid "OGRGeometryH OGR_G_Difference(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Difference:4
msgid "Compute difference."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:6
msgid ""
"Generates a new geometry which is the region of this geometry with the "
"region of the other geometry removed."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:13
msgid "This function is the same as the C++ method OGRGeometry::Difference()."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:25 osgeo.ogr.Geometry.Intersection:27
#: osgeo.ogr.Geometry.SymDifference:26 osgeo.ogr.Geometry.Union:25
msgid "hOther:  the other geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:27
msgid ""
"a new geometry representing the difference or NULL if the difference is "
"empty or an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:1
msgid "int OGR_G_Disjoint(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:4
msgid "Test for disjointness."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:6
msgid "Tests if this geometry and the other geometry are disjoint."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:12
msgid "This function is the same as the C++ method OGRGeometry::Disjoint()."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:26
msgid "TRUE if they are disjoint, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:1
msgid "double OGR_G_Distance(OGRGeometryH hFirst, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Distance:4
msgid "Compute distance between two geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:6
msgid ""
"Returns the shortest distance between the two geometries. The distance is"
" expressed into the same unit as the coordinates of the geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:9
msgid "This function is the same as the C++ method OGRGeometry::Distance()."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:19 osgeo.ogr.Geometry.Distance3D:18
msgid "hFirst:  the first geometry to compare against."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:21 osgeo.ogr.Geometry.Distance3D:20
msgid "hOther:  the other geometry to compare against."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:23 osgeo.ogr.Geometry.Distance3D:26
msgid "the distance between the geometries or -1 if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:1
msgid "double OGR_G_Distance3D(OGRGeometryH hFirst, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:4
msgid "Returns the 3D distance between two geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:6
msgid ""
"The distance is expressed into the same unit as the coordinates of the "
"geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:9
msgid ""
"This method is built on the SFCGAL library, check it for the definition "
"of the geometry operation. If OGR is built without the SFCGAL library, "
"this method will always return -1.0"
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:13
msgid "This function is the same as the C++ method OGRGeometry::Distance3D()."
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:22
msgid "distance between the two geometries"
msgstr ""

#: of osgeo.ogr.Geometry.Empty:1
msgid "void OGR_G_Empty(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.Empty:3
msgid "Clear geometry information."
msgstr ""

#: of osgeo.ogr.Geometry.Empty:5
msgid ""
"This restores the geometry to its initial state after construction, and "
"before assignment of actual geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Empty:8
msgid "This function relates to the SFCOM IGeometry::Empty() method."
msgstr ""

#: of osgeo.ogr.Geometry.Empty:10
msgid "This function is the same as the CPP method OGRGeometry::empty()."
msgstr ""

#: of osgeo.ogr.Geometry.Empty:15
msgid "hGeom:  handle on the geometry to empty."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:1
msgid "int OGR_G_Equals(OGRGeometryH hGeom, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Equals:4
msgid "Returns TRUE if two geometries are equivalent."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:6
msgid "This operation implements the SQL/MM ST_OrderingEquals() operation."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:8
msgid ""
"The comparison is done in a structural way, that is to say that the "
"geometry types must be identical, as well as the number and ordering of "
"sub-geometries and vertices. Or equivalently, two geometries are "
"considered equal by this method if their WKT/WKB representation is equal."
" Note: this must be distinguished for equality in a spatial way (which is"
" the purpose of the ST_Equals() operation)."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:15
msgid "This function is the same as the CPP method OGRGeometry::Equals() method."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:21 osgeo.ogr.Geometry.Intersects:15
msgid "hGeom:  handle on the first geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:23
msgid "hOther:  handle on the other geometry to test against."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:25
msgid "TRUE if equivalent or FALSE otherwise."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:1
msgid ""
"OGRErr OGR_G_ExportToIsoWkb(OGRGeometryH hGeom, OGRwkbByteOrder eOrder, "
"unsigned char *pabyDstBuffer)"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:5
msgid ""
"Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary "
"format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:8
msgid ""
"This function relates to the SFCOM IWks::ExportToWKB() method. It exports"
" the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&M) WKB types."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:12
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::exportToWkb(OGRwkbByteOrder, unsigned char *, OGRwkbVariant)"
" with eWkbVariant = wkbVariantIso."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:19 osgeo.ogr.Geometry.ExportToWkb:21
msgid "hGeom:  handle on the geometry to convert to a well know binary data from."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:22 osgeo.ogr.Geometry.ExportToWkb:24
msgid ""
"eOrder:  One of wkbXDR or wkbNDR indicating MSB or LSB byte order "
"respectively."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:25 osgeo.ogr.Geometry.ExportToWkb:27
msgid ""
"pabyDstBuffer:  a buffer into which the binary representation is written."
" This buffer must be at least OGR_G_WkbSize() byte in size."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:28 osgeo.ogr.Geometry.ExportToIsoWkt:23
#: osgeo.ogr.Geometry.ExportToWkb:30 osgeo.ogr.Geometry.ExportToWkt:25
msgid "Currently OGRERR_NONE is always returned."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:1
msgid "OGRErr OGR_G_ExportToIsoWkt(OGRGeometryH hGeom, char **ppszSrcText)"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:4
msgid ""
"Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text "
"format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:7
msgid ""
"This function relates to the SFCOM IWks::ExportToWKT() method. It exports"
" the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&M) WKB types."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:11
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::exportToWkt(wkbVariantIso)."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:17 osgeo.ogr.Geometry.ExportToWkt:19
msgid "hGeom:  handle on the geometry to convert to a text format from."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:19 osgeo.ogr.Geometry.ExportToWkt:21
msgid ""
"ppszSrcText:  a text buffer is allocated by the program, and assigned to "
"the passed pointer. After use, *ppszDstText should be freed with "
"CPLFree()."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:1
msgid ""
"OGRErr OGR_G_ExportToWkb(OGRGeometryH hGeom, OGRwkbByteOrder eOrder, "
"unsigned char *pabyDstBuffer)"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:5
msgid "Convert a geometry well known binary format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:7
msgid "This function relates to the SFCOM IWks::ExportToWKB() method."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:9
msgid ""
"For backward compatibility purposes, it exports the Old-style 99-402 "
"extended dimension (Z) WKB types for types Point, LineString, Polygon, "
"MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For "
"other geometry types, it is equivalent to OGR_G_ExportToIsoWkb()."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:14
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::exportToWkb(OGRwkbByteOrder, unsigned char *, OGRwkbVariant)"
" with eWkbVariant = wkbVariantOldOgc."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:1
msgid "OGRErr OGR_G_ExportToWkt(OGRGeometryH hGeom, char **ppszSrcText)"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:4
msgid "Convert a geometry into well known text format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:6
msgid "This function relates to the SFCOM IWks::ExportToWKT() method."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:8
msgid ""
"For backward compatibility purposes, it exports the Old-style 99-402 "
"extended dimension (Z) WKB types for types Point, LineString, Polygon, "
"MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For "
"other geometry types, it is equivalent to OGR_G_ExportToIsoWkt()."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:13
msgid "This function is the same as the CPP method OGRGeometry::exportToWkt()."
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:1
msgid "void OGR_G_FlattenTo2D(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:4
msgid "Convert geometry to strictly 2D."
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:6
msgid "In a sense this converts all Z coordinates to 0.0."
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:8
msgid "This function is the same as the CPP method OGRGeometry::flattenTo2D()."
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:14
msgid "hGeom:  handle on the geometry to convert."
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:1
msgid "OGRGeometryH OGR_G_GetBoundary(OGRGeometryH hTarget)"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:4
msgid "Compute boundary (deprecated)"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:6 osgeo.ogr.Geometry.SymmetricDifference:6
msgid "Deprecated"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:8
msgid "See:   OGR_G_Boundary()"
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:1
msgid "int OGR_G_GetCoordinateDimension(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:6
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::getCoordinateDimension()."
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:15
msgid ""
"Deprecated use OGR_G_CoordinateDimension(), OGR_G_Is3D(), or "
"OGR_G_IsMeasured()."
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:18
msgid "this will return 2 or 3."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:1
msgid "int OGR_G_GetDimension(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:4
msgid "Get the dimension of this geometry."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:6
msgid ""
"This function corresponds to the SFCOM IGeometry::GetDimension() method. "
"It indicates the dimension of the geometry, but does not indicate the "
"dimension of the underlying space (as indicated by "
"OGR_G_GetCoordinateDimension() function)."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:11
msgid "This function is the same as the CPP method OGRGeometry::getDimension()."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:17
msgid "hGeom:  handle on the geometry to get the dimension from."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:19
msgid "0 for points, 1 for lines and 2 for surfaces."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:1
msgid "void OGR_G_GetEnvelope(OGRGeometryH hGeom, OGREnvelope *psEnvelope)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:4
msgid ""
"Computes and returns the bounding envelope for this geometry in the "
"passed psEnvelope structure."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:7 osgeo.ogr.Geometry.GetEnvelope3D:7
msgid "This function is the same as the CPP method OGRGeometry::getEnvelope()."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:13 osgeo.ogr.Geometry.GetEnvelope3D:13
msgid "hGeom:  handle of the geometry to get envelope from."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:15 osgeo.ogr.Geometry.GetEnvelope3D:15
msgid "psEnvelope:  the structure in which to place the results."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:1
msgid "void OGR_G_GetEnvelope3D(OGRGeometryH hGeom, OGREnvelope3D *psEnvelope)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:4
msgid ""
"Computes and returns the bounding envelope (3D) for this geometry in the "
"passed psEnvelope structure."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:1
msgid "const char* OGR_G_GetGeometryName(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:4
msgid "Fetch WKT name for geometry type."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:6
msgid "There is no SFCOM analog to this function."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:8
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::getGeometryName()."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:14
msgid "hGeom:  handle on the geometry to get name from."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:16
msgid "name used for this geometry type in well known text format."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:1
msgid "OGRwkbGeometryType OGR_G_GetGeometryType(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:4
msgid "Fetch geometry type."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:6
msgid ""
"Note that the geometry type may include the 2.5D flag. To get a 2D "
"flattened version of the geometry type apply the wkbFlatten() macro to "
"the return result."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:10
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::getGeometryType()."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:16
msgid "hGeom:  handle on the geometry to get type from."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:18
msgid "the geometry type code."
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:1
msgid "OGRSpatialReferenceH OGR_G_GetSpatialReference(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:4
msgid "Returns spatial reference system for geometry."
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:6
msgid ""
"This function relates to the SFCOM IGeometry::get_SpatialReference() "
"method."
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:9
msgid ""
"This function is the same as the CPP method "
"OGRGeometry::getSpatialReference()."
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:15
msgid "hGeom:  handle on the geometry to get spatial reference from."
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:17
msgid "a reference to the spatial reference geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:1
msgid "OGRGeometryH OGR_G_Intersection(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:4
msgid "Compute intersection."
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:6
msgid ""
"Generates a new geometry which is the region of intersection of the two "
"geometries operated on. The OGR_G_Intersects() function can be used to "
"test if two geometries intersect."
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:14
msgid "This function is the same as the C++ method OGRGeometry::Intersection()."
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:29
msgid ""
"a new geometry representing the intersection or NULL if there is no "
"intersection or an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:1
msgid "int OGR_G_Intersects(OGRGeometryH hGeom, OGRGeometryH hOtherGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:4
msgid "Do these features intersect?"
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:6
msgid ""
"Determines whether two geometries intersect. If GEOS is enabled, then "
"this is done in rigorous fashion otherwise TRUE is returned if the "
"envelopes (bounding boxes) of the two geometries overlap."
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:10
msgid "This function is the same as the CPP method OGRGeometry::Intersects."
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:17
msgid "hOtherGeom:  handle on the other geometry to test against."
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:19
msgid "TRUE if the geometries intersect, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:1
msgid "int OGR_G_Is3D(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:3
msgid "See whether this geometry has Z coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:5
msgid "This function is the same as the CPP method OGRGeometry::Is3D()."
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:10
msgid "hGeom:  handle on the geometry to check whether it has Z coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:12
msgid "TRUE if the geometry has Z coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:1
msgid "int OGR_G_IsEmpty(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:3
msgid "Test if the geometry is empty."
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:5
msgid "This method is the same as the CPP method OGRGeometry::IsEmpty()."
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:10 osgeo.ogr.Geometry.IsRing:14
#: osgeo.ogr.Geometry.IsSimple:20 osgeo.ogr.Geometry.IsValid:14
msgid "hGeom:  The Geometry to test."
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:12 osgeo.ogr.Geometry.IsRing:16
#: osgeo.ogr.Geometry.IsValid:16
msgid "TRUE if the geometry has no points, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:1
msgid "int OGR_G_IsMeasured(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:4
msgid "See whether this geometry is measured."
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:6
msgid "This function is the same as the CPP method OGRGeometry::IsMeasured()."
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:11
msgid "hGeom:  handle on the geometry to check whether it is measured."
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:13
msgid "TRUE if the geometry has M coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.IsRing:1
msgid "int OGR_G_IsRing(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.IsRing:3
msgid "Test if the geometry is a ring."
msgstr ""

#: of osgeo.ogr.Geometry.IsRing:5
msgid "This function is the same as the C++ method OGRGeometry::IsRing()."
msgstr ""

#: of osgeo.ogr.Geometry.IsRing:7 osgeo.ogr.Geometry.IsValid:7
msgid ""
"This function is built on the GEOS library, check it for the definition "
"of the geometry operation. If OGR is built without the GEOS library, this"
" function will always return FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:1
msgid "int OGR_G_IsSimple(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:4
msgid "Returns TRUE if the geometry is simple."
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:6
msgid ""
"Returns TRUE if the geometry has no anomalous geometric points, such as "
"self intersection or self tangency. The description of each instantiable "
"geometric class will include the specific conditions that cause an "
"instance of that class to be classified as not simple."
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:11
msgid ""
"This function is the same as the C++ method OGRGeometry::IsSimple() "
"method."
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:14
msgid ""
"If OGR is built without the GEOS library, this function will always "
"return FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:22
msgid "TRUE if object is simple, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.IsValid:1
msgid "int OGR_G_IsValid(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.IsValid:3
msgid "Test if the geometry is valid."
msgstr ""

#: of osgeo.ogr.Geometry.IsValid:5
msgid "This function is the same as the C++ method OGRGeometry::IsValid()."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:1
msgid "OGRGeometryH OGR_G_MakeValid(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:4
msgid "Attempts to make an invalid geometry valid without losing vertices."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:6
msgid "Already-valid geometries are cloned without further intervention."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:8
msgid "This function is the same as the C++ method OGRGeometry::MakeValid()."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:10
msgid ""
"This function is built on the GEOS >= 3.8 library, check it for the "
"definition of the geometry operation. If OGR is built without the GEOS >="
" 3.8 library, this function will return a clone of the input geometry if "
"it is valid, or NULL if it is invalid"
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:18
msgid "hGeom:  The Geometry to make valid."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:20
msgid "a newly allocated geometry now owned by the caller, or NULL on failure."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:23
msgid "GDAL 3.0"
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:1
msgid "int OGR_G_Overlaps(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:4
msgid "Test for overlap."
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:6
msgid ""
"Tests if this geometry and the other geometry overlap, that is their "
"intersection has a non-zero area."
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:13
msgid "This function is the same as the C++ method OGRGeometry::Overlaps()."
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:27
msgid "TRUE if they are overlapping, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:1
msgid "OGRGeometryH OGR_G_PointOnSurface(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:4
msgid "Returns a point guaranteed to lie on the surface."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:6
msgid ""
"This method relates to the SFCOM ISurface::get_PointOnSurface() method "
"however the current implementation based on GEOS can operate on other "
"geometry types than the types that are supported by SQL/MM-Part 3 : "
"surfaces (polygons) and multisurfaces (multipolygons)."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:11
msgid ""
"This method is built on the GEOS library, check it for the definition of "
"the geometry operation. If OGR is built without the GEOS library, this "
"method will always fail, issuing a CPLE_NotSupported error."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:18
msgid "hGeom:  the geometry to operate on."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:20
msgid "a point guaranteed to lie on the surface or NULL if an error occurred."
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:1
msgid "OGRGeometryH OGR_G_Polygonize(OGRGeometryH hTarget)"
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:4
msgid "Polygonizes a set of sparse edges."
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:6
msgid ""
"A new geometry object is created and returned containing a collection of "
"reassembled Polygons: NULL will be returned if the input collection "
"doesn't corresponds to a MultiLinestring, or when reassembling Edges into"
" Polygons is impossible due to topological inconsistencies."
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:11
msgid "This function is the same as the C++ method OGRGeometry::Polygonize()."
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:21
msgid "hTarget:  The Geometry to be polygonized."
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:1
msgid "void OGR_G_Segmentize(OGRGeometryH hGeom, double dfMaxLength)"
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:4
msgid "Modify the geometry such it has no segment longer then the given distance."
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:7
msgid ""
"Interpolated points will have Z and M values (if needed) set to 0. "
"Distance computation is performed in 2d only."
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:10
msgid "This function is the same as the CPP method OGRGeometry::segmentize()."
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:15
msgid "hGeom:  handle on the geometry to segmentize"
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:17
msgid "dfMaxLength:  the maximum distance between 2 points after segmentization"
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:1
msgid "void OGR_G_Set3D(OGRGeometryH hGeom, int bIs3D)"
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:4
msgid "Add or remove the Z coordinate dimension."
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:6
msgid ""
"This method adds or removes the explicit Z coordinate dimension. Removing"
" the Z coordinate dimension of a geometry will remove any existing Z "
"values. Adding the Z dimension to a geometry collection, a compound "
"curve, a polygon, etc. will affect the children geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:14
msgid "hGeom:  handle on the geometry to set or unset the Z dimension."
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:16
msgid "bIs3D:  Should the geometry have a Z dimension, either TRUE or FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:1
msgid "void OGR_G_SetCoordinateDimension(OGRGeometryH hGeom, int nNewDimension)"
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:4
msgid "Set the coordinate dimension."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:6
msgid ""
"This method sets the explicit coordinate dimension. Setting the "
"coordinate dimension of a geometry to 2 should zero out any existing Z "
"values. Setting the dimension of a geometry collection, a compound curve,"
" a polygon, etc. will affect the children geometries. This will also "
"remove the M dimension if present before this call."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:12
msgid "Deprecated use OGR_G_Set3D() or OGR_G_SetMeasured()."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:17
msgid "hGeom:  handle on the geometry to set the dimension of the coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:20
msgid "nNewDimension:  New coordinate dimension value, either 2 or 3."
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:1
msgid "void OGR_G_SetMeasured(OGRGeometryH hGeom, int bIsMeasured)"
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:4
msgid "Add or remove the M coordinate dimension."
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:6
msgid ""
"This method adds or removes the explicit M coordinate dimension. Removing"
" the M coordinate dimension of a geometry will remove any existing M "
"values. Adding the M dimension to a geometry collection, a compound "
"curve, a polygon, etc. will affect the children geometries."
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:14
msgid "hGeom:  handle on the geometry to set or unset the M dimension."
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:16
msgid ""
"bIsMeasured:  Should the geometry have a M dimension, either TRUE or "
"FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:1
msgid "OGRGeometryH OGR_G_Simplify(OGRGeometryH hThis, double dTolerance)"
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:4
msgid "Compute a simplified geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:6
msgid "This function is the same as the C++ method OGRGeometry::Simplify()."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:18
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:19
msgid "dTolerance:  the distance tolerance for the simplification."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:20
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:21
msgid "the simplified geometry or NULL if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.SimplifyPreserveTopology:1
msgid ""
"OGRGeometryH OGR_G_SimplifyPreserveTopology(OGRGeometryH hThis, double "
"dTolerance)"
msgstr ""

#: of osgeo.ogr.Geometry.SimplifyPreserveTopology:4
msgid "Simplify the geometry while preserving topology."
msgstr ""

#: of osgeo.ogr.Geometry.SimplifyPreserveTopology:6
msgid ""
"This function is the same as the C++ method "
"OGRGeometry::SimplifyPreserveTopology()."
msgstr ""

#: of osgeo.ogr.Geometry.SwapXY:1
msgid "void OGR_G_SwapXY(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.SwapXY:3
msgid "Swap x and y coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.SwapXY:8
msgid "hGeom:  geometry."
msgstr ""

#: of osgeo.ogr.Geometry.SwapXY:10
msgid "OGR 2.3.0"
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:1
msgid "OGRGeometryH OGR_G_SymDifference(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:4
msgid "Compute symmetric difference."
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:6
msgid ""
"Generates a new geometry which is the symmetric difference of this "
"geometry and the other geometry."
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:13
msgid ""
"This function is the same as the C++ method "
"OGRGeometry::SymmetricDifference()."
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:28
msgid ""
"a new geometry representing the symmetric difference or NULL if the "
"difference is empty or an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.SymmetricDifference:1
msgid ""
"OGRGeometryH OGR_G_SymmetricDifference(OGRGeometryH hThis, OGRGeometryH "
"hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.SymmetricDifference:4
msgid "Compute symmetric difference (deprecated)"
msgstr ""

#: of osgeo.ogr.Geometry.SymmetricDifference:8
msgid "See:  OGR_G_SymmetricDifference()"
msgstr ""

#: of osgeo.ogr.Geometry.Touches:1
msgid "int OGR_G_Touches(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Touches:4
msgid "Test for touching."
msgstr ""

#: of osgeo.ogr.Geometry.Touches:6
msgid "Tests if this geometry and the other geometry are touching."
msgstr ""

#: of osgeo.ogr.Geometry.Touches:12
msgid "This function is the same as the C++ method OGRGeometry::Touches()."
msgstr ""

#: of osgeo.ogr.Geometry.Touches:26
msgid "TRUE if they are touching, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:1
msgid ""
"OGRErr OGR_G_Transform(OGRGeometryH hGeom, OGRCoordinateTransformationH "
"hTransform)"
msgstr ""

#: of osgeo.ogr.Geometry.Transform:4
msgid "Apply arbitrary coordinate transformation to geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:6 osgeo.ogr.Geometry.TransformTo:6
msgid ""
"This function will transform the coordinates of a geometry from their "
"current spatial reference system to a new target spatial reference "
"system. Normally this means reprojecting the vectors, but it could "
"include datum shifts, and changes of units."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:11
msgid ""
"Note that this function does not require that the geometry already have a"
" spatial reference system. It will be assumed that they can be treated as"
" having the source spatial reference system of the "
"OGRCoordinateTransformation object, and the actual SRS of the geometry "
"will be ignored. On successful completion the output OGRSpatialReference "
"of the OGRCoordinateTransformation will be assigned to the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:19
msgid "This function is the same as the CPP method OGRGeometry::transform."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:24 osgeo.ogr.Geometry.TransformTo:27
msgid "hGeom:  handle on the geometry to apply the transform to."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:26
msgid "hTransform:  handle on the transformation to apply."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:1
msgid "OGRErr OGR_G_TransformTo(OGRGeometryH hGeom, OGRSpatialReferenceH hSRS)"
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:4
msgid "Transform geometry to new spatial reference system."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:11
msgid ""
"This function will only work if the geometry already has an assigned "
"spatial reference system, and if it is transformable to the target "
"coordinate system."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:15
msgid ""
"Because this function requires internal creation and initialization of an"
" OGRCoordinateTransformation object it is significantly more expensive to"
" use this function to transform many geometries than it is to create the "
"OGRCoordinateTransformation in advance, and call transform() with that "
"transformation. This function exists primarily for convenience when only "
"transforming a single geometry."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:22
msgid "This function is the same as the CPP method OGRGeometry::transformTo."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:29
msgid "hSRS:  handle on the spatial reference system to apply."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:31
msgid "OGRERR_NONE on success, or an error code."
msgstr ""

#: of osgeo.ogr.Geometry.Union:1
msgid "OGRGeometryH OGR_G_Union(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Union:4
msgid "Compute union."
msgstr ""

#: of osgeo.ogr.Geometry.Union:6
msgid ""
"Generates a new geometry which is the region of union of the two "
"geometries operated on."
msgstr ""

#: of osgeo.ogr.Geometry.Union:13
msgid "This function is the same as the C++ method OGRGeometry::Union()."
msgstr ""

#: of osgeo.ogr.Geometry.Union:27 osgeo.ogr.Geometry.UnionCascaded:23
msgid "a new geometry representing the union or NULL if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.UnionCascaded:1
msgid "OGRGeometryH OGR_G_UnionCascaded(OGRGeometryH hThis)"
msgstr ""

#: of osgeo.ogr.Geometry.UnionCascaded:4
msgid "Compute union using cascading."
msgstr ""

#: of osgeo.ogr.Geometry.UnionCascaded:10
msgid "This function is the same as the C++ method OGRGeometry::UnionCascaded()."
msgstr ""

#: of osgeo.ogr.Geometry.Within:1
msgid "int OGR_G_Within(OGRGeometryH hThis, OGRGeometryH hOther)"
msgstr ""

#: of osgeo.ogr.Geometry.Within:6
msgid "Tests if this geometry is within the other geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Within:12
msgid "This function is the same as the C++ method OGRGeometry::Within()."
msgstr ""

#: of osgeo.ogr.Geometry.Within:26
msgid "TRUE if hThis is within hOther, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:1
msgid "int OGR_G_WkbSize(OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:3
msgid "Returns size of related binary representation."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:5
msgid ""
"This function returns the exact number of bytes required to hold the well"
" known binary representation of this geometry object. Its computation may"
" be slightly expensive for complex geometries."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:9
msgid "This function relates to the SFCOM IWks::WkbSize() method."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:11
msgid "This function is the same as the CPP method OGRGeometry::WkbSize()."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:16
msgid "hGeom:  handle on the geometry to get the binary size from."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:18
msgid "size of binary representation in bytes."
msgstr ""

#: ../../source/api/python/vector_api.rst:93
msgid "FeatureDefn"
msgstr ""

#: of osgeo.ogr.FeatureDefn:1
msgid "Proxy of C++ OGRFeatureDefnShadow class."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:1
msgid "void OGR_FD_AddFieldDefn(OGRFeatureDefnH hDefn, OGRFieldDefnH hNewField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:4
#: osgeo.ogr.FeatureDefn.AddGeomFieldDefn:5
msgid "Add a new field definition to the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:6
msgid ""
"To add a new field definition to a layer definition, do not use this "
"function directly, but use OGR_L_CreateField() instead."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:9
msgid ""
"This function should only be called while there are no OGRFeature objects"
" in existence based on this OGRFeatureDefn. The OGRFieldDefn passed in is"
" copied, and remains the responsibility of the caller."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:13
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::AddFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:19
msgid "hDefn:  handle to the feature definition to add the field definition to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:22
msgid "hNewField:  handle to the new field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:1
msgid ""
"void OGR_FD_AddGeomFieldDefn(OGRFeatureDefnH hDefn, OGRGeomFieldDefnH "
"hNewGeomField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:7
msgid ""
"To add a new field definition to a layer definition, do not use this "
"function directly, but use OGR_L_CreateGeomField() instead."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:10
msgid ""
"This function should only be called while there are no OGRFeature objects"
" in existence based on this OGRFeatureDefn. The OGRGeomFieldDefn passed "
"in is copied, and remains the responsibility of the caller."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:15
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::AddGeomFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:21
msgid ""
"hDefn:  handle to the feature definition to add the geometry field "
"definition to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:24
msgid "hNewGeomField:  handle to the new field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:1
msgid "OGRErr OGR_FD_DeleteGeomFieldDefn(OGRFeatureDefnH hDefn, int iGeomField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:4
msgid "Delete an existing geometry field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:6
msgid ""
"To delete an existing geometry field definition from a layer definition, "
"do not use this function directly, but use OGR_L_DeleteGeomField() "
"instead ( not implemented yet)."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:10
msgid ""
"This method should only be called while there are no OGRFeature objects "
"in existence based on this OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:13
msgid ""
"This method is the same as the C++ method "
"OGRFeatureDefn::DeleteGeomFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:19
msgid "hDefn:  handle to the feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:21
msgid "iGeomField:  the index of the geometry field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:23
msgid "OGRERR_NONE in case of success."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:1
msgid "int OGR_FD_GetFieldCount(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:4
msgid "Fetch number of fields on the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:6
msgid "This function is the same as the C++ OGRFeatureDefn::GetFieldCount()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:11
#: osgeo.ogr.FeatureDefn.GetGeomFieldCount:12
msgid "hDefn:  handle to the feature definition to get the fields count from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:1
msgid "OGRFieldDefnH OGR_FD_GetFieldDefn(OGRFeatureDefnH hDefn, int iField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:4
msgid "Fetch field definition of the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:12
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn:12
msgid "hDefn:  handle to the feature definition to get the field definition from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:15
msgid "iField:  the field to fetch, between 0 and GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:17
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn:18
msgid ""
"a handle to an internal field definition object or NULL if invalid index."
" This object should not be modified or freed by the application."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:1
msgid "int OGR_FD_GetFieldIndex(OGRFeatureDefnH hDefn, const char *pszFieldName)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:4
msgid "Find field by name."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:6
msgid ""
"The field index of the first field matching the passed field name (case "
"insensitively) is returned."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:9
msgid "This function is the same as the C++ method OGRFeatureDefn::GetFieldIndex."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:15
#: osgeo.ogr.FeatureDefn.GetGeomFieldIndex:16
msgid "hDefn:  handle to the feature definition to get field index from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:17
msgid "pszFieldName:  the field name to search for."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:19
msgid "the field index, or -1 if no match found."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldCount:1
msgid "int OGR_FD_GetGeomFieldCount(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldCount:4
msgid "Fetch number of geometry fields on the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldCount:6
msgid "This function is the same as the C++ OGRFeatureDefn::GetGeomFieldCount()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:1
msgid ""
"OGRGeomFieldDefnH OGR_FD_GetGeomFieldDefn(OGRFeatureDefnH hDefn, int "
"iGeomField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:4
msgid "Fetch geometry field definition of the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetGeomFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:15
msgid ""
"iGeomField:  the geometry field to fetch, between 0 and "
"GetGeomFieldCount() - 1."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:1
msgid ""
"int OGR_FD_GetGeomFieldIndex(OGRFeatureDefnH hDefn, const char "
"*pszGeomFieldName)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:5
msgid "Find geometry field by name."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:7
msgid ""
"The geometry field index of the first geometry field matching the passed "
"field name (case insensitively) is returned."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:10
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetGeomFieldIndex."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:18
msgid "pszGeomFieldName:  the geometry field name to search for."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:20
msgid "the geometry field index, or -1 if no match found."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:1
msgid "OGRwkbGeometryType OGR_FD_GetGeomType(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:4
msgid "Fetch the geometry base type of the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:6
msgid "This function is the same as the C++ method OGRFeatureDefn::GetGeomType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:9
msgid ""
"Starting with GDAL 1.11, this method returns "
"GetGeomFieldDefn(0)->GetType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:15
msgid "hDefn:  handle to the feature definition to get the geometry type from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:18
msgid "the base type for all geometry related to this definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:1
msgid "const char* OGR_FD_GetName(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:4
msgid "Get name of the OGRFeatureDefn passed as an argument."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:6
msgid "This function is the same as the C++ method OGRFeatureDefn::GetName()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:11
msgid "hDefn:  handle to the feature definition to get the name from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:13
msgid "the name. This name is internal and should not be modified, or freed."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:1
msgid "int OGR_FD_GetReferenceCount(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:4
msgid "Fetch current reference count."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetReferenceCount()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:12
#: osgeo.ogr.FeatureDefn.IsGeometryIgnored:15
#: osgeo.ogr.FeatureDefn.SetGeometryIgnored:15
#: osgeo.ogr.FeatureDefn.SetStyleIgnored:12
msgid "hDefn:  handle to the feature definition on witch OGRFeature are based on."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:15
msgid "the current reference count."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:1
msgid "int OGR_FD_IsGeometryIgnored(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:4
msgid "Determine whether the geometry can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::IsGeometryIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:9
msgid ""
"Starting with GDAL 1.11, this method returns "
"GetGeomFieldDefn(0)->IsIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:18
#: osgeo.ogr.FeatureDefn.IsStyleIgnored:15 osgeo.ogr.FieldDefn.IsIgnored:13
msgid "ignore state"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:1
msgid "int OGR_FD_IsSame(OGRFeatureDefnH hFDefn, OGRFeatureDefnH hOtherFDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:4
msgid "Test if the feature definition is identical to the other one."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:9
msgid ""
"hFDefn:  handle to the feature definition on witch OGRFeature are based "
"on."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:12
msgid "hOtherFDefn:  handle to the other feature definition to compare to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:14
msgid "TRUE if the feature definition is identical to the other one."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:1
msgid "int OGR_FD_IsStyleIgnored(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:4
msgid "Determine whether the style can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::IsStyleIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:12
msgid "hDefn:  handle to the feature definition on which OGRFeature are based on."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:1
msgid "void OGR_FD_SetGeomType(OGRFeatureDefnH hDefn, OGRwkbGeometryType eType)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:4
msgid ""
"Assign the base geometry type for the passed layer (the same as the "
"feature definition)."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:7
msgid ""
"All geometry objects using this type must be of the defined type or a "
"derived type. The default upon creation is wkbUnknown which allows for "
"any geometry type. The geometry type should generally not be changed "
"after any OGRFeatures have been created against this definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:12
msgid "This function is the same as the C++ method OGRFeatureDefn::SetGeomType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:15
msgid "Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)->SetType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:21
msgid ""
"hDefn:  handle to the layer or feature definition to set the geometry "
"type to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:24
msgid "eType:  the new type to assign."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:1
msgid "void OGR_FD_SetGeometryIgnored(OGRFeatureDefnH hDefn, int bIgnore)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:4
msgid "Set whether the geometry can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::SetGeometryIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:9
msgid ""
"Starting with GDAL 1.11, this method calls "
"GetGeomFieldDefn(0)->SetIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:18
#: osgeo.ogr.FeatureDefn.SetStyleIgnored:15
msgid "bIgnore:  ignore state"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetStyleIgnored:1
msgid "void OGR_FD_SetStyleIgnored(OGRFeatureDefnH hDefn, int bIgnore)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetStyleIgnored:4
msgid "Set whether the style can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetStyleIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::SetStyleIgnored()."
msgstr ""

#: ../../source/api/python/vector_api.rst:101
msgid "FieldDefn"
msgstr ""

#: of osgeo.ogr.FieldDefn:1
msgid "Proxy of C++ OGRFieldDefnShadow class."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:1
msgid "const char* OGR_Fld_GetAlternativeNameRef(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:4
msgid "Fetch the alternative name (or \"alias\") for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:6
#: osgeo.ogr.FieldDefn.SetAlternativeName:7
msgid ""
"The alternative name is an optional attribute for a field which can "
"provide a more user-friendly, descriptive name of a field which is not "
"subject to the usual naming constraints defined by the data provider."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:10
#: osgeo.ogr.FieldDefn.SetAlternativeName:11
msgid ""
"This is a metadata style attribute only: the alternative name cannot be "
"used in place of the actual field name during SQL queries or other field "
"name dependent API calls."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:14
msgid ""
"This function is the same as the CPP method "
"OGRFieldDefn::GetAlternativeNameRef()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:20
#: osgeo.ogr.FieldDefn.GetDefault:12 osgeo.ogr.FieldDefn.GetNameRef:12
#: osgeo.ogr.FieldDefn.SetDefault:30
msgid "hDefn:  handle to the field definition."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:22
msgid "the alternative name of the field definition."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:24
#: osgeo.ogr.FieldDefn.IsUnique:17 osgeo.ogr.FieldDefn.SetAlternativeName:26
#: osgeo.ogr.FieldDefn.SetUnique:22
msgid "GDAL 3.2"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:1
msgid "const char* OGR_Fld_GetDefault(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:4
msgid "Get default field value."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:6
msgid "This function is the same as the C++ method OGRFieldDefn::GetDefault()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:14
msgid "default field value or NULL."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:1
msgid "OGRJustification OGR_Fld_GetJustify(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:4 osgeo.ogr.FieldDefn.justify:5
msgid "Get the justification for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:6 osgeo.ogr.FieldDefn.justify:7
msgid "This function is the same as the CPP method OGRFieldDefn::GetJustify()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:9 osgeo.ogr.FieldDefn.SetJustify:6
#: osgeo.ogr.FieldDefn.justify:10
msgid "Note: no driver is know to use the concept of field justification."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:14 osgeo.ogr.FieldDefn.justify:15
msgid "hDefn:  handle to the field definition to get justification from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:16 osgeo.ogr.FieldDefn.justify:17
msgid "the justification."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:1
msgid "const char* OGR_Fld_GetNameRef(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:4
msgid "Fetch name of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:6
msgid "This function is the same as the CPP method OGRFieldDefn::GetNameRef()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:14
msgid "the name of the field definition."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:1
msgid "int OGR_Fld_GetPrecision(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:4 osgeo.ogr.FieldDefn.precision:5
msgid "Get the formatting precision for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:6 osgeo.ogr.FieldDefn.SetPrecision:6
#: osgeo.ogr.FieldDefn.precision:7
msgid "This should normally be zero for fields of types other than OFTReal."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:8 osgeo.ogr.FieldDefn.precision:9
msgid "This function is the same as the CPP method OGRFieldDefn::GetPrecision()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:14 osgeo.ogr.FieldDefn.precision:15
msgid "hDefn:  handle to the field definition to get precision from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:16 osgeo.ogr.FieldDefn.precision:17
msgid "the precision."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:1
msgid "OGRFieldSubType OGR_Fld_GetSubType(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:4
msgid "Fetch subtype of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:6
msgid "This function is the same as the CPP method OGRFieldDefn::GetSubType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:12
msgid "hDefn:  handle to the field definition to get subtype from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:14
msgid "field subtype."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:1
msgid "OGRFieldType OGR_Fld_GetType(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:4 osgeo.ogr.FieldDefn.type:5
msgid "Fetch type of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:6 osgeo.ogr.FieldDefn.type:7
msgid "This function is the same as the CPP method OGRFieldDefn::GetType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:11 osgeo.ogr.FieldDefn.type:12
msgid "hDefn:  handle to the field definition to get type from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:13 osgeo.ogr.FieldDefn.type:14
msgid "field type."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:1
msgid "int OGR_Fld_GetWidth(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:4 osgeo.ogr.FieldDefn.width:5
msgid "Get the formatting width for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:6 osgeo.ogr.FieldDefn.width:7
msgid "This function is the same as the CPP method OGRFieldDefn::GetWidth()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:11 osgeo.ogr.FieldDefn.width:12
msgid "hDefn:  handle to the field definition to get width from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:13 osgeo.ogr.FieldDefn.width:14
msgid "the width, zero means no specified width."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:1
msgid "int OGR_Fld_IsDefaultDriverSpecific(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:4
msgid "Returns whether the default value is driver specific."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:6
msgid ""
"Driver specific default values are those that are not NULL, a numeric "
"value, a literal value enclosed between single quote characters, "
"CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal value."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:11
msgid ""
"This function is the same as the C++ method "
"OGRFieldDefn::IsDefaultDriverSpecific()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:17
#: osgeo.ogr.FieldDefn.IsIgnored:11 osgeo.ogr.FieldDefn.IsNullable:18
#: osgeo.ogr.FieldDefn.IsUnique:13 osgeo.ogr.FieldDefn.SetIgnored:11
#: osgeo.ogr.FieldDefn.SetNullable:17 osgeo.ogr.FieldDefn.SetUnique:18
msgid "hDefn:  handle to the field definition"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:19
msgid "TRUE if the default value is driver specific."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsIgnored:1
msgid "int OGR_Fld_IsIgnored(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsIgnored:4
msgid "Return whether this field should be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsIgnored:6
msgid "This method is the same as the C++ method OGRFieldDefn::IsIgnored()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:1
msgid "int OGR_Fld_IsNullable(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:4
msgid "Return whether this field can receive null values."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:6
msgid "By default, fields are nullable."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:8
msgid ""
"Even if this method returns FALSE (i.e not-nullable field), it doesn't "
"mean that OGRFeature::IsFieldSet() will necessary return TRUE, as fields "
"can be temporary unset and null /not-null validation is usually done when"
" OGRLayer::CreateFeature()/SetFeature() is called."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:13
msgid "This method is the same as the C++ method OGRFieldDefn::IsNullable()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:20
msgid "TRUE if the field is authorized to be null."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:1
msgid "int OGR_Fld_IsUnique(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:4
msgid "Return whether this field has a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:6
msgid "By default, fields have no unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:8
msgid "This method is the same as the C++ method OGRFieldDefn::IsUnique()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:15
msgid "TRUE if the field has a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:1
msgid ""
"void OGR_Fld_SetAlternativeName(OGRFieldDefnH hDefn, const char "
"*pszAlternativeName)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:5
msgid "Reset the alternative name (or \"alias\") for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:15
msgid ""
"This function is the same as the CPP method "
"OGRFieldDefn::SetAlternativeName()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:21
msgid ""
"hDefn:  handle to the field definition to apply the new alternative name "
"to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:24
msgid "pszAlternativeName:  the new alternative name to apply."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:1
msgid "void OGR_Fld_SetDefault(OGRFieldDefnH hDefn, const char *pszDefault)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:4
msgid "Set default field value."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:6
msgid ""
"The default field value is taken into account by drivers (generally those"
" with a SQL interface) that support it at field creation time. OGR will "
"generally not automatically set the default field value to null fields by"
" itself when calling OGRFeature::CreateFeature() / "
"OGRFeature::SetFeature(), but will let the low-level layers to do the "
"job. So retrieving the feature from the layer is recommended."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:13
msgid ""
"The accepted values are NULL, a numeric value, a literal value enclosed "
"between single quote characters (and inner single quote characters "
"escaped by repetition of the single quote character), CURRENT_TIMESTAMP, "
"CURRENT_TIME, CURRENT_DATE or a driver specific expression (that might be"
" ignored by other drivers). For a datetime literal value, format should "
"be 'YYYY/MM/DD HH:MM:SS[.sss]' (considered as UTC time)."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:21
msgid ""
"Drivers that support writing DEFAULT clauses will advertise the "
"GDAL_DCAP_DEFAULT_FIELDS driver metadata item."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:24
msgid "This function is the same as the C++ method OGRFieldDefn::SetDefault()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:32
msgid "pszDefault:  new default field value or NULL pointer."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:1
msgid "void OGR_Fld_SetIgnored(OGRFieldDefnH hDefn, int ignore)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:4
msgid "Set whether this field should be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:6
msgid "This method is the same as the C++ method OGRFieldDefn::SetIgnored()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:13
msgid "ignore:  ignore state"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:1
msgid "void OGR_Fld_SetJustify(OGRFieldDefnH hDefn, OGRJustification eJustify)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:4
msgid "Set the justification for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:8
msgid "This function is the same as the CPP method OGRFieldDefn::SetJustify()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:14
msgid "hDefn:  handle to the field definition to set justification to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:16
msgid "eJustify:  the new justification."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:1
msgid "void OGR_Fld_SetName(OGRFieldDefnH hDefn, const char *pszName)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:4
msgid "Reset the name of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:6
msgid "This function is the same as the CPP method OGRFieldDefn::SetName()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:11
msgid "hDefn:  handle to the field definition to apply the new name to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:13
msgid "pszName:  the new name to apply."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:1
msgid "void OGR_Fld_SetNullable(OGRFieldDefnH hDefn, int bNullableIn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:4
msgid "Set whether this field can receive null values."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:6
msgid ""
"By default, fields are nullable, so this method is generally called with "
"FALSE to set a not-null constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:9
msgid ""
"Drivers that support writing not-null constraint will advertise the "
"GDAL_DCAP_NOTNULL_FIELDS driver metadata item."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:12
msgid "This method is the same as the C++ method OGRFieldDefn::SetNullable()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:19
msgid "bNullableIn:  FALSE if the field must have a not-null constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:1
msgid "void OGR_Fld_SetPrecision(OGRFieldDefnH hDefn, int nPrecision)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:4
msgid "Set the formatting precision for this field in characters."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:8
msgid "This function is the same as the CPP method OGRFieldDefn::SetPrecision()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:14
msgid "hDefn:  handle to the field definition to set precision to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:16
msgid "nPrecision:  the new precision."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:1
msgid "void OGR_Fld_SetSubType(OGRFieldDefnH hDefn, OGRFieldSubType eSubType)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:4
msgid "Set the subtype of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:6 osgeo.ogr.FieldDefn.SetType:6
msgid ""
"This should never be done to an OGRFieldDefn that is already part of an "
"OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:9
msgid "This function is the same as the CPP method OGRFieldDefn::SetSubType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:15 osgeo.ogr.FieldDefn.SetType:14
msgid "hDefn:  handle to the field definition to set type to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:17
msgid "eSubType:  the new field subtype."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:1
msgid "void OGR_Fld_SetType(OGRFieldDefnH hDefn, OGRFieldType eType)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:4
msgid "Set the type of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:9
msgid "This function is the same as the CPP method OGRFieldDefn::SetType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:16
msgid "eType:  the new field type."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:1
msgid "void OGR_Fld_SetUnique(OGRFieldDefnH hDefn, int bUniqueIn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:4
msgid "Set whether this field has a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:6
msgid ""
"By default, fields have no unique constraint, so this method is generally"
" called with TRUE to set a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:9
msgid ""
"Drivers that support writing unique constraint will advertise the "
"GDAL_DCAP_UNIQUE_FIELDS driver metadata item. field can receive null "
"values."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:13
msgid "This method is the same as the C++ method OGRFieldDefn::SetUnique()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:20
msgid "bUniqueIn:  TRUE if the field must have a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:1
msgid "void OGR_Fld_SetWidth(OGRFieldDefnH hDefn, int nNewWidth)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:4
msgid "Set the formatting width for this field in characters."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:6
msgid "This function is the same as the CPP method OGRFieldDefn::SetWidth()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:11
msgid "hDefn:  handle to the field definition to set width to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:13
msgid "nNewWidth:  the new width."
msgstr ""

#: of osgeo.ogr.FieldDefn.justify:1
msgid ""
"GetJustify(FieldDefn self) -> OGRJustification OGRJustification "
"OGR_Fld_GetJustify(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.name:1
msgid "GetName(FieldDefn self) -> char const *"
msgstr ""

#: of osgeo.ogr.FieldDefn.precision:1
msgid ""
"GetPrecision(FieldDefn self) -> int int "
"OGR_Fld_GetPrecision(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.type:1
msgid ""
"GetType(FieldDefn self) -> OGRFieldType OGRFieldType "
"OGR_Fld_GetType(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.width:1
msgid "GetWidth(FieldDefn self) -> int int OGR_Fld_GetWidth(OGRFieldDefnH hDefn)"
msgstr ""

#: ../../source/api/python/vector_api.rst:113
msgid "GeomFieldDefn"
msgstr ""

#: of osgeo.ogr.GeomFieldDefn:1
msgid "Proxy of C++ OGRGeomFieldDefnShadow class."
msgstr ""

#: of osgeo.ogr.GeomFieldDefn.name:1
msgid "GetName(GeomFieldDefn self) -> char const *"
msgstr ""

#: of osgeo.ogr.GeomFieldDefn.srs:1
msgid "GetSpatialRef(GeomFieldDefn self) -> SpatialReference"
msgstr ""

#: of osgeo.ogr.GeomFieldDefn.type:1
msgid "GetType(GeomFieldDefn self) -> OGRwkbGeometryType"
msgstr ""

#: ../../source/api/python/vector_api.rst:121
msgid "FieldDomain"
msgstr ""

#: of osgeo.ogr.FieldDomain:1
msgid "Proxy of C++ OGRFieldDomainShadow class."
msgstr ""

#: ../../source/api/python/vector_api.rst:135
msgid "Relationship"
msgstr ""

#: ../../source/api/python/vector_api.rst:143
msgid "StyleTable"
msgstr ""

#: of osgeo.ogr.StyleTable:1
msgid "Proxy of C++ OGRStyleTableShadow class."
msgstr ""

#: ../../source/api/python_bindings.rst:5
msgid "General information"
msgstr ""

#: ../../source/api/python_bindings.rst:7
msgid ""
"This Python package and extensions are a number of tools for programming "
"and manipulating the GDAL_ Geospatial Data Abstraction Library."
msgstr ""

#: ../../source/api/python_bindings.rst:9
msgid ""
"The GDAL project maintains SWIG generated Python bindings for GDAL/OGR. "
"Generally speaking the classes and methods mostly match those of the GDAL"
" and OGR C++ classes. There is no Python specific reference "
"documentation, but the :ref:`tutorials <tutorials>` includes Python "
"examples."
msgstr ""

#: ../../source/api/python_bindings.rst:15
msgid "Dependencies"
msgstr ""

#: ../../source/api/python_bindings.rst:17
msgid "libgdal and header files (gdal-devel)"
msgstr ""

#: ../../source/api/python_bindings.rst:18
msgid ""
"numpy (1.0.0 or greater) and header files (numpy-devel) (not explicitly "
"required, but many examples and utilities will not work without it)"
msgstr ""

#: ../../source/api/python_bindings.rst:25
msgid "Conda"
msgstr ""

#: ../../source/api/python_bindings.rst:27
msgid ""
"GDAL can be quite complex to build and install, particularly on Windows "
"and MacOS. Pre built binaries are provided for the conda system:"
msgstr ""

#: ../../source/api/python_bindings.rst:30
msgid "https://docs.conda.io/en/latest/"
msgstr ""

#: ../../source/api/python_bindings.rst:32
msgid "By the conda-forge project:"
msgstr ""

#: ../../source/api/python_bindings.rst:34
msgid "https://conda-forge.org/"
msgstr ""

#: ../../source/api/python_bindings.rst:36
msgid ""
"Once you have Anaconda or Miniconda installed, you should be able to "
"install GDAL with:"
msgstr ""

#: ../../source/api/python_bindings.rst:38
msgid "``conda install -c conda-forge gdal``"
msgstr ""

#: ../../source/api/python_bindings.rst:41
msgid "Unix"
msgstr ""

#: ../../source/api/python_bindings.rst:43
msgid "The GDAL Python bindings requires setuptools."
msgstr ""

#: ../../source/api/python_bindings.rst:46
msgid "pip"
msgstr ""

#: ../../source/api/python_bindings.rst:48
msgid ""
"GDAL can be installed from the `Python Package Index "
"<https://pypi.org/project/GDAL>`__:"
msgstr ""

#: ../../source/api/python_bindings.rst:55
msgid ""
"In order to enable numpy-based raster support, libgdal and its "
"development headers must be installed as well as the Python packages "
"numpy, setuptools, and wheel. To install the Python dependencies and "
"build numpy-based raster support:"
msgstr ""

#: ../../source/api/python_bindings.rst:65
msgid "Users can verify that numpy-based raster support has been installed with:"
msgstr ""

#: ../../source/api/python_bindings.rst:72
msgid ""
"If this command raises an ImportError, numpy-based raster support has not"
" been properly installed:"
msgstr ""

#: ../../source/api/python_bindings.rst:83
msgid ""
"This is most often due to pip reusing a cached GDAL installation. Verify "
"that the necessary dependencies have been installed and then run the "
"following to force a clean build:"
msgstr ""

#: ../../source/api/python_bindings.rst:88
msgid "::"
msgstr ""

#: ../../source/api/python_bindings.rst:87
msgid ""
"pip install --no-cache --force-reinstall gdal[numpy]==\"$(gdal-config "
"--version).*\""
msgstr ""

#: ../../source/api/python_bindings.rst:91
msgid "Potential issues with GDAL >= 3.9, Python >= 3.9 and NumPy 2.0"
msgstr ""

#: ../../source/api/python_bindings.rst:93
msgid ""
"The pyproject.toml file of GDAL 3.9 requires numpy >= 2.0.0rc1 (for "
"Python >= 3.9) at build time to be able to build bindings that are "
"compatible of both NumPy 1 and NumPy 2. If for some reason the numpy >= "
"2.0.0rc1 build dependency can not be installed, it is possible to "
"manually install the build requirements, and invoke ``pip install`` with "
"the ``--no-build-isolation`` flag."
msgstr ""

#: ../../source/api/python_bindings.rst:107
msgid "Building as part of the GDAL library source tree"
msgstr ""

#: ../../source/api/python_bindings.rst:109
msgid ""
"Python bindings are generated by default when building GDAL from source. "
"For more detail, see :ref:`building-python-bindings`."
msgstr ""

#: ../../source/api/python_bindings.rst:112
msgid ""
"The GDAL Python package is built using `SWIG <https://www.swig.org>`__. "
"The currently supported version is SWIG >= 4"
msgstr ""

#: ../../source/api/python_bindings.rst:119
msgid "Imports"
msgstr ""

#: ../../source/api/python_bindings.rst:121
msgid ""
"There are five major modules that are included with the GDAL_ Python "
"bindings.:"
msgstr ""

#: ../../source/api/python_bindings.rst:134
msgid "API documentation is available at :ref:`python_osgeo`"
msgstr ""

#: ../../source/api/python_bindings.rst:137
msgid "Numpy"
msgstr ""

#: ../../source/api/python_bindings.rst:139
msgid ""
"One advanced feature of the GDAL Python bindings not found in the other "
"language bindings is integration with the Python numerical array "
"facilities. The gdal.Dataset.ReadAsArray() method can be used to read "
"raster data as numerical arrays, ready to use with the Python numerical "
"array capabilities."
msgstr ""

#: ../../source/api/python_bindings.rst:146
msgid "Tutorials"
msgstr ""

#: ../../source/api/python_bindings.rst:148
msgid ""
"Chris Garrard has given courses at Utah State University on "
"\"Geoprocessing with Python using Open Source GIS\" "
"(`http://www.gis.usu.edu/~chrisg/python "
"<http://www.gis.usu.edu/~chrisg/python>`__). There a re many slides, "
"examples, test data... and homework ;-) that can -be greatly helpful for "
"beginners with GDAL/OGR in Python."
msgstr ""

#: ../../source/api/python_bindings.rst:152
msgid ""
"A cookbook full of recipes for using the Python GDAL/OGR bindings : "
"`http://pcjericks.github.io/py-gdalogr-cookbook/index.html "
"<http://pcjericks.github.io/py-gdalogr-cookbook/index.html>`__"
msgstr ""

#: ../../source/api/python_bindings.rst:155
msgid "Gotchas"
msgstr ""

#: ../../source/api/python_bindings.rst:157
msgid ""
"Although GDAL's and OGR's Python bindings provide a fairly \"Pythonic\" "
"wrapper around the underlying C++ code, there are several ways in which "
"the Python bindings differ from typical Python libraries. These "
"differences can catch Python programmers by surprise and lead to "
"unexpected results. These differences result from the complexity of "
"developing a large, long-lived library while continuing to maintain "
"backward compatibility. They are being addressed over time, but until "
"they are all gone, please review this list of :ref:`python_gotchas`."
msgstr ""

#: ../../source/api/python_bindings.rst:162
msgid "Examples"
msgstr ""

#: ../../source/api/python_bindings.rst:164
msgid ""
"An assortment of other samples are available in the `Python github "
"samples directory <https://github.com/OSGeo/gdal/tree/master/swig/python"
"/gdal-utils/osgeo_utils/samples>`__ with some description in the "
":ref:`python_samples`."
msgstr ""

#: ../../source/api/python_bindings.rst:166
msgid ""
"Several `GDAL utilities "
"<https://github.com/OSGeo/gdal/tree/master/swig/python/gdal-"
"utils/osgeo_utils/>`__ are implemented in Python and can be useful "
"examples."
msgstr ""

#: ../../source/api/python_bindings.rst:168
msgid ""
"The majority of GDAL regression tests are written in Python. They are "
"available at `https://github.com/OSGeo/gdal/tree/master/autotest "
"<https://github.com/OSGeo/gdal/tree/master/autotest>`__"
msgstr ""

#: ../../source/api/python_bindings.rst:170
msgid ""
"Some examples of GDAL/numpy integration can be found is found in the "
"following scripts:"
msgstr ""

#: ../../source/api/python_bindings.rst:172
msgid "`gdal_calc.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:173
msgid "`val_repl.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:174
msgid "`gdal_merge.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:175
msgid "`gdal2tiles.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:176
msgid "`gdal2xyz.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:177
msgid "`pct2rgb.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:178
msgid "`gdallocationinfo.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:180
msgid ""
"One example of GDAL/numpy integration is found in the `val_repl.py "
"<https://github.com/OSGeo/gdal/tree/master/swig/python/gdal-"
"utils/osgeo_utils/samples/val_repl.py>`__ script."
msgstr ""

#: ../../source/api/python_bindings.rst:183
msgid "**Performance Notes**"
msgstr ""

#: ../../source/api/python_bindings.rst:185
msgid ""
"ReadAsArray expects to make an entire copy of a raster band or dataset "
"unless the data are explicitly subsetted as part of the function call. "
"For large data, this approach is expected to be prohibitively memory "
"intensive."
msgstr ""

#: ../../source/api/python_gotchas.rst:5
msgid "Python Gotchas in the GDAL and OGR Python Bindings"
msgstr ""

#: ../../source/api/python_gotchas.rst:7
msgid ""
"This page lists aspects of GDAL's and OGR's Python bindings that may "
"catch Python programmers by surprise. If you find something new, feel "
"free to open a pull request adding it to the list. Consider discussing it"
" on the `gdal-dev mailing list <https://lists.osgeo.org/mailman/listinfo"
"/gdal-dev>`__  first, to make sure you fully understand the issue and "
"that others agree that it is unexpected, \"non-Pythonic\", or something "
"that would catch many Python programmers by surprise. Be sure to "
"reference email threads, GitHub tickets, and other sources of additional "
"information."
msgstr ""

#: ../../source/api/python_gotchas.rst:13
msgid ""
"This list is not the place to report bugs. If you believe something is a "
"bug, please `open a ticket <https://github.com/OSGeo/gdal/issues>`__ and "
"report the problem to gdal-dev. Then consider listing it here if it is "
"something related to Python specifically. Do not list it here if it "
"relates to GDAL or OGR generally, and not the Python bindings "
"specifically."
msgstr ""

#: ../../source/api/python_gotchas.rst:16
msgid ""
"Not all items listed here are bugs. Some of these are just how GDAL and "
"OGR work and cannot be fixed easily without breaking existing code. If "
"you don't like how something works and think it should be changed, feel "
"free to discuss it on gdal-dev and see what can be done."
msgstr ""

#: ../../source/api/python_gotchas.rst:21
msgid "Gotchas that are by design... or per history"
msgstr ""

#: ../../source/api/python_gotchas.rst:23
msgid ""
"These are unexpected behaviors that are not considered by the GDAL and "
"OGR teams to be bugs and are unlikely to be changed due to effort "
"required, or whose fixing might affect backward compatibility, etc."
msgstr ""

#: ../../source/api/python_gotchas.rst:27
msgid ""
"Python bindings do not raise exceptions unless you explicitly call "
"``UseExceptions()``"
msgstr ""

#: ../../source/api/python_gotchas.rst:29
msgid ""
"By default, the GDAL and OGR Python bindings do not raise exceptions when"
" errors occur. Instead they return an error value such as ``None`` and "
"write an error message to ``sys.stdout``. For example, when you try to "
"open a non-existing dataset with GDAL:"
msgstr ""

#: ../../source/api/python_gotchas.rst:41
msgid ""
"In Python, it is traditional to report errors by raising exceptions. You "
"can enable this behavior in GDAL and OGR by calling the "
"``UseExceptions()`` function:"
msgstr ""

#: ../../source/api/python_gotchas.rst:58
msgid ""
"It is planned that exceptions will be enabled by default in GDAL 4.0. "
"Code that does not want exceptions to be raised in a future version of "
"GDAL should explicitly disable them with ``gdal.DontUseExceptions()``."
msgstr ""

#: ../../source/api/python_gotchas.rst:62
msgid ""
"Python crashes or throws an exception if you use an object after deleting"
" a related object"
msgstr ""

#: ../../source/api/python_gotchas.rst:64
msgid "Consider this example:"
msgstr ""

#: ../../source/api/python_gotchas.rst:74
msgid ""
"In this example, ``band`` has a relationship with ``dataset`` that "
"requires ``dataset`` to remain allocated in order for ``band`` to work. "
"If we delete ``dataset`` and then try to use ``band``, Python will throw "
"a confusing exception:"
msgstr ""

#: ../../source/api/python_gotchas.rst:88
msgid ""
"In GDAL 3.7 and earlier, using a band after the dataset has been "
"destroyed will cause a crash instead of an exception."
msgstr ""

#: ../../source/api/python_gotchas.rst:90
msgid ""
"This problem can manifest itself in subtle ways. For example, it can "
"occur if you try to instantiate a temporary dataset instance within a "
"single line of code:"
msgstr ""

#: ../../source/api/python_gotchas.rst:98
msgid ""
"In this example, the dataset instance was no longer needed after the call"
" to ``GetRasterBand()`` so Python deallocated it *before* calling "
"``Checksum()``."
msgstr ""

#: ../../source/api/python_gotchas.rst:112
msgid ""
"This example is the same case as above but it looks different. The "
"dataset object is only available in the ``load_band`` function and will "
"be deleted right after leaving the function."
msgstr ""

#: ../../source/api/python_gotchas.rst:116
msgid ""
"The problem is not restricted to GDAL band and dataset objects and "
"happens in other areas where objects have relationships with each other. "
"The issue occurs because deleting an object in Python causes not only the"
" C++ object behind it to be deallocated, but also other objects for which"
" that C++ object maintains ownership (e.g., a Dataset owning a Band, a "
"Feature owning a Geometry.) If the Python object associated with one of "
"these child objects retains a reference to that object, Python will crash"
" when the object is accessed. In common cases such as the Band/Dataset "
"relationship above, the GDAL bindings invalidate references to objects "
"that no longer exist so that an exception is thrown instead of a crash, "
"but the work is not complete."
msgstr ""

#: ../../source/api/python_gotchas.rst:127
msgid ""
"Unfortunately there is no complete list of such relationships, so you "
"have to watch for it yourself."
msgstr ""

#: ../../source/api/python_gotchas.rst:130
msgid ""
"Python crashes if you add a new field to an OGR layer when features "
"deriving from this layer definition are still active"
msgstr ""

#: ../../source/api/python_gotchas.rst:132
msgid "For example:"
msgstr ""

#: ../../source/api/python_gotchas.rst:142
msgid ""
"For more information, please see `#3552 "
"<https://trac.osgeo.org/gdal/ticket/3552>`__."
msgstr ""

#: ../../source/api/python_gotchas.rst:145
msgid ""
"Layers with attribute filters (``SetAttributeFilter()``) will only return"
" filtered features when using ``GetNextFeature()``"
msgstr ""

#: ../../source/api/python_gotchas.rst:147
msgid ""
"If you read the documentation for ``SetAttributeFilter()`` carefully you "
"will see the caveat about ``OGR_L_GetNextFeature()``. This means that if "
"you use ``GetFeature()``, instead of ``GetNextFeature()``, then you can "
"still access and work with features from the layer that are not covered "
"by the filter. ``GetFeatureCount()`` will respect the filter and show the"
" correct number of features filtered. However, working with "
"``GetFeatureCount()`` in a loop can lead to some subtle confusion. "
"Iterating over the Layer object or using ``GetNextFeature()`` should be "
"the default method for accessing features:"
msgstr ""

#: ../../source/api/python_gotchas.rst:162
msgid ""
"Certain objects contain a ``Destroy()`` method, but you should never use "
"it"
msgstr ""

#: ../../source/api/python_gotchas.rst:164
msgid ""
"You may come across examples that call the ``Destroy()`` method. `This "
"tutorial "
"<https://www.gis.usu.edu/~chrisg/python/2009/lectures/ospy_slides2.pdf>`__"
" even gives specific advice on page 12 about when to call ``Destroy``."
msgstr ""

#: ../../source/api/python_gotchas.rst:166
msgid ""
"Calling ``Destroy`` forces the underlying native object to be destroyed."
"  This is typically unnecessary because these objects are automatically "
"destroyed during garbage collection when no references to the Python "
"object remain."
msgstr ""

#: ../../source/api/python_gotchas.rst:170
msgid ""
"In most situations, it is not necessary to force the object to be "
"destroyed at a specific point in time. However, because the contents of "
"``gdal.Dataset`` and ``ogr.DataSource`` objects are only guaranteed to be"
" written to disk when the backing native object is destroyed, it may be "
"necessary to explicitly destroy these objects. In these cases, a context "
"manager (``with`` block) is often a good solution, e.g.:"
msgstr ""

#: ../../source/api/python_gotchas.rst:187
msgid ""
"If this is not possible, for example if the object needs to be destroyed "
"within a function, then the ``Close()`` method may be called."
msgstr ""

#: ../../source/api/python_gotchas.rst:192
msgid ""
"Context managers and the ``Close()`` method are available beginning in "
"GDAL 3.8. In earlier versions, ``Destroy()`` can be used for "
"``ogr.DataSource`` objects, or garbage collection may be forced by "
"destroying reference using ``del`` or setting variables to ``None``."
msgstr ""

#: ../../source/api/python_gotchas.rst:197
msgid ""
"With some drivers, raster datasets can be intermittently saved without "
"closing using ``FlushCache()``. Similarly, vector datasets can be saved "
"using ``SyncToDisk()``.  However, neither of these methods guarantee that"
" the data are written to disk, so the preferred method is to use a "
"context manager or call ``Close()``."
msgstr ""

#: ../../source/api/python_gotchas.rst:205
msgid "Exceptions raised in custom error handlers do not get caught"
msgstr ""

#: ../../source/api/python_gotchas.rst:207
msgid ""
"The python bindings allow you to specify a python callable as an error "
"handler (`#4993 <https://trac.osgeo.org/gdal/ticket/4993>`__). However, "
"these error handlers appear to be called in a separate thread and any "
"exceptions raised do not propagate back to the main thread (`#5186 "
"<https://trac.osgeo.org/gdal/ticket/5186>`__)."
msgstr ""

#: ../../source/api/python_gotchas.rst:210
msgid ""
"So if you want to  `catch warnings as well as errors "
"<https://gis.stackexchange.com/questions/43404/how-to-detect-a-gdal-ogr-"
"warning/68042>`__, something like this won't work:"
msgstr ""

#: ../../source/api/python_gotchas.rst:228
msgid "But you can do something like this instead:"
msgstr ""

#: ../../source/api/python_gotchas.rst:283
msgid "Gotchas that result from bugs or behaviors of other software"
msgstr ""

#: ../../source/api/python_gotchas.rst:286
msgid "Python crashes in GDAL functions when you upgrade or downgrade numpy"
msgstr ""

#: ../../source/api/python_gotchas.rst:288
msgid ""
"Much of GDAL's Python bindings are implemented in C++. Much of the core "
"of numpy is implemented in C. The C++ part of GDAL's Python bindings "
"interacts with the C part of numpy through numpy's ABI (application "
"binary interface). This requires GDAL's Python bindings to be compiled "
"using numpy header files that define numpy C data structures. Those data "
"structures sometimes change between numpy versions. When this happens, "
"the new version of numpy is not be compatible at the binary level with "
"the old version, and the GDAL Python bindings must be recompiled before "
"they will work with the new version of numpy. And when they are "
"recompiled, they probably won't work with the old version."
msgstr ""

#: ../../source/api/python_gotchas.rst:292
msgid ""
"If you obtained a precompiled version of GDAL's Python bindings, such as "
"the Windows packages from `http://gisinternals.com/sdk.php "
"<http://gisinternals.com/sdk.php>`__ be sure you look up what version of "
"numpy was used to compile them, and install that version of numpy on your"
" machine."
msgstr ""

#: ../../source/api/python_gotchas.rst:295
msgid ""
"Python bindings cannot be used successfully from ArcGIS in-process "
"geoprocessing tools (ArcGIS 9.3 and later)"
msgstr ""

#: ../../source/api/python_gotchas.rst:297
msgid ""
"ArcGIS allows the creation of custom, Python-based geoprocessing tools. "
"Until ArcGIS 10, there was no easy way to read raster data into memory. "
"GDAL provides such a mechanism."
msgstr ""

#: ../../source/api/python_gotchas.rst:299
msgid ""
"Starting with ArcGIS 9.3, geoprocessing tools can either run in the "
"ArcGIS process itself (ArcCatalog.exe or ArcMap.exe) or run in a separate"
" python.exe worker process. Unfortunately ArcGIS contains a bug in how it"
" runs in-process tools. Thus, if you use GDAL from an in-process tool, it"
" will run fine the first time but after that it may fail with "
"``TypeError`` exceptions until you restart the ArcGIS process. For "
"example, band.ReadAsArray() fails with:"
msgstr ""

#: ../../source/api/python_gotchas.rst:301
msgid ""
"``TypeError: in method 'BandRasterIONumpy', argument 1 of type "
"'GDALRasterBandShadow *``'"
msgstr ""

#: ../../source/api/python_gotchas.rst:303
msgid ""
"This is a bug in ArcGIS. Please see `#3672 "
"<https://trac.osgeo.org/gdal/ticket/3672>`__ for complete details and "
"advice on workarounds."
msgstr ""

#: ../../source/api/python_samples.rst:5
msgid "Python Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:7
msgid ""
"The following are sample scripts intended to give an idea how to use the "
"GDAL's Python interface. Please feel free to use them in your "
"applications."
msgstr ""

#: ../../source/api/python_samples.rst:10
msgid ""
"From GDAL 3.2, Python utility scripts :ref:`programs` are located inside "
"the `osgeo_utils` module. From GDAL 3.3, Python sample scripts are "
"located inside the `osgeo_utils.samples` sub-module."
msgstr ""

#: ../../source/api/python_samples.rst:14
msgid "Python Raster Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:18
msgid ""
"assemblepoly: Script demonstrates how to assemble polygons from arcs. "
"Demonstrates various aspects of OGR Python API."
msgstr ""

#: ../../source/api/python_samples.rst:19
msgid ""
"fft: Script to perform forward and inverse two-dimensional fast Fourier "
"transform."
msgstr ""

#: ../../source/api/python_samples.rst:20
msgid ""
"gdal2grd: Script to write out ASCII GRD rasters (used in Golden Software "
"Surfer). from any source supported by GDAL."
msgstr ""

#: ../../source/api/python_samples.rst:21
msgid "gdal_vrtmerge: Similar to gdal_merge, but produces a VRT file."
msgstr ""

#: ../../source/api/python_samples.rst:22
msgid ""
"gdalcopyproj: Duplicate the geotransform, projection and/or GCPs from one"
" raster dataset to another, which can be useful after performing image "
"manipulations with other software that ignores or discards georeferencing"
" metadata."
msgstr ""

#: ../../source/api/python_samples.rst:24
msgid ""
"gdalfilter:  Example script for applying kernel based filters to an image"
" using GDAL. Demonstrates use of virtual files as an intermediate "
"representation."
msgstr ""

#: ../../source/api/python_samples.rst:26
msgid ""
"get_soundg: Script to copy the SOUNDG layer from an S-57 file to a "
"Shapefile, splitting up features with MULTIPOINT geometries into many "
"POINT features, and appending the point elevations as an attribute."
msgstr ""

#: ../../source/api/python_samples.rst:29
msgid "histrep: Module to extract data from many rasters into one output."
msgstr ""

#: ../../source/api/python_samples.rst:30
msgid ""
"load2odbc: Load ODBC table to an ODBC datastore. Uses direct SQL since "
"the ODBC driver is read-only for OGR."
msgstr ""

#: ../../source/api/python_samples.rst:31
msgid ""
"rel: Script to produce a shaded relief image from the elevation data. "
"(similar functionality in gdaldem now)"
msgstr ""

#: ../../source/api/python_samples.rst:32
msgid ""
"tigerpoly:  Script demonstrating how to assemble polygons from arcs in "
"TIGER/Line datasource, writing results to a newly created shapefile."
msgstr ""

#: ../../source/api/python_samples.rst:34
msgid ""
"tolatlong: Script to read coordinate system and geotransformation matrix "
"from input file and report latitude/longitude coordinates for the "
"specified pixel."
msgstr ""

#: ../../source/api/python_samples.rst:36
msgid ""
"val_repl: Script to replace specified values from the input raster file "
"with the new ones. May be useful in cases when you don't like value, used"
" for NoData indication and want replace it with other value. Input file "
"remains unchanged, results stored in other file."
msgstr ""

#: ../../source/api/python_samples.rst:39
msgid ""
"vec_tr: Example of applying some algorithm to all the geometries in the "
"file, such as a fixed offset."
msgstr ""

#: ../../source/api/python_samples.rst:40
msgid ""
"vec_tr_spat: Example of using Intersect() to filter based on only those "
"features that truly intersect a given rectangle. Easily extended to "
"general polygon!"
msgstr ""

#: ../../source/api/python_samples.rst:42
msgid ""
"classify: Demonstrates using numpy for simple range based classification "
"of an image. This is only an example that has stuff hardcoded."
msgstr ""

#: ../../source/api/python_samples.rst:44
msgid ""
"gdal_lut: Read a LUT from a text file, and apply it to an image. Sort of "
"a '1 band' version of pct2rgb."
msgstr ""

#: ../../source/api/python_samples.rst:46
msgid ""
"magphase: Example script computing magnitude and phase images from a "
"complex image."
msgstr ""

#: ../../source/api/python_samples.rst:47
msgid "hsv_merge: Merge greyscale image into RGB image as intensity in HSV space."
msgstr ""

#: ../../source/api/python_samples.rst:48
msgid ""
"gdal_ls: Display the list of files in a virtual directory, like /vsicurl "
"or /vsizip"
msgstr ""

#: ../../source/api/python_samples.rst:49
msgid "gdal_cp: Copy a virtual file"
msgstr ""

#: ../../source/api/python_samples.rst:52
msgid "Python Vector Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:56
msgid ""
"ogrupdate: Update a target datasource with the features of a source "
"datasource. Contrary to ogr2ogr, this script tries to match features "
"between the datasources, to decide whether to create a new feature, or to"
" update an existing one."
msgstr ""

#: ../../source/api/python_samples.rst:59
msgid "ogr_layer_algebra: Application for executing OGR layer algebra operations."
msgstr ""

#: ../../source/api/python_samples.rst:60
msgid ""
"ogr_dispatch: Dispatch features into layers according to the value of "
"some fields or the geometry type."
msgstr ""

#: ../../source/api/python_samples.rst:61
msgid ""
"wcs_virtds_params: Generates MapServer WCS layer definition from a "
"tileindex with mixed SRS"
msgstr ""

#: ../../source/api/python_samples.rst:62
msgid ""
"ogr_build_junction_table: Create junction tables for layers coming from "
"GML datasources that reference other objects in _href fields"
msgstr ""

#: ../../source/api/python_samples.rst:64
msgid "gcps2ogr: Outputs GDAL GCPs as OGR points"
msgstr ""

#: ../../source/api/python_samples.rst:68
msgid "Python Coordinate Reference System Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:72
msgid ""
"crs2crs2grid: A script to produce PROJ.4 grid shift files from HTDP "
"program."
msgstr ""

#: ../../source/api/python_samples.rst:75
msgid "Python direct ports of c++ programs"
msgstr ""

#: ../../source/api/python_samples.rst:79
msgid ":ref:`gdalinfo`: A direct port of apps/gdalinfo.c"
msgstr ""

#: ../../source/api/python_samples.rst:80
msgid ":ref:`ogrinfo`: A direct port of apps/ogrinfo.cpp"
msgstr ""

#: ../../source/api/python_samples.rst:81
msgid ":ref:`gdallocationinfo`: A direct port of apps/gdallocationinfo.cpp"
msgstr ""

#: ../../source/api/python_samples.rst:84
msgid "Python sample scripts that are now programs"
msgstr ""

#: ../../source/api/python_samples.rst:86
msgid ""
"Sample scripts might be upgraded to proper gdal utilities (programs) in "
"next versions with added functionality and documentation. The following "
"samples from previous versions are now programs."
msgstr ""

#: ../../source/api/python_samples.rst:92
msgid ":ref:`gdal2xyz`: Translates a raster file into xyz format."
msgstr ""

#: ../../source/api/python_samples.rst:93
msgid ""
":ref:`gdal_retile`: Script for restructuring data in a tree of regular "
"tiles."
msgstr ""

#: ../../source/api/python_samples.rst:94
msgid "val_at_coord: see :ref:`gdallocationinfo`"
msgstr ""

#: ../../source/api/raster_c_api.rst:5
msgid "gdal.h: Raster C API"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pszFuncName"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param papszFunctionArgs"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nInBands"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param eInDT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param padfInNoData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pnOutBands"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param peOutDT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param ppadfOutNoData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pszVRTPath"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param ppWorkingData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pWorkingData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nBufXSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nBufYSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pInBuffer"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nInBufferSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pOutBuffer"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nOutBufferSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param eOutDT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nOutBands"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param padfOutNoData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcXOff"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcYOff"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcXSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcYSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param adfSrcGT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param papszExtra"
msgstr ""

#: ../../source/api/vector_c_api.rst:5
msgid "ogr_core.h and ogr_api.h: Vector C API"
msgstr ""

