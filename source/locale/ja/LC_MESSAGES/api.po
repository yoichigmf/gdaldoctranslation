# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-29 04:11+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/api/cpl.rst:10
msgid "Common Portability Library C API"
msgstr ""

#: ../../source/api/cpl.rst:13
msgid "cpl_conv.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/gnm_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/ogrspatialref.rst
#: ../../source/api/raster_c_api.rst ../../source/api/vector_c_api.rst
msgid "Defines"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/gnm_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/raster_c_api.rst ../../source/api/vector_c_api.rst
msgid "Typedefs"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/ogr_srs_api.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst
msgid "Functions"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdalattribute_cpp.rst ../../source/api/gdaldataset_cpp.rst
#: ../../source/api/gdaldimension_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalextendeddatatype_cpp.rst
#: ../../source/api/gdalgroup_cpp.rst ../../source/api/gdalmdarray_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogr_srs_api.rst
#: ../../source/api/ogrfeature_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst of osgeo.gdal.BuildVRT
#: osgeo.gdal.BuildVRTOptions osgeo.gdal.DEMProcessing
#: osgeo.gdal.DEMProcessingOptions osgeo.gdal.Grid osgeo.gdal.GridOptions
#: osgeo.gdal.Info osgeo.gdal.MultiDimInfo osgeo.gdal.MultiDimTranslate
#: osgeo.gdal.MultiDimTranslateOptions osgeo.gdal.Nearblack
#: osgeo.gdal.NearblackOptions osgeo.gdal.Rasterize osgeo.gdal.RasterizeOptions
#: osgeo.gdal.Translate osgeo.gdal.TranslateOptions osgeo.gdal.VectorTranslate
#: osgeo.gdal.VectorTranslateOptions osgeo.gdal.Warp osgeo.gdal.WarpOptions
#: osgeo.ogr.DataSource.CopyLayer osgeo.ogr.DataSource.CreateLayer
#: osgeo.ogr.DataSource.DeleteLayer osgeo.ogr.DataSource.ExecuteSQL
#: osgeo.ogr.DataSource.GetDriver osgeo.ogr.DataSource.GetLayerByName
#: osgeo.ogr.DataSource.GetLayerCount osgeo.ogr.DataSource.GetName
#: osgeo.ogr.DataSource.ReleaseResultSet osgeo.ogr.DataSource.TestCapability
#: osgeo.ogr.Feature.Clone osgeo.ogr.Feature.DumpReadable
#: osgeo.ogr.Feature.Equal osgeo.ogr.Feature.FillUnsetWithDefault
#: osgeo.ogr.Feature.GetDefnRef osgeo.ogr.Feature.GetFID
#: osgeo.ogr.Feature.GetFieldAsBinary osgeo.ogr.Feature.GetFieldAsDateTime
#: osgeo.ogr.Feature.GetFieldAsDouble osgeo.ogr.Feature.GetFieldAsDoubleList
#: osgeo.ogr.Feature.GetFieldAsInteger osgeo.ogr.Feature.GetFieldAsInteger64
#: osgeo.ogr.Feature.GetFieldAsInteger64List
#: osgeo.ogr.Feature.GetFieldAsIntegerList osgeo.ogr.Feature.GetFieldAsString
#: osgeo.ogr.Feature.GetFieldAsStringList osgeo.ogr.Feature.GetFieldCount
#: osgeo.ogr.Feature.GetFieldDefnRef osgeo.ogr.Feature.GetFieldIndex
#: osgeo.ogr.Feature.GetGeomFieldCount osgeo.ogr.Feature.GetGeomFieldDefnRef
#: osgeo.ogr.Feature.GetGeomFieldIndex osgeo.ogr.Feature.GetGeomFieldRef
#: osgeo.ogr.Feature.GetNativeData osgeo.ogr.Feature.GetNativeMediaType
#: osgeo.ogr.Feature.GetStyleString osgeo.ogr.Feature.IsFieldNull
#: osgeo.ogr.Feature.IsFieldSet osgeo.ogr.Feature.IsFieldSetAndNotNull
#: osgeo.ogr.Feature.SetFID osgeo.ogr.Feature.SetFieldDoubleList
#: osgeo.ogr.Feature.SetFieldInteger64 osgeo.ogr.Feature.SetFieldInteger64List
#: osgeo.ogr.Feature.SetFieldIntegerList osgeo.ogr.Feature.SetFieldNull
#: osgeo.ogr.Feature.SetFieldString osgeo.ogr.Feature.SetFieldStringList
#: osgeo.ogr.Feature.SetFrom osgeo.ogr.Feature.SetFromWithMap
#: osgeo.ogr.Feature.SetGeomField osgeo.ogr.Feature.SetGeomFieldDirectly
#: osgeo.ogr.Feature.SetGeometry osgeo.ogr.Feature.SetGeometryDirectly
#: osgeo.ogr.Feature.SetNativeData osgeo.ogr.Feature.SetNativeMediaType
#: osgeo.ogr.Feature.SetStyleString osgeo.ogr.Feature.UnsetField
#: osgeo.ogr.Feature.Validate osgeo.ogr.FeatureDefn.AddFieldDefn
#: osgeo.ogr.FeatureDefn.AddGeomFieldDefn
#: osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn
#: osgeo.ogr.FeatureDefn.GetFieldCount osgeo.ogr.FeatureDefn.GetFieldDefn
#: osgeo.ogr.FeatureDefn.GetFieldIndex osgeo.ogr.FeatureDefn.GetGeomFieldCount
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn
#: osgeo.ogr.FeatureDefn.GetGeomFieldIndex osgeo.ogr.FeatureDefn.GetGeomType
#: osgeo.ogr.FeatureDefn.GetName osgeo.ogr.FeatureDefn.GetReferenceCount
#: osgeo.ogr.FeatureDefn.IsGeometryIgnored osgeo.ogr.FeatureDefn.IsSame
#: osgeo.ogr.FeatureDefn.IsStyleIgnored osgeo.ogr.FeatureDefn.SetGeomType
#: osgeo.ogr.FeatureDefn.SetGeometryIgnored
#: osgeo.ogr.FeatureDefn.SetStyleIgnored
#: osgeo.ogr.FieldDefn.GetAlternativeNameRef osgeo.ogr.FieldDefn.GetDefault
#: osgeo.ogr.FieldDefn.GetDomainName osgeo.ogr.FieldDefn.GetJustify
#: osgeo.ogr.FieldDefn.GetNameRef osgeo.ogr.FieldDefn.GetPrecision
#: osgeo.ogr.FieldDefn.GetSubType osgeo.ogr.FieldDefn.GetType
#: osgeo.ogr.FieldDefn.GetWidth osgeo.ogr.FieldDefn.IsDefaultDriverSpecific
#: osgeo.ogr.FieldDefn.IsIgnored osgeo.ogr.FieldDefn.IsNullable
#: osgeo.ogr.FieldDefn.IsUnique osgeo.ogr.FieldDefn.SetAlternativeName
#: osgeo.ogr.FieldDefn.SetDefault osgeo.ogr.FieldDefn.SetDomainName
#: osgeo.ogr.FieldDefn.SetIgnored osgeo.ogr.FieldDefn.SetJustify
#: osgeo.ogr.FieldDefn.SetName osgeo.ogr.FieldDefn.SetNullable
#: osgeo.ogr.FieldDefn.SetPrecision osgeo.ogr.FieldDefn.SetSubType
#: osgeo.ogr.FieldDefn.SetType osgeo.ogr.FieldDefn.SetUnique
#: osgeo.ogr.FieldDefn.SetWidth osgeo.ogr.FieldDefn.justify
#: osgeo.ogr.FieldDefn.precision osgeo.ogr.FieldDefn.type
#: osgeo.ogr.FieldDefn.width osgeo.ogr.Geometry.AssignSpatialReference
#: osgeo.ogr.Geometry.Buffer osgeo.ogr.Geometry.Contains
#: osgeo.ogr.Geometry.Crosses osgeo.ogr.Geometry.DelaunayTriangulation
#: osgeo.ogr.Geometry.Difference osgeo.ogr.Geometry.Disjoint
#: osgeo.ogr.Geometry.Distance osgeo.ogr.Geometry.Distance3D
#: osgeo.ogr.Geometry.Equals osgeo.ogr.Geometry.ExportToIsoWkb
#: osgeo.ogr.Geometry.ExportToWkb osgeo.ogr.Geometry.Intersection
#: osgeo.ogr.Geometry.Intersects osgeo.ogr.Geometry.MakeValid
#: osgeo.ogr.Geometry.Overlaps osgeo.ogr.Geometry.Segmentize
#: osgeo.ogr.Geometry.Set3D osgeo.ogr.Geometry.SetCoordinateDimension
#: osgeo.ogr.Geometry.SetMeasured osgeo.ogr.Geometry.Simplify
#: osgeo.ogr.Geometry.SimplifyPreserveTopology osgeo.ogr.Geometry.SymDifference
#: osgeo.ogr.Geometry.Touches osgeo.ogr.Geometry.Transform
#: osgeo.ogr.Geometry.TransformTo osgeo.ogr.Geometry.Union
#: osgeo.ogr.Geometry.Within osgeo.ogr.Layer.AlterFieldDefn
#: osgeo.ogr.Layer.Clip osgeo.ogr.Layer.CreateFeature
#: osgeo.ogr.Layer.CreateField osgeo.ogr.Layer.CreateGeomField
#: osgeo.ogr.Layer.DeleteFeature osgeo.ogr.Layer.DeleteField
#: osgeo.ogr.Layer.Erase osgeo.ogr.Layer.GetExtent osgeo.ogr.Layer.GetFeature
#: osgeo.ogr.Layer.GetFeatureCount osgeo.ogr.Layer.GetGeometryTypes
#: osgeo.ogr.Layer.Identity osgeo.ogr.Layer.Intersection
#: osgeo.ogr.Layer.ReorderField osgeo.ogr.Layer.ReorderFields
#: osgeo.ogr.Layer.SetAttributeFilter osgeo.ogr.Layer.SetFeature
#: osgeo.ogr.Layer.SetIgnoredFields osgeo.ogr.Layer.SetNextByIndex
#: osgeo.ogr.Layer.SetSpatialFilter osgeo.ogr.Layer.SetSpatialFilterRect
#: osgeo.ogr.Layer.SymDifference osgeo.ogr.Layer.TestCapability
#: osgeo.ogr.Layer.Union osgeo.ogr.Layer.Update osgeo.ogr.Layer.UpsertFeature
msgid "Parameters"
msgstr "パラメータ"

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdal_alg.rst ../../source/api/gdal_utils.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdalattribute_cpp.rst ../../source/api/gdaldataset_cpp.rst
#: ../../source/api/gdaldimension_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalgroup_cpp.rst ../../source/api/gdalmdarray_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogr_srs_api.rst
#: ../../source/api/ogrfeature_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst of osgeo.ogr.DataSource.CopyLayer
#: osgeo.ogr.DataSource.CreateLayer osgeo.ogr.DataSource.DeleteLayer
#: osgeo.ogr.DataSource.ExecuteSQL osgeo.ogr.DataSource.GetDriver
#: osgeo.ogr.DataSource.GetLayerByName osgeo.ogr.DataSource.GetLayerCount
#: osgeo.ogr.DataSource.GetName osgeo.ogr.DataSource.TestCapability
#: osgeo.ogr.Feature.Clone osgeo.ogr.Feature.Equal osgeo.ogr.Feature.GetDefnRef
#: osgeo.ogr.Feature.GetFID osgeo.ogr.Feature.GetFieldAsBinary
#: osgeo.ogr.Feature.GetFieldAsDateTime osgeo.ogr.Feature.GetFieldAsDouble
#: osgeo.ogr.Feature.GetFieldAsDoubleList osgeo.ogr.Feature.GetFieldAsInteger
#: osgeo.ogr.Feature.GetFieldAsInteger64
#: osgeo.ogr.Feature.GetFieldAsInteger64List
#: osgeo.ogr.Feature.GetFieldAsIntegerList osgeo.ogr.Feature.GetFieldAsString
#: osgeo.ogr.Feature.GetFieldAsStringList osgeo.ogr.Feature.GetFieldCount
#: osgeo.ogr.Feature.GetFieldDefnRef osgeo.ogr.Feature.GetFieldIndex
#: osgeo.ogr.Feature.GetGeomFieldCount osgeo.ogr.Feature.GetGeomFieldDefnRef
#: osgeo.ogr.Feature.GetGeomFieldIndex osgeo.ogr.Feature.GetGeometryRef
#: osgeo.ogr.Feature.GetNativeData osgeo.ogr.Feature.GetNativeMediaType
#: osgeo.ogr.Feature.GetStyleString osgeo.ogr.Feature.IsFieldNull
#: osgeo.ogr.Feature.IsFieldSet osgeo.ogr.Feature.IsFieldSetAndNotNull
#: osgeo.ogr.Feature.SetFID osgeo.ogr.Feature.SetFrom
#: osgeo.ogr.Feature.SetFromWithMap osgeo.ogr.Feature.SetGeomField
#: osgeo.ogr.Feature.SetGeomFieldDirectly osgeo.ogr.Feature.SetGeometry
#: osgeo.ogr.Feature.SetGeometryDirectly osgeo.ogr.Feature.Validate
#: osgeo.ogr.Feature.geometry osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn
#: osgeo.ogr.FeatureDefn.GetFieldCount osgeo.ogr.FeatureDefn.GetFieldDefn
#: osgeo.ogr.FeatureDefn.GetFieldIndex osgeo.ogr.FeatureDefn.GetGeomFieldCount
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn
#: osgeo.ogr.FeatureDefn.GetGeomFieldIndex osgeo.ogr.FeatureDefn.GetGeomType
#: osgeo.ogr.FeatureDefn.GetName osgeo.ogr.FeatureDefn.GetReferenceCount
#: osgeo.ogr.FeatureDefn.IsGeometryIgnored osgeo.ogr.FeatureDefn.IsSame
#: osgeo.ogr.FeatureDefn.IsStyleIgnored
#: osgeo.ogr.FieldDefn.GetAlternativeNameRef osgeo.ogr.FieldDefn.GetDefault
#: osgeo.ogr.FieldDefn.GetDomainName osgeo.ogr.FieldDefn.GetJustify
#: osgeo.ogr.FieldDefn.GetNameRef osgeo.ogr.FieldDefn.GetPrecision
#: osgeo.ogr.FieldDefn.GetSubType osgeo.ogr.FieldDefn.GetType
#: osgeo.ogr.FieldDefn.GetWidth osgeo.ogr.FieldDefn.IsDefaultDriverSpecific
#: osgeo.ogr.FieldDefn.IsIgnored osgeo.ogr.FieldDefn.IsNullable
#: osgeo.ogr.FieldDefn.IsUnique osgeo.ogr.FieldDefn.justify
#: osgeo.ogr.FieldDefn.precision osgeo.ogr.FieldDefn.type
#: osgeo.ogr.FieldDefn.width osgeo.ogr.Geometry.Boundary
#: osgeo.ogr.Geometry.Buffer osgeo.ogr.Geometry.Clone
#: osgeo.ogr.Geometry.Contains osgeo.ogr.Geometry.ConvexHull
#: osgeo.ogr.Geometry.CoordinateDimension osgeo.ogr.Geometry.Crosses
#: osgeo.ogr.Geometry.DelaunayTriangulation osgeo.ogr.Geometry.Difference
#: osgeo.ogr.Geometry.Disjoint osgeo.ogr.Geometry.Distance
#: osgeo.ogr.Geometry.Distance3D osgeo.ogr.Geometry.Equals
#: osgeo.ogr.Geometry.GetCoordinateDimension osgeo.ogr.Geometry.GetDimension
#: osgeo.ogr.Geometry.GetEnvelope osgeo.ogr.Geometry.GetEnvelope3D
#: osgeo.ogr.Geometry.GetGeometryType osgeo.ogr.Geometry.Intersection
#: osgeo.ogr.Geometry.Intersects osgeo.ogr.Geometry.Is3D
#: osgeo.ogr.Geometry.IsEmpty osgeo.ogr.Geometry.IsMeasured
#: osgeo.ogr.Geometry.IsRing osgeo.ogr.Geometry.IsSimple
#: osgeo.ogr.Geometry.IsValid osgeo.ogr.Geometry.MakeValid
#: osgeo.ogr.Geometry.Normalize osgeo.ogr.Geometry.Overlaps
#: osgeo.ogr.Geometry.PointOnSurface osgeo.ogr.Geometry.Polygonize
#: osgeo.ogr.Geometry.Simplify osgeo.ogr.Geometry.SimplifyPreserveTopology
#: osgeo.ogr.Geometry.SymDifference osgeo.ogr.Geometry.Touches
#: osgeo.ogr.Geometry.Transform osgeo.ogr.Geometry.TransformTo
#: osgeo.ogr.Geometry.Union osgeo.ogr.Geometry.UnionCascaded
#: osgeo.ogr.Geometry.Within osgeo.ogr.Layer.AlterFieldDefn
#: osgeo.ogr.Layer.Clip osgeo.ogr.Layer.CommitTransaction
#: osgeo.ogr.Layer.CreateFeature osgeo.ogr.Layer.CreateField
#: osgeo.ogr.Layer.CreateGeomField osgeo.ogr.Layer.DeleteFeature
#: osgeo.ogr.Layer.DeleteField osgeo.ogr.Layer.Erase
#: osgeo.ogr.Layer.FindFieldIndex osgeo.ogr.Layer.GetExtent
#: osgeo.ogr.Layer.GetFIDColumn osgeo.ogr.Layer.GetFeature
#: osgeo.ogr.Layer.GetFeatureCount osgeo.ogr.Layer.GetGeomType
#: osgeo.ogr.Layer.GetGeometryColumn osgeo.ogr.Layer.GetGeometryTypes
#: osgeo.ogr.Layer.GetLayerDefn osgeo.ogr.Layer.GetName
#: osgeo.ogr.Layer.GetNextFeature osgeo.ogr.Layer.GetSpatialFilter
#: osgeo.ogr.Layer.GetSpatialRef osgeo.ogr.Layer.Identity
#: osgeo.ogr.Layer.Intersection osgeo.ogr.Layer.ReorderField
#: osgeo.ogr.Layer.ReorderFields osgeo.ogr.Layer.RollbackTransaction
#: osgeo.ogr.Layer.SetAttributeFilter osgeo.ogr.Layer.SetFeature
#: osgeo.ogr.Layer.SetIgnoredFields osgeo.ogr.Layer.SetNextByIndex
#: osgeo.ogr.Layer.StartTransaction osgeo.ogr.Layer.SymDifference
#: osgeo.ogr.Layer.SyncToDisk osgeo.ogr.Layer.TestCapability
#: osgeo.ogr.Layer.Union osgeo.ogr.Layer.Update osgeo.ogr.Layer.UpsertFeature
msgid "Returns"
msgstr "返り値"

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdaldataset_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/raster_c_api.rst
#: ../../source/api/vector_c_api.rst
msgid "Public Members"
msgstr "公開メンバ"

#: ../../source/api/cpl.rst:19
msgid "cpl_csv.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/gnm_cpp.rst
#: ../../source/api/ogr_srs_api.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/raster_c_api.rst ../../source/api/vector_c_api.rst
msgid "Enums"
msgstr ""

#: ../../source/api/cpl.rst:25
msgid "cpl_compressor.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param input_data"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param input_size"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param output_data"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param output_size"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param options"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param compressor_user_data"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdal_alg.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/raster_c_api.rst
msgid "Return"
msgstr ""

#: ../../source/api/cpl.rst:31
msgid "cpl_error.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdalattribute_cpp.rst ../../source/api/gdaldataset_cpp.rst
#: ../../source/api/gdaldimension_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalextendeddatatype_cpp.rst
#: ../../source/api/gdalgroup_cpp.rst ../../source/api/gdalmdarray_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogrfeature_cpp.rst
#: ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst ../../source/api/vector_c_api.rst
msgid "Public Functions"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdalwarp_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Private Members"
msgstr ""

#: ../../source/api/cpl.rst:37
msgid "cpl_http.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pszURL"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param papszOptions"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pfnProgress"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pProgressArg"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pfnWrite"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pWriteArg"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/raster_c_api.rst
msgid "Param pUserData"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdalabstractmdarray_cpp.rst
#: ../../source/api/gdaldataset_cpp.rst ../../source/api/ogrgeometry_cpp.rst
#: ../../source/api/ogrlayer_cpp.rst
msgid "Public Types"
msgstr ""

#: ../../source/api/cpl.rst:43
msgid "cpl_minixml.h"
msgstr ""

#: ../../source/api/cpl.rst:49
msgid "cpl_multiproc.h"
msgstr ""

#: ../../source/api/cpl.rst:55
msgid "cpl_port.h"
msgstr ""

#: ../../source/api/cpl.rst:61
msgid "cpl_progress.h"
msgstr ""

#: ../../source/api/cpl.rst:67
msgid "cpl_string.h"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/cpl_cpp.rst
#: ../../source/api/gdaldataset_cpp.rst ../../source/api/gdaldriver_cpp.rst
#: ../../source/api/gdalextendeddatatype_cpp.rst
#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/ogrfeature_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrgeometry_cpp.rst ../../source/api/ogrlayer_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Public Static Functions"
msgstr ""

#: ../../source/api/cpl.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst ../../source/api/ogrfeaturestyle_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Private Functions"
msgstr ""

#: ../../source/api/cpl.rst:73
msgid "cpl_time.h"
msgstr ""

#: ../../source/api/cpl.rst:79
msgid "cpl_virtualmem.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param ctxt"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nOffset"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pPageToFill"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nToFill"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pPageToBeEvicted"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nToBeEvicted"
msgstr ""

#: ../../source/api/cpl.rst:85
msgid "cpl_vsi_error.h"
msgstr ""

#: ../../source/api/cpl.rst:91
msgid "cpl_vsi.h"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param pFile"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param nRanges"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param panOffsets"
msgstr ""

#: ../../source/api/cpl.rst
msgid "Param panSizes"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsisubfile/ virtual file handler."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsisubfile/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsicurl/ HTTP/FTP file system handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsicurl/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 1.8.0"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsicurl_streaming/ HTTP/FTP file system handler (requires "
"libcurl)."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsicurl_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 1.10"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsis3/ Amazon S3 file system handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsis3/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.1"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsis3_streaming/ Amazon S3 file system handler (requires "
"libcurl)."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsis3_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsigs/ Google Cloud Storage file system handler (requires "
"libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsigs/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.2"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsigs_streaming/ Google Cloud Storage file system handler "
"(requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsigs_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz/ Microsoft Azure Blob file system handler (requires "
"libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiaz/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.3"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz_streaming/ Microsoft Azure Blob file system handler "
"(requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiaz_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz/ Microsoft Azure Data Lake Storage Gen2 file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiadls/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 3.3"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsioss/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiaz_streaming/ Alibaba Cloud Object Storage Service (OSS) "
"(requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsioss_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiswift/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiswift_streaming/ OpenStack Swif Object Storage (Swift) file "
"system handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiswift_streaming/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsi7z/ 7zip file system handler (requires libarchive)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsi7z/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 3.7"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsirar/ RAR file system handler (requires libarchive)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsirar/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install GZip file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading on-the-fly and "
"writing in GZip (.gz) files."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"All portions of the file system underneath the base path \"/vsigzip/\" "
"will be handled by this driver."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsigzip/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 1.6.0"
msgstr ""

#: ../../<breathe>:-1
msgid "Install ZIP file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading on-the-fly in ZIP"
" (.zip) archives."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"All portions of the file system underneath the base path \"/vsizip/\" "
"will be handled by this driver."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsizip/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsistdin/ file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading from the standard"
" input stream."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"The file operations available are of course limited to Read() and forward"
" Seek() (full seek in the first MB of a file by default)."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Starting with GDAL 3.6, this limit can be configured either by setting "
"the CPL_VSISTDIN_BUFFER_LIMIT configuration option to a number of bytes "
"(can be -1 for unlimited), or using the \"/vsistdin?buffer_limit=value\" "
"filename."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsistdin/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid ""
"Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system "
"handler (requires libcurl)"
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsiwebhdfs/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 2.4"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsistdout/ file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows writing to the standard "
"output stream."
msgstr ""

#: ../../<breathe>:-1
msgid "The file operations available are of course limited to Write()."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A variation of this file system exists as the /vsistdout_redirect/ file "
"system handler, where the output function can be defined with "
"VSIStdoutSetRedirection()."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsistdout/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsisparse/ virtual file handler."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsisparse/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsitar/ file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"A special file handler is installed that allows reading on-the-fly in TAR"
" (regular .tar, or compressed .tar.gz/.tgz) archives."
msgstr ""

#: ../../<breathe>:-1
msgid ""
"All portions of the file system underneath the base path \"/vsitar/\" "
"will be handled by this driver."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsitar/ documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Install /vsicached? file system handler."
msgstr ""

#: ../../<breathe>:-1
msgid "See /vsicached? documentation"
msgstr ""

#: ../../<breathe>:-1
msgid "Since  GDAL 3.8.0"
msgstr ""

#: ../../source/api/cpl.rst:98
msgid ":ref:`cpl_cpp_api`."
msgstr ""

#: ../../source/api/cpl_cpp.rst:10
msgid "Common Portability Library C++ API"
msgstr ""

#: ../../source/api/cpl_cpp.rst:13
msgid "cpl_odbc.h"
msgstr ""

#: ../../source/api/cpl_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/ogrspatialref.rst
msgid "Private Static Functions"
msgstr ""

#: ../../source/api/cpl_cpp.rst:19
msgid "cpl_vsi_virtual.h"
msgstr ""

#: ../../source/api/cpl_cpp.rst
msgid "Variables"
msgstr ""

#: ../../source/api/cpl_cpp.rst:26
msgid ":ref:`cpl_api`."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:5
msgid "Compiling the C# bindings - CMake Scripts"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:7
msgid ""
"This page describes the primary steps when creating the GDAL/OGR C# "
"binaries from the source using the new CMake scripts."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:9
#: ../../source/api/csharp/csharp_compile_legacy.rst:9
msgid ""
"In most cases this is not necessary and it is better to use one of the "
"pre-compiled sources, such as `GisInternals "
"<https://gisinternals.com/>`__ or Conda."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:11
msgid ""
"You can either build the bindings as part of a full GDAL build - or "
"standalone on top of an existing installation."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:14
#: ../../source/api/csharp/csharp_compile_legacy.rst:18
#: ../../source/api/csharp/csharp_compile_legacy.rst:105
msgid "Requirements"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:16
#: ../../source/api/csharp/csharp_compile_legacy.rst:20
#: ../../source/api/csharp/csharp_compile_legacy.rst:107
msgid "The build environment has the following dependencies:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:18
msgid "CMake 3.10 or later"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:19
msgid "the appropriate C++ build environment (i.e. gcc or Visual Studio etc)."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:20
msgid "SWIG 4"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:21
msgid ".NET 5.0 or Mono"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:24
msgid ".NET Build Toolchain"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:26
msgid ""
"The build scripts can use either .NET 5.0 and  :file:`dotnet.exe` or Mono"
" and :file:`msc.exe` to compile the bindings."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:28
msgid ""
".NET is used for preference if it found on all platforms but the use of "
"Mono can be forced using a command line variable."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:31
msgid "Building as part of a GDAL Build"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:33
msgid "The build environment uses the following variables:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:36
msgid "CSHARP_MONO"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:36
#: ../../source/api/csharp/csharp_compile_cmake.rst:42
#: ../../source/api/csharp/csharp_compile_cmake.rst:44
msgid "Boolean"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:36
msgid "Forces the use of Mono"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:38
msgid "CSHARP_LIBRARY_VERSION"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:38
#: ../../source/api/csharp/csharp_compile_cmake.rst:40
msgid "String"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:38
msgid "Set the .NET version for the shared libraries"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:40
msgid "CSHARP_APPLICATION_VERSION"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:40
msgid "Set the .NET version for the sample apps"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:42
msgid "GDAL_CSHARP_ONLY"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:42
msgid "Build standalone on GDAL binaries"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:44
msgid "BUILD_CSHARP_BINDINGS"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:44
msgid "Build the C# bindings DEFAULT ON"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:48
msgid "Building with .NET"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:50
msgid ""
"If the build environment has .NET 5.0 installed and GDAL is built, then "
"the c# bindings will be built using .NET by default."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:52
msgid ""
"The details of building GDAL are documented elsewhere, but there are "
"likely to be variants of the following commands run from the root "
"directory of the gdal repository:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:60
#: ../../source/api/csharp/csharp_compile_cmake.rst:115
msgid ""
"The C# bindings and sample apps are installed in the install directory "
"(in the above case that would be `../install`, in the `share/csharp` sub "
"folder. There would be the following files:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:62
#: ../../source/api/csharp/csharp_compile_cmake.rst:117
#: ../../source/api/csharp/csharp_compile_legacy.rst:66
msgid ":file:`gdal_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:63
#: ../../source/api/csharp/csharp_compile_cmake.rst:118
#: ../../source/api/csharp/csharp_compile_legacy.rst:67
msgid ":file:`ogr_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:64
#: ../../source/api/csharp/csharp_compile_cmake.rst:119
#: ../../source/api/csharp/csharp_compile_legacy.rst:68
msgid ":file:`osr_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:65
#: ../../source/api/csharp/csharp_compile_cmake.rst:120
#: ../../source/api/csharp/csharp_compile_legacy.rst:69
msgid ":file:`gdalconst_csharp.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:66
#: ../../source/api/csharp/csharp_compile_cmake.rst:121
msgid ""
":file:`gdal_wrap.dll` or :file:`libgdal_wrap.so` or "
":file:`libgdal_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:67
#: ../../source/api/csharp/csharp_compile_cmake.rst:122
msgid ""
":file:`ogr_wrap.dll` or :file:`libogr_wrap.so` or "
":file:`libogr_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:68
#: ../../source/api/csharp/csharp_compile_cmake.rst:69
#: ../../source/api/csharp/csharp_compile_cmake.rst:123
#: ../../source/api/csharp/csharp_compile_cmake.rst:124
msgid ""
":file:`osr_wrap.dll` or :file:`libosr_wrap.so` or "
":file:`libosr_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:70
#: ../../source/api/csharp/csharp_compile_cmake.rst:125
msgid ""
":file:`gdalconst_wrap.dll` or :file:`libgdalconst_wrap.so` or "
":file:`libgdalconst_wrap.dylib`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:71
msgid ""
"various sample applications - as \\*.exe on Windows, or just as \\* on "
"Unix, along with \\*.dll for each app and the runtime config files."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:73
msgid ""
"There are also subdirectories for each of the sample apps, holding the "
"config files."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:75
msgid "There are also the following NuGET packages:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:77
msgid ":file:`OSGeo.GDAL`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:78
msgid ":file:`OSGeo.OGR`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:79
msgid ":file:`OSgeo.OSR`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:80
msgid ":file:`OSGeo.GDAL.CONST`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:81
msgid "various sample application"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:84
msgid "Using the .NET Bindings"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:86
msgid ""
"The easiest way to use the bindings in development would be use the NuGET"
" packages created."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:88
msgid ""
"To do this you need to add a local repistory pointing to the GDAL install"
" directory. `This is explained here <https://docs.microsoft.com/en-"
"us/nuget/hosting-packages/local-feeds>`__ ."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:90
msgid "Once this is done, you add the GDAL packages into your project as normal."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:92
msgid ""
"These packages only install the bindings and do not install core GDAL. It"
" is for you as the developer to make sure that the GDAL binaries are "
"available in the search path."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:95
msgid ""
"The NuGET packages are created with the same version number as the "
"version of GDAL in the build system. If you are building in a GIT "
"repository, then the build system automatically makes the version with a "
"x.y.z-dev pre-release tag. This means that to load the package into "
"Visual Studio (for instance), you have to tick the pre-release box. This "
"is all intentional and not a bug."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:102
msgid "Building on Mono"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:104
msgid ""
"If the build environment does not have .NET 5.0 or msbuild installed and "
"GDAL is built, then the c# bindings will be built using Mono by default. "
"Mono building can also be forced by setting CSHARP_MONO."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:107
msgid ""
"The details of building GDAL are documented elsewhere, but the there are "
"likely to be variants of the following commands run from the root "
"directory of the gdal repository:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:126
msgid "various sample applications as \\*.exe on all platforms."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:129
msgid "Using the Mono Bindings"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:131
msgid "Note that the bindings created by this process will only work with Mono."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:133
#: ../../source/api/csharp/csharp_compile_legacy.rst:177
msgid ""
"To run one of the prebuilt executables - you can run them with Mono as "
"follows :"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:135
#: ../../source/api/csharp/csharp_compile_legacy.rst:179
msgid ":program:`mono GDALInfo.exe`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:137
#: ../../source/api/csharp/csharp_compile_legacy.rst:181
msgid ""
"Both the managed libraries (i.e. the DLLs) and the unmanaged libraries "
"must be available to Mono. This is in more detail in `the Mono "
"documentation <https://www.mono-project.com/docs/advanced/pinvoke/>`__"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:141
msgid "Building Standalone"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:143
msgid ""
"The Bindings using both the .NET or Mono toolchains can be build on top "
"of an existing implementation of GDAL that includes the include files and"
" libs - for instance the Conda distribution."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:146
msgid ""
"To do this, Cmake must be run with the GDAL_CSHARP_ONLY flag set and only"
" one of the following targets should be built:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:150
msgid "csharp_binding"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:150
msgid "Just the bindings"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:152
msgid "csharp_samples"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:152
msgid "The bindings and the sample apps"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:155
msgid "Do not build the install target when running standalone, it will fail!"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:157
msgid ""
"Do not run a bare ctest command on this build, it will likely fail! Use "
"something like `ctest -R \"^csharp.*\"` instead."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:159
msgid "As an example:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:166
msgid ""
"The output from this build is axactly the same as documented as above, "
"except that the outputs will be in `../build/swig/csharp` and some of the"
" sub folders."
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:169
msgid "Signing of build artifacts"
msgstr ""

#: ../../source/api/csharp/csharp_compile_cmake.rst:171
msgid ""
"The CSharp assemblies are strong name signed by default with the provided"
" key file in :source_file:`swig/csharp/gdal.snk`. If authenticode signing"
" of the assemblies is wished, it should be done in a post-build manual "
"step, for example with:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:5
msgid "Compiling the C# bindings - Legacy Scripts"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:7
msgid ""
"This page describes the primary steps when creating the GDAL/OGR C# "
"binaries from the source."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:12
msgid "Building on Windows"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:14
msgid ""
"To building the C# interface, you need a compiled version of the GDAL "
"core. This can be the result of a manual compilation or can be linking to"
" one of the prebuilt binaries. In the former case the following should be"
" run in the clone of the GitHub repository used to build GDAL and the "
"steps to create the environment should not be necessary."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:22
msgid "nmake / Visual Studio"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:23
#: ../../source/api/csharp/csharp_compile_legacy.rst:110
msgid "SWIG 3/4"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:25
msgid ""
"The `GDAL test scripts "
"<https://github.com/OSGeo/gdal/blob/master/.github/workflows/windows_build.yml>`__"
" use VS 2019 (MSVC Ver 1920) so it would make sense to use the same "
"versions."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:27
msgid ""
"`SWIG <http://www.swig.org/>`__ is used to build the API bindings. The "
"GDAL test scripts use version 3 and the conda build use version 4. Both "
"Work."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:30
#: ../../source/api/csharp/csharp_compile_legacy.rst:114
msgid "Build Environment"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:32
msgid ""
"You need to set up the build environment. If you are using VS 2019, this "
"might be the command:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:34
msgid ":program:`VsDevCmd.bat -arch=x64`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:36
msgid ""
"The :program:`VsDevCmd.bat` command can usually be found in "
":file:`C:\\\\Program Files (x86)\\\\Microsoft Visual "
"Studio\\\\2019\\\\Enterprise\\\\Common7\\\\Tools` or the equivalent for "
"the Community Edition."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:38
msgid ""
"If you don't want to bother with executing the proper vcvars*.bat you "
"might use the development environment specific command prompt to "
"accomplish this task. When using a Win64 compilation be careful to "
"activate the x64 version of the command prompt installed on your system."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:40
msgid ""
"If you are not running in an environment that has been used to compile "
"GDAL locally, then there are a number of variables that need to be "
"configured. The Conda ``gdal-feedstock`` configuration app can be used as"
" a guideline about how to do that - `build.bat <https://github.com/conda-"
"forge/gdal-feedstock/blob/master/recipe/set_bld_opts.bat>`__."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:43
#: ../../source/api/csharp/csharp_compile_legacy.rst:121
msgid "Creating the SWIG interface code"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:45
msgid ""
"The first step is to generate the SWIG interface code. This will create a"
" set of ``.cs`` definitions that will be compiled into the ``.dll`` files"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:47
msgid ""
"To create the interface execute the following command (from the "
"``swig\\csharp`` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:53
msgid ""
"You should edit nmake.opt adding the actual location of the "
":file:`swig.exe` file."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:56
#: ../../source/api/csharp/csharp_compile_legacy.rst:134
msgid "Compiling the code"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:58
msgid ""
"After creating the interface the code can be compiled using this command "
"(from the ``swig\\csharp`` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:64
#: ../../source/api/csharp/csharp_compile_legacy.rst:142
msgid "Upon a successful compilation the following files are created:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:70
msgid ":file:`gdal_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:71
msgid ":file:`ogr_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:72
msgid ":file:`osr_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:73
msgid ":file:`gdalconst_wrap.dll`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:74
msgid "various sample applications"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:76
msgid ""
"The :file:`\\*_csharp.dll` binaries are the managed part of the "
"interface. You should add a reference to these assemblies for using the "
"classes of the interface. These :file:`\\*_csharp.dll` files will load "
"the corresponding :file:`\\*_wrap.dll` files, which are the unmanaged "
"part of the interface hosting the code of the gdal core."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:79
#: ../../source/api/csharp/csharp_compile_legacy.rst:160
msgid "Testing the successful compilation"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:81
#: ../../source/api/csharp/csharp_compile_legacy.rst:162
msgid "To test the compiled binaries, you can use:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:87
#: ../../source/api/csharp/csharp_compile_legacy.rst:168
msgid "This command will invoke some of the sample applications."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:89
msgid ""
"For the tests to work the location of the proj and gdal DLLs should be "
"available in the PATH."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:92
msgid "Using MONO on Windows"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:94
msgid ""
"If you have the Windows version of the MONO package installed you can "
"compile the C# code using the MONO compiler. In this case uncomment the "
"following entry in csharp.opt:"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:96
msgid ":program:`MONO = YES`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:98
msgid "mcs.exe must be in the PATH."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:102
msgid "Building on Linux/OSX"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:109
msgid "make"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:111
msgid "mono (probably any reasonable version)"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:116
msgid ""
"The build environment needs to be correctly configured. If you are not "
"running in an environment that has been used to locally build GDAL then "
"you should run the :program:`configure` command from the GDAL root "
"directory."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:118
msgid ""
"The conda gdal-feedstock recipe provides an example of how to do that - "
"`build.sh <https://github.com/conda-forge/gdal-"
"feedstock/blob/master/recipe/build.sh>`__"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:123
msgid ""
"The first step is to generate the SWIG interface code. This will create a"
" set of :file:`.cs` definitions that will be compiled into the "
":file:`.dll` files"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:125
msgid ""
"To create the interface execute the following command (from the "
":file:`swig/    csharp` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:131
msgid ""
"In versions of GDAL < 3.3.0 - this command will create incorrect "
"interfaces without the correct namespace. See `#3670 "
"<https://github.com/OSGeo/gdal/pull/3670/commits/777c9d0e86602740199cf9a4ab44e040c52c2283>`__."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:136
msgid ""
"After creating the interface the code can be compiled using this command "
"(from the :file:`swig/csharp` directory):"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:144
msgid ":file:`gdal_csharp.dll` and :file:`gdal_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:145
msgid ":file:`ogr_csharp.dll` and :file:`ogr_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:146
msgid ":file:`osr_csharp.dll` and :file:`osr_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:147
msgid ":file:`gdalconst_csharp.dll` and :file:`gdalconst_csharp.dll.config`"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:148
msgid ":file:`libgdalcsharp.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:149
msgid ":file:`libogrcsharp.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:150
msgid ":file:`libosrcsharp.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:151
msgid ":file:`libgdalconst_wrap.so / .dylib` etc"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:152
msgid "various sample applications (:file:`\\*.exe`)"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:154
msgid ""
"The :file:`\\*_csharp.dll` binaries are the managed part of the "
"interface. You should add a reference to these assemblies for using the "
"classes of the interface."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:156
msgid ""
"The :file:`\\*_csharp.dll` files will try to load the corresponding "
":file:`\\*_wrap.dll` and are redirected to the :file:`libxxxcsharp.\\*` "
"libraries, which are the unmanaged part of the interface hosting the code"
" of the gdal core, by the :file:`\\*.dll.config` definitions."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:170
msgid ""
"For the tests to work the location of the proj and gdal libraries should "
"be available in the PATH."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:173
msgid "Using The Bindings on Unix"
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:175
msgid ""
"Note that the bindings created by this process will only work with Mono "
"at the moment."
msgstr ""

#: ../../source/api/csharp/csharp_compile_legacy.rst:184
msgid ""
"This document was amended from the previous version at "
"`https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpCompile "
"<https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpCompile>`__"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:5
msgid "C# Bindings Conda Package"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:7
msgid "The GDAL C# Bindings Conda Package is a community supported project."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:10
#: ../../source/api/python_bindings.rst:22
msgid "Installation"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:12
msgid "GDAL with the C# bindings and example applications can be loaded using"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:19
#: ../../source/api/csharp/csharp_conda.rst:51
#: ../../source/api/python_bindings.rst:117
msgid "Usage"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:21
msgid ""
"The Conda package for GDAL version 3.5.0 and later uses the CMAKE build "
"scripts and therefore there have been changes in the build process and "
"the artifacts produced."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:23
msgid ":ref:`csharp_conda_35`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:25
msgid ":ref:`csharp_conda_34`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:32
msgid "GDAL 3.5.0 and later"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:34
msgid ""
"The Conda package for GDAL version 3.5.0 and later is built using the new"
" Cmake build scripts."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:37
msgid ".NET Target Framework"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:39
msgid ""
"On all architectures (i.e. Windows, Linux and Mac), the bindings are "
"compiled using .NET6.0 as the current (at the time of writing) LTS "
"version."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:42
msgid "Package Artifacts"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:44
msgid "The Conda package contains two sets of artifacts:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:46
msgid ""
"The SWIG wrapper Dynamic Shared Objects (DSO) - :file:`gdal_wrap.dll` or "
":file:`libgdal_wrap.so` or :file:`libgdal_wrap.dylib` etc. These are "
"loaded as one would expect for a Conda package (i.e. in the :file:`bin` "
"folder in Windows and the :file:`lib` folder in Unix) and thus will "
"automatically link to the correct version of the GDAL DSO and the "
"dependencies, and"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:48
msgid ""
"Local NuGet packages for the actual C# bindings (i.e. "
":file:`gdal_csharp.dll`, :file:`gdalconst_csharp.dll`, "
":file:`osr_csharp.dll` and :file:`ogr_csharp.dll`). These are created as "
"packages called :file:`OSGeo.GDAL`, :file:`OSGeo.OSR` and "
":file:`OSGeo.OGR`. These are loaded into the :file:`share/gdal` folder."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:53
msgid ""
"To use the bindings in your application, you will need to basically do "
"the following:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:55
msgid "Add the relevant Packages to you application as local packages, and"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:56
msgid "Add the DSOs to the search path for the application."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:58
msgid ""
"The former is not complicated and can be done by defining a local source,"
" either global (as `is explained here <https://docs.microsoft.com/en-"
"us/nuget/hosting-packages/local-feeds>`__ ) or in the build command as is"
" shown below."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:60
msgid ""
"The latter can be based on Conda for a console application, as is shown "
"below, but if you are working in an IDE (which being a .NET IDE knows "
"nothing about Conda) and/or working on a GUI application (which is not "
"going to be running in a Conda environment) you are going to have to sort"
" out the DSOs your self; probably involving copying the relevant DSOs "
"into the application package."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:63
msgid "Usage Example - Windows"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:65
msgid "The most simple example would be:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:67
#: ../../source/api/csharp/csharp_conda.rst:104
msgid "Create a new application (in a dedicated empty folder)"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:69
#: ../../source/api/csharp/csharp_conda.rst:106
msgid ":program:`dotnet new console`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:71
#: ../../source/api/csharp/csharp_conda.rst:108
msgid ""
"Create a small application (by replacing the contents of "
":file:`Program.cs`)."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:91
#: ../../source/api/csharp/csharp_conda.rst:128
msgid "Add the GDAL package"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:93
msgid ""
":program:`dotnet add package OSGeo.GDAL -s "
"%CONDA_PREFIX%\\\\Library\\\\share\\\\gdal`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:95
#: ../../source/api/csharp/csharp_conda.rst:132
msgid "Compile or run"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:97
#: ../../source/api/csharp/csharp_conda.rst:134
msgid ":program:`dotnet run`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:99
msgid ""
"Provided you run these commands in a Conda environment (containing the "
"gdal-csharp package) this should just work."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:102
msgid "Usage Example - Unix"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:130
msgid ":program:`dotnet add package OSGeo.GDAL -s $CONDA_PREFIX/share/gdal`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:136
msgid ""
"This will not just work under Unix since, unlike Windows, the Library "
"Search Path is separate from the Process Search path and is not set by "
"Conda."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:138
msgid ""
"To make this work, you will probably have to change the Library search "
"path, which is ok for development but should not be accepted for "
"production (which means that you will need to copy the DSOs to the "
"application search path)."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:140
msgid "Under Linux:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:142
msgid ":program:`export LD_LIBRARY_PATH=$CONDA_PREFIX/lib`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:144
msgid "Under OSX:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:146
msgid ":program:`export DYLD_LIBRARY_PATH=$CONDA_PREFIX/lib`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:153
msgid "GDAL 3.4.x and earlier"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:156
msgid "Windows"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:158
msgid ""
"You can test if the C# bindings are working in a Conda environment by "
"running :program:`%CONDA_PREFIX%\\\\Library\\\\bin\\\\gcs\\\\gdal_test`."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:160
msgid ""
"The DLLs are loaded into the :file:`%CONDA_PREFIX%\\\\Library\\\\bin` "
"folder, as is normal for a Conda environment."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:162
msgid ""
"The  C# sample .EXEs are loaded into  "
":file:`%CONDA_PREFIX%\\\\Library\\\\bin\\\\gcs`, because otherwise they "
"over write the standard GDAL tools."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:164
msgid ""
"To run a sample application - eg GDALinfo.exe - add "
":file:`%CONDA_PREFIX%\\\\Library\\\\bin\\\\gcs` to the path and just run "
":program:`gdalinfo`."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:166
msgid ""
"To link the DLLs into your code, you will need to include the DLLs into "
"the project (which will almost certainly mean copying them to the project"
" directory)."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:168
msgid ""
"For a console app that is run from within the Conda environment (i.e. run"
" :program:`conda activate`) then they should work once compiled."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:170
msgid ""
"For GUI apps or other apps that cannot be run from with the Conda "
"environment then you will have to setup the environment to make the GDAL "
"DLLs available to the app."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:174
msgid "Mac / Linux"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:176
msgid ""
"You test if the C# bindings are working in a Conda environment by running"
" :program:`mono $CONDA_PREFIX/lib/gdal_test.exe`"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:178
msgid ""
"The shared objects (i.e. :file:`\\*.so` / :file:`\\*.dylib`), the .EXE "
"and .DLL files are all loaded into the :file:`$CONDA_PREFIX/lib` folder "
"(not the :file:`bin` folder as you might expect). This is in line with "
"`the Mono documentation <https://www.mono-project.com/docs/getting-"
"started/application-deployment/>`__."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:181
msgid ""
"To run one of the sample applications (e.g. :file:`GDALinfo.exe`), run "
":program:`mono $CONDA_PREFIX/lib/GDALinfo.exe`."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:183
msgid ""
"To build a console app in Mono, you can do this in a conda environment "
"simple using a command similar to this (changing the source name to your "
"own):"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:189
msgid ""
"If the compiled executable is run in the conda environment, this should "
"work. For something more portable or a GUI app, then you have to work out"
" the dependencies your self."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:191
msgid ""
"The DLLs can also be used in a .NET project, for instance built in VS. "
"Just link the DLLs in as dependencies."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:194
msgid "Differences in the Conda build"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:196
msgid ""
"The Conda build is in some ways different from the \"standard\" GDAL "
"3.4.x build:"
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:198
msgid ""
"On Mac and Linux, the SWIG files are built as :file:`\\*_wrap` in line "
"with the windows versions. This means that there are no :file:`.config` "
"files. Most importantly, this means that the DLLs can be used in .NET and"
" Unity projects as well as Mono."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:199
msgid "On Windows, the sample apps are built in .NET5 and not .NET CORE 2.1."
msgstr ""

#: ../../source/api/csharp/csharp_conda.rst:201
msgid "These changes anticipated the standard build for GDAL 3.5.x."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:5
msgid "C# Raster Interface"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:7
msgid ""
"The GDAL C# interface supports transferring raster data between the C# "
"application and GDAL."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:9
msgid ""
"The various :file:`Band.ReadRaster`, :file:`Band.WriteRaster`, "
":file:`Dataset.ReadRaster`, :file:`Dataset.WriteRaster` overloads are "
"involved in transferring raster data between the managed and the "
"unmanaged parts of the application."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:12
msgid ""
"This page will summarize the main aspects of raster data handling related"
" exclusively to the C# interface."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:14
msgid ""
"The :file:`Band` class contains the following "
":file:`ReadRaster`/:file:`WriteRaster` overloads:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:54
msgid ""
"The only difference between these functions is the actual type of the "
"buffer parameter. The last 2 overloads are the generic overloads and the "
"caller should write the proper marshaling code for the buffer holding the"
" raster data. The overloads that have a C# array as the buffer parameter "
"implement the proper marshaling code for the caller."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:60
msgid "Reading the raster image"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:62
msgid ""
"When reading raster data from GDAL, the user will probably create a .NET "
"image to hold C# representation of the data. The raster data can be read "
"directly or in a buffered fashion."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:66
msgid "Using the buffered read approach"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:68
msgid ""
"When reading the image this way the C# API will copy the image data "
"between the C and the C# arrays:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:88
msgid ""
"In this case the interface implementation uses an internally created "
"unmanaged array to transfer the data between the C and C++ part of the "
"code, like:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:106
msgid "Using the direct read approach"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:108
msgid ""
"Raster data can be read into the C# bitmap directly using the following "
"approach:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:127
msgid ""
"This approach is more performant than the previous since there's no need "
"to allocate an intermediary array for transferring the data."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:130
msgid "Using /unsafe code and the fixed statement"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:132
msgid ""
"In the previous examples the programmer could ignore bothering with "
"implementing the marshaling code for the raster arrays. Both of the "
"examples prevent the garbage collector from relocating the array during "
"the execution of the P/Invoke call. Without using an intermediary array "
"the programmer can also use the following method to read the raster data:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:143
msgid ""
"When using this approach the application must be compiled using the "
":program:`/unsafe` command line option."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:146
msgid "Using indexed / grayscale images"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:148
msgid ""
"The :file:`PaletteInterp` enumeration can be used to distinguish between "
"the various type of the image color interpretations."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:159
msgid ""
"When reading images with indexed color representations, the programmer "
"might have to do some extra work copying the palette over:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:192
msgid ""
"When reading grayscale images, the programmer should create a sufficient "
"palette for the .NET image."
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:220
#: ../../source/api/csharp/csharp_vector.rst:212
msgid "Related C# examples"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:222
msgid ""
"The following examples demonstrate the usage of the GDAL raster "
"operations mentioned previously:"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:224
msgid ":source_file:`swig/csharp/apps/GDALRead.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:225
#: ../../source/api/csharp/csharp_raster.rst:226
msgid ":source_file:`swig/csharp/apps/GDALReadDirect.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_raster.rst:228
msgid ""
"This document was amended from the previous version at "
"`https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpRaster "
"<https://trac.osgeo.org/gdal/wiki/GdalOgrCsharpRaster>`__"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:5
msgid "C# Bindings Usage Advice"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:8
msgid "Adding reference to the GDAL/OGR assemblies"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:10
#: ../../source/api/csharp/csharp_usage.rst:15
msgid "TODO"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:13
msgid "Using the interface classes"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:19
msgid "Modifying Local Search Path"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:22
msgid ""
"If you want to add a folder to PATH during run-time, so you don't have to"
" pollute system PATH permanently, you can do it this way, in C#"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:43
msgid "MSDN documentation:"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:45
msgid ""
"`http://msdn2.microsoft.com/en-us/library/ms686206.aspx "
"<http://msdn2.microsoft.com/en-us/library/ms686206.aspx>`__"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:46
msgid ""
"`http://msdn2.microsoft.com/en-"
"us/library/system.environment.setenvironmentvariable.aspx "
"<http://msdn2.microsoft.com/en-"
"us/library/system.environment.setenvironmentvariable.aspx>`__"
msgstr ""

#: ../../source/api/csharp/csharp_usage.rst:48
msgid ""
"Instead of the P/Invoke call to :program:`SetEnvironmentVariable()`, you "
"can use C# native method :program:`Environment.SetEnvironmentVariable()`."
" Read the doc carefully, because there are two versions of this method. "
"Unlike the Win32 API call accessed through P/Invoke, the method "
":program:`Environment.SetEnvironmentVariable()` has an overload that "
"*may* change environment permanently, across processes."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:5
msgid "C# Vector and Spatial Reference Interfaces"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:8
msgid "Basic Architecture"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:10
msgid ""
"The vector interface is within the :file:`OSGeo.OGR` namespace and the "
"spatial reference interface is within the :file:`OSGeo.OSR` namespace."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:12
msgid "The **main** classes are as follows"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:35
msgid "Accessing Feature Geometries"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:37
msgid ""
"The basic process is :file:`DataSource` => :file:`Layer` => "
":file:`Feature` => :file:`Geometry`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:40
msgid "Open a DataSource"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:42
msgid ""
"A :file:`DataSource` wraps a OGR source (e.g a filename) and is created "
"as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:63
msgid "Access the Layers"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:65
msgid ""
"Each :file:`DataSource` will have one or more layers that can be iterated"
" as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:85
msgid "Access a Layer's Features"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:87
msgid ""
"Each :file:`Layer` can have zero or more :file:`Feature` s. These should "
"be accessed as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:100
msgid "Access a Features's Geometry"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:107
msgid ":file:`Geometry` objects are nested - so for instance:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:109
msgid ""
"a :file:`Geometry` of type :file:`wkbGeometryType.wkbTIN` has multiple "
"daughter :file:`Geometry` objects of type "
":file:`wkbGeometryType.wkbTriangle`,"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:110
msgid ""
"each :file:`Geometry` object of type :file:`wkbGeometryType.wkbTriangle` "
"has a daughter :file:`Geometry` object of type "
":file:`wkbGeometryType.LinearRing`,"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:111
msgid ""
"each :file:`Geometry` of type :file:`wkbGeometryType.LinearRing` contains"
" a number of points."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:113
msgid ""
"When you get to the most basic type - which usually seems to be "
":file:`wkbGeometryType.wkbPoint`, :file:`wkbGeometryType.wkbLineString` "
"or :file:`wkbGeometryType.wkbLinearRing` or their multi- versions or 25D "
"or ZM versions, you can access the point coordinates as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:126
msgid ""
"The size of the :file:`double[]` depends on the number of dimensions of "
"the :file:`Geometry`."
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:129
msgid "Access a Feature's data fields"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:131
msgid ""
"Each :file:`Feature` object can have a number of data fields associated. "
"The schema for the data fields is defined in a :file:`FieldDefn` object. "
"The fields can be fetched a follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:162
msgid "Access a Geometry's CRS"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:164
msgid ""
"If there is a CRS (aka SRS) defined for the :file:`Geometry` it can be "
"retrieved as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:170
msgid ""
"The :file:`SpatialReference` is the main class for representing the CRS /"
" projection. The CRS can be turned into a WKT string, e.g. for display "
"purposes, as follows:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:178
msgid ""
"Sometimes the CRS defined on the layer does not cascade down to the "
"Feature - you need to refer bak to the Layer"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:182
msgid "Reproject a Geometry"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:184
msgid ""
"If the :file:`Geometry` has a valid :file:`SpatialReference` defined, "
"then the :file:`Geometry` can be transformed to a new CRS using this "
"command:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:192
msgid ""
"However, often it is better to explicitly define the "
":file:`CoordinateTransform` to be used"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:214
msgid ""
"The following examples demonstrate the usage of the OGR vector operations"
" mentioned above:"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:216
msgid ":source_file:`swig/csharp/apps/ogrinfo.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:217
msgid ":source_file:`swig/csharp/apps/OGRLayerAlg.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:218
msgid ":source_file:`swig/csharp/apps/OGRFeatureEdit.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:219
msgid ":source_file:`swig/csharp/apps/OSRTransform.cs`"
msgstr ""

#: ../../source/api/csharp/csharp_vector.rst:220
msgid ":source_file:`swig/csharp/apps/GetCRSInfo.cs`"
msgstr ""

#: ../../source/api/csharp/index.rst:5
msgid "C# bindings"
msgstr ""

#: ../../source/api/csharp/index.rst:7
msgid ""
"The GDAL project (primarily Tamas Szekeres) maintains SWIG generated C# "
"bindings for GDAL and OGR."
msgstr ""

#: ../../source/api/csharp/index.rst:9
msgid ""
"Generally speaking the classes and methods mostly match those of the GDAL"
" and OGR C++ classes, but there is currently no C# specific documentation"
" beyond this site."
msgstr ""

#: ../../source/api/csharp/index.rst:11
msgid "The C# bindings are also usable from other .NET languages, such as VB.Net."
msgstr ""

#: ../../source/api/csharp/index.rst:13
msgid ""
"The C# interface has been built upon the same libraries as the other SWIG"
" generated wrappers (like Python, Java). Therefore, the class names, "
"class member names, and the method signatures are driven by the GDAL+SWIG"
" conventions and might not follow the conventional .NET naming "
"guidelines. However, one can easily identify the matching members in the "
"GDAL/OGR API documentation."
msgstr ""

#: ../../source/api/csharp/index.rst:17
msgid ""
"The GDAL/OGR C# classes use the .NET P/Invoke mechanism for the "
"communication between the managed and unmanaged code. Every class "
"implements the IDisposable interface to control the finalization of the "
"underlying unmanaged memory referenced by every the wrapper class."
msgstr ""

#: ../../source/api/csharp/index.rst:21
msgid "Supported platforms"
msgstr ""

#: ../../source/api/csharp/index.rst:23
msgid "Currently the interface is compilable on and supports:"
msgstr ""

#: ../../source/api/csharp/index.rst:25
msgid ""
"the various Win32 and Win64 platforms targeting the Microsoft.NET and the"
" MONO frameworks,"
msgstr ""

#: ../../source/api/csharp/index.rst:26
msgid "GNU Linux/OSX systems using the MONO framework, and"
msgstr ""

#: ../../source/api/csharp/index.rst:27
msgid ""
"Unity systems on Windows, OSX and Linux (currently only the MONO "
"framework and not IL2CPP)."
msgstr ""

#: ../../source/api/csharp/index.rst:30
msgid "Getting GDAL for C#"
msgstr ""

#: ../../source/api/csharp/index.rst:32
msgid ""
"There are a number of ways to get the C# bindings, including but not "
"limited to:"
msgstr ""

#: ../../source/api/csharp/index.rst:34
msgid ""
"The `gisinternals <http://www.gisinternals.com/sdk>`__ site, see below "
"under \"Windows Build SDK\","
msgstr ""

#: ../../source/api/csharp/index.rst:35
msgid ""
"The `Conda package <https://anaconda.org/conda-forge/gdal-csharp>`__, see"
" instructions below"
msgstr ""

#: ../../source/api/csharp/index.rst:36
msgid "The gdal.netcore NuGet package, see link below, and"
msgstr ""

#: ../../source/api/csharp/index.rst:37
msgid ""
"For Unity, there is a UPM package that installs GDAL, `available from "
"here <https://openupm.com/packages/com.virgis.gdal/?subPage=readme>`__ "
"(available on Windows, Mac and Linux)"
msgstr ""

#: ../../source/api/csharp/index.rst:39
msgid "(all of these are community supported)"
msgstr ""

#: ../../source/api/csharp/index.rst:43
msgid "Related Documents"
msgstr ""

#: ../../source/api/csharp/index.rst:56 ../../source/api/java/index.rst:69
msgid "Useful Links"
msgstr ""

#: ../../source/api/csharp/index.rst:58
msgid ""
"A variety of example programs in CSharp are available at the "
"`/swig/csharp/apps "
"<https://github.com/OSGeo/gdal/tree/master/swig/csharp/apps>`__ folder of"
" the GDAL project tree."
msgstr ""

#: ../../source/api/csharp/index.rst:60
msgid "The Conda Feedstock"
msgstr ""

#: ../../source/api/csharp/index.rst:62
msgid ""
"A simple (as is) build engine of GDAL 3.2 library for .NET Core. `MaxRev-"
"Dev/gdal.netcore <https://github.com/MaxRev-Dev/gdal.netcore>`__"
msgstr ""

#: ../../source/api/csharp/index.rst:64
msgid ""
"The `ViRGiS project <https://www.virgis.org/>`__ makes extensive use of "
"GDAL in c# in a Unity environment."
msgstr ""

#: ../../source/api/csharp/index.rst:66
msgid "(Please add your project to this section)"
msgstr ""

#: ../../source/api/csharp/index.rst:70
msgid "Windows Build SDKs"
msgstr ""

#: ../../source/api/csharp/index.rst:72
msgid ""
"Tamas Szekeres maintains `build SDK packages "
"<http://www.gisinternals.com/sdk>`__ in order to compile GDAL from the "
"sources on Windows. The build system provides daily build binary packages"
" for the latest stable and development versions."
msgstr ""

#: ../../source/api/gdal_alg.rst:10
msgid "gdal_alg.h: GDAL Algorithms C API"
msgstr ""

#: ../../source/api/gdal_alg.rst:13
msgid "gdal_alg.h"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param pTransformerArg"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param bDstToSrc"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param nPointCount"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param x"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param y"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param z"
msgstr ""

#: ../../source/api/gdal_alg.rst
msgid "Param panSuccess"
msgstr ""

#: ../../source/api/gdal_utils.rst:10
msgid "gdal_utils.h: GDAL Algorithms C API"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst:10
msgid "GDALAbstractMDArray C++ API"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param array"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param chunkArrayStartIdx"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param chunkCount"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param iCurChunk"
msgstr ""

#: ../../source/api/gdalabstractmdarray_cpp.rst
msgid "Param nChunkCount"
msgstr ""

#: ../../source/api/gdalattribute_cpp.rst:10
msgid "GDALAttribute C++ API"
msgstr ""

#: ../../source/api/gdalattribute_cpp.rst:13
msgid "GDALAttribute class"
msgstr ""

#: ../../source/api/gdalattribute_cpp.rst:20
msgid "GDALIHasAttribute interface"
msgstr ""

#: ../../source/api/gdaldataset_cpp.rst:10
msgid "GDALDataset C++ API"
msgstr ""

#: ../../source/api/gdaldimension_cpp.rst:10
msgid "GDALDimension C++ API"
msgstr ""

#: ../../source/api/gdaldriver_cpp.rst:10
msgid "GDALDriver C++ API"
msgstr ""

#: ../../source/api/gdaldriver_cpp.rst:13
msgid "GDALDriver class"
msgstr ""

#: ../../source/api/gdaldriver_cpp.rst:20
msgid "GDALDriverManager class"
msgstr ""

#: ../../source/api/gdalextendeddatatype_cpp.rst:10
msgid "GDALExtendedDataType C++ API"
msgstr ""

#: ../../source/api/gdalextendeddatatype_cpp.rst:13
msgid "GDALExtendedDataType class"
msgstr ""

#: ../../source/api/gdalextendeddatatype_cpp.rst:20
msgid "GDALEDTComponent class"
msgstr ""

#: ../../source/api/gdalgroup_cpp.rst:10
msgid "GDALGroup C++ API"
msgstr ""

#: ../../source/api/gdalmdarray_cpp.rst:10
msgid "GDALMDArray C++ API"
msgstr ""

#: ../../source/api/gdalrasterband_cpp.rst:10
msgid "GDALRasterBand C++ API"
msgstr ""

#: ../../source/api/gdalrasterband_cpp.rst ../../source/api/gdalwarp_cpp.rst
#: ../../source/api/gnm_cpp.rst
msgid "Protected Functions"
msgstr ""

#: ../../source/api/gdalwarp_cpp.rst:10
msgid "Warper C++ API"
msgstr ""

#: ../../source/api/gdalwarp_cpp.rst
msgid "Friends"
msgstr ""

#: ../../source/api/gnm_cpp.rst:10
msgid "Geographic Network C++ API"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Go"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Julia"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Lua"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Original Node.js bindings"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Node.js fork with full Promise-based async and TypeScript support"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Perl"
msgstr ""

#: ../../source/api/index.rst:115
msgid "PHP"
msgstr ""

#: ../../source/api/index.rst:115
msgid "R"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Ruby"
msgstr ""

#: ../../source/api/index.rst:115
msgid "Rust"
msgstr ""

#: ../../source/api/index.rst:136
msgid "Fiona"
msgstr ""

#: ../../source/api/index.rst:136
msgid "Rasterio"
msgstr ""

#: ../../source/api/index.rst:144
msgid "Godal"
msgstr ""

#: ../../source/api/index.rst:5 ../../source/api/python_bindings.rst:133
msgid "API"
msgstr ""

#: ../../source/api/index.rst:10
msgid "`Full Doxygen output <../doxygen/index.html>`_"
msgstr ""

#: ../../source/api/index.rst:13
msgid "C API"
msgstr ""

#: ../../source/api/index.rst:26
msgid "C++ API"
msgstr ""

#: ../../source/api/index.rst:29
msgid "Raster API"
msgstr ""

#: ../../source/api/index.rst:40
msgid "Vector API"
msgstr ""

#: ../../source/api/index.rst:51
msgid "Spatial reference system API"
msgstr ""

#: ../../source/api/index.rst:59
msgid "Multi-dimensional array API"
msgstr ""

#: ../../source/api/index.rst:72
msgid "Miscellaneous C++ API"
msgstr ""

#: ../../source/api/index.rst:81
msgid "Python API"
msgstr ""

#: ../../source/api/index.rst:99
msgid "`Java API <../java/index.html>`_"
msgstr ""

#: ../../source/api/index.rst:103
msgid "GDAL/OGR In Other Languages"
msgstr ""

#: ../../source/api/index.rst:105
msgid ""
"There is a set of generic `SWIG <http://www.swig.org/>`__ interface files"
" in the GDAL source tree (subdirectory swig) and a set of language "
"bindings based on those. Currently active ones are:"
msgstr ""

#: ../../source/api/index.rst:113
msgid ""
"There are also other bindings that are developed outside of the GDAL "
"source tree (**note**: those offer APIs not strictly coupled to the "
"GDAL/OGR C/C++ API). These include bindings for"
msgstr ""

#: ../../source/api/index.rst:130
msgid ""
"For Perl, since GDAL 3.5 the link `Perl "
"<https://trac.osgeo.org/gdal/wiki/GdalOgrInPerl>`__ is deprecated, use "
"above link instead."
msgstr ""

#: ../../source/api/index.rst:134
msgid "There are also more Pythonic ways of using the vector/OGR functions with"
msgstr ""

#: ../../source/api/index.rst:142
msgid "There is a more idiomatic Golang way of using the raster functions with"
msgstr ""

#: ../../source/api/index.rst:151
msgid ""
"API is omitted in this PDF document. You can consult it on "
"https://gdal.org/api/index.html"
msgstr ""

#: ../../source/api/java/index.rst:5
msgid "Java bindings"
msgstr ""

#: ../../source/api/java/index.rst:7
msgid "The GDAL project has SWIG generated Java bindings for GDAL and OGR."
msgstr ""

#: ../../source/api/java/index.rst:9
msgid ""
"Generally speaking the classes and methods mostly match those of the GDAL"
" and OGR C++ classes. You can find the `​Javadoc "
"<http://gdal.org/java>`__ of the API of the Java bindings."
msgstr ""

#: ../../source/api/java/index.rst:11
msgid ""
"Due to the fact the Java garbage collector works in a separate thread "
"from the main thread, it is necessary to configure GDAL with multi-"
"threading support, even if you do not use GDAL API from several Java "
"threads."
msgstr ""

#: ../../source/api/java/index.rst:14
msgid "How to build bindings"
msgstr ""

#: ../../source/api/java/index.rst:16
msgid ""
"Please consult the CMake :ref:`building_from_source_java` paragraph for "
"CMake options controlling how to enable the Java bindings and where to "
"install its artifacts"
msgstr ""

#: ../../source/api/java/index.rst:21
msgid "How to use the bindings"
msgstr ""

#: ../../source/api/java/index.rst:23
msgid ""
"The result of the build of the Java bindings will be both a "
":file:`gdal.jar` and a companion :file:`libgdalalljni.so` / "
":file:`libgdalalljni.dylib` / :file:`gdalalljni.dll` native library. To "
"limit potential compatibility problems, you should ensure that gdal.jar "
"and gdalalljni come from the same GDAL sources."
msgstr ""

#: ../../source/api/java/index.rst:28
msgid ""
"The native gdalalljni library, as well as the core libgdal library (and "
"its dependencies) should be accessible through the mechanism of the "
"operating system to locate shared libraries. Typically on Linux, this "
"means that the path to those libraries should be set in the "
"``LD_LIBRARY_PATH`` environment variable (or in :file:`/etc/ld.so.conf`)."
" On MacOSX, it should be in the ``DYLD_LIBRARY_PATH`` environment "
"variable. And on Windows, in the ``PATH`` environment variable."
msgstr ""

#: ../../source/api/java/index.rst:36
msgid ""
"For example, to test on Linux that the bindings are working, you can "
"lanch, from the build directory:"
msgstr ""

#: ../../source/api/java/index.rst:44
msgid "On Windows:"
msgstr ""

#: ../../source/api/java/index.rst:53
msgid "Maven Users"
msgstr ""

#: ../../source/api/java/index.rst:55
msgid ""
"The Java bindings are available from the ​`Maven Central "
"<http://search.maven.org/>`__ repository. All that is needed is to "
"declare a dependency."
msgstr ""

#: ../../source/api/java/index.rst:71
msgid "​`Javadoc <http://gdal.org/java>`__ of the API of the Java bindings."
msgstr ""

#: ../../source/api/java/index.rst:72
msgid ""
"`gdalinfo.java "
"<https://github.com/OSGeo/gdal/tree/master/swig/java/apps/gdalinfo.java>`__"
" Sample Java program similar to gdalinfo utility."
msgstr ""

#: ../../source/api/java/index.rst:73
msgid ""
"`All Java sample programs "
"<https://github.com/OSGeo/gdal/tree/master/swig/java/apps/>`__"
msgstr ""

#: ../../source/api/java/index.rst:74
msgid ""
"`Tamas Szekeres' Windows daily builds "
"<http://www.gisinternals.com/sdk>`__ : Tamas Szekeres maintains a "
"complete set of Win32 and Win64 binary packages that include the GDAL "
"Java bindings. These packages are based on the current development and "
"stable branches built from the GDAL source repository."
msgstr ""

#: ../../source/api/java/index.rst:75
msgid ""
"`Image I/O-Ext <https://imageio-ext.dev.java.net/>`__ : The main core "
"module of the project is gdalframework, a framework leveraging on GDAL "
"via SWIG's generated JAVA bindings to provide support for a reach set of "
"data formats. (**Note**: this framework doesn't necessarily ship the "
"latest released GDAL version)"
msgstr ""

#: ../../source/api/ogr_srs_api.rst:10
msgid "ogr_srs_api.h: Spatial Reference System C API"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:10
msgid "OGRFeature C++ API"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:13
msgid "OGRFeature class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:20
msgid "OGRFeatureDefn class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:27
msgid "OGRFieldDefn class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:34
msgid "OGRGeomFieldDefn class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:41
msgid "OGRFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:48
msgid "OGRCodedFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:55
msgid "OGRRangeFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeature_cpp.rst:62
msgid "OGRGlobFieldDomain class"
msgstr ""

#: ../../source/api/ogrfeaturestyle_cpp.rst:10
msgid "OGRFeature Style C++ API"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:10
msgid "OGRGeometry C++ API"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:12
msgid "Include file: ogr_geometry.h"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:15
msgid "OGRGeometryFactory class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:22
msgid "OGRGeometry class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:29
msgid "OGRPoint class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:36
msgid "OGRLineString class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:43
msgid "OGRLinearRing class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:50
msgid "OGRCircularString class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:57
msgid "OGRCurve class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:64
msgid "OGRSurface class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:71
msgid "OGRPolygon class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:78
msgid "OGRCurvePolygon class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:85
msgid "OGRMultiPoint class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:92
msgid "OGRMultiLineString class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:99
msgid "OGRMultiPolygon class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:106
msgid "OGRGeometryCollection class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:113
msgid "OGRMultiCurve class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:120
msgid "OGRMultiSurface class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:127
msgid "OGRPolyhedralSurface class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:134
msgid "OGRTriangle class"
msgstr ""

#: ../../source/api/ogrgeometry_cpp.rst:141
msgid "OGRTriangulatedSurface class"
msgstr ""

#: ../../source/api/ogrlayer_cpp.rst:10
msgid "OGRLayer C++ API"
msgstr ""

#: ../../source/api/ogrlayer_cpp.rst ../../source/api/ogrspatialref.rst
msgid "Public Static Attributes"
msgstr ""

#: ../../source/api/ogrspatialref.rst:10
msgid "Spatial Reference System C++ API"
msgstr ""

#: ../../source/api/python/general.rst:9
msgid "Python General API"
msgstr ""

#: ../../source/api/python/general.rst:12
msgid "Configuration Management"
msgstr ""

#: ../../source/api/python/general.rst:58
msgid "Error Handling"
msgstr ""

#: of osgeo.gdal.ConfigurePythonLogging:1
msgid "Configure GDAL to use Python's logging framework"
msgstr ""

#: ../../source/api/python/general.rst:96
msgid "File Management"
msgstr ""

#: of osgeo.gdal.DirEntry:1
msgid "Proxy of C++ DirEntry class."
msgstr ""

#: of osgeo.gdal.DirEntry.extra:1
msgid "p.p.char"
msgstr ""

#: of osgeo.gdal.Band.DataType osgeo.gdal.Band.XSize osgeo.gdal.Band.YSize
#: osgeo.gdal.ColorEntry.c1 osgeo.gdal.ColorEntry.c2 osgeo.gdal.ColorEntry.c3
#: osgeo.gdal.ColorEntry.c4 osgeo.gdal.Dataset.RasterCount
#: osgeo.gdal.Dataset.RasterXSize osgeo.gdal.Dataset.RasterYSize
#: osgeo.gdal.DirEntry.extra osgeo.gdal.DirEntry.mode
#: osgeo.gdal.DirEntry.modeKnown osgeo.gdal.DirEntry.mtime
#: osgeo.gdal.DirEntry.mtimeKnown osgeo.gdal.DirEntry.name
#: osgeo.gdal.DirEntry.size osgeo.gdal.DirEntry.sizeKnown
#: osgeo.gdal.Driver.HelpTopic osgeo.gdal.Driver.LongName
#: osgeo.gdal.Driver.ShortName osgeo.gdal.GCP.GCPLine osgeo.gdal.GCP.GCPPixel
#: osgeo.gdal.GCP.GCPX osgeo.gdal.GCP.GCPY osgeo.gdal.GCP.GCPZ
#: osgeo.gdal.GCP.Id osgeo.gdal.GCP.Info osgeo.gdal.StatBuf.mode
#: osgeo.gdal.StatBuf.mtime osgeo.gdal.StatBuf.size osgeo.gdal.Statistics.max
#: osgeo.gdal.Statistics.mean osgeo.gdal.Statistics.min
#: osgeo.gdal.Statistics.std_dev osgeo.gdal.Statistics.valid_count
#: osgeo.ogr.DataSource.name osgeo.ogr.Driver.name
#: osgeo.osr.AreaOfUse.east_lon_degree osgeo.osr.AreaOfUse.name
#: osgeo.osr.AreaOfUse.north_lat_degree osgeo.osr.AreaOfUse.south_lat_degree
#: osgeo.osr.AreaOfUse.west_lon_degree osgeo.osr.CRSInfo.area_name
#: osgeo.osr.CRSInfo.auth_name osgeo.osr.CRSInfo.bbox_valid
#: osgeo.osr.CRSInfo.code osgeo.osr.CRSInfo.deprecated
#: osgeo.osr.CRSInfo.east_lon_degree osgeo.osr.CRSInfo.name
#: osgeo.osr.CRSInfo.north_lat_degree osgeo.osr.CRSInfo.projection_method
#: osgeo.osr.CRSInfo.south_lat_degree osgeo.osr.CRSInfo.type
#: osgeo.osr.CRSInfo.type:3 osgeo.osr.CRSInfo.west_lon_degree
msgid "type"
msgstr ""

#: of osgeo.gdal.DirEntry.extra:3
msgid "extra"
msgstr ""

#: of osgeo.gdal.Band.XSize:1 osgeo.gdal.Band.YSize:1
#: osgeo.gdal.Dataset.RasterCount:1 osgeo.gdal.Dataset.RasterXSize:1
#: osgeo.gdal.Dataset.RasterYSize:1 osgeo.gdal.DirEntry.mode:1
#: osgeo.gdal.StatBuf.mode:1
msgid "int"
msgstr ""

#: of osgeo.gdal.DirEntry.mode:3 osgeo.gdal.StatBuf.mode:3
msgid "mode"
msgstr ""

#: of osgeo.gdal.DirEntry.modeKnown:1 osgeo.gdal.DirEntry.mtimeKnown:1
#: osgeo.gdal.DirEntry.sizeKnown:1 osgeo.osr.CRSInfo.bbox_valid:1
#: osgeo.osr.CRSInfo.deprecated:1
msgid "bool"
msgstr ""

#: of osgeo.gdal.DirEntry.modeKnown:3
msgid "modeKnown"
msgstr ""

#: of osgeo.gdal.DirEntry.mtime:1 osgeo.gdal.DirEntry.size:1
#: osgeo.gdal.StatBuf.mtime:1 osgeo.gdal.StatBuf.size:1
#: osgeo.gdal.Statistics.valid_count:1
msgid "GIntBig"
msgstr ""

#: of osgeo.gdal.DirEntry.mtime:3 osgeo.gdal.StatBuf.mtime:3
msgid "mtime"
msgstr ""

#: of osgeo.gdal.DirEntry.mtimeKnown:3
msgid "mtimeKnown"
msgstr ""

#: of osgeo.gdal.DirEntry.name:1 osgeo.gdal.GCP.Id:1 osgeo.gdal.GCP.Info:1
#: osgeo.osr.AreaOfUse.name:1 osgeo.osr.CRSInfo.area_name:1
#: osgeo.osr.CRSInfo.auth_name:1 osgeo.osr.CRSInfo.code:1
#: osgeo.osr.CRSInfo.name:1 osgeo.osr.CRSInfo.projection_method:1
msgid "p.char"
msgstr ""

#: of osgeo.gdal.DirEntry.name:3 osgeo.ogr.DataSource.name:3
#: osgeo.ogr.Driver.name:3 osgeo.osr.AreaOfUse.name:3 osgeo.osr.CRSInfo.name:3
msgid "name"
msgstr ""

#: of osgeo.gdal.DirEntry.size:3 osgeo.gdal.StatBuf.size:3
msgid "size"
msgstr ""

#: of osgeo.gdal.DirEntry.sizeKnown:3
msgid "sizeKnown"
msgstr ""

#: of osgeo.gdal.DirEntry.thisown:1 osgeo.gdal_array.VirtualMem.thisown:1
#: osgeo.gnm.GenericNetwork.thisown:1 osgeo.gnm.Network.thisown:1
msgid "The membership flag"
msgstr ""

#: ../../source/api/python/mdim_api.rst:9
msgid "Python Multi-dimensional array API"
msgstr ""

#: of osgeo.gdal.Group:1
msgid "Proxy of C++ GDALGroupHS class."
msgstr ""

#: of osgeo.gdal.Dimension:1
msgid "Proxy of C++ GDALDimensionHS class."
msgstr ""

#: of osgeo.gdal.MDArray:1
msgid "Proxy of C++ GDALMDArrayHS class."
msgstr ""

#: of osgeo.gdal.MDArray.GetShape:1
msgid "Return the shape of the array"
msgstr ""

#: of osgeo.gdal.MDArray.ReadAsMaskedArray:1
msgid "Return a numpy masked array of ReadAsArray() with GetMask()"
msgstr ""

#: of osgeo.gdal.MDArray.shape:1
msgid "Returns the shape of the array."
msgstr ""

#: of osgeo.gdal.Attribute:1
msgid "Proxy of C++ GDALAttributeHS class."
msgstr ""

#: of osgeo.gdal.Attribute.Read:1
msgid "Read an attribute and return it with the most appropriate type"
msgstr ""

#: of osgeo.gdal.ExtendedDataType:1
msgid "Proxy of C++ GDALExtendedDataTypeHS class."
msgstr ""

#: ../../source/api/python/osgeo.rst:4
msgid "Miscellaneous Python API"
msgstr ""

#: ../../source/api/python/osgeo.rst:8
msgid "Submodules"
msgstr ""

#: ../../source/api/python/osgeo.rst:21
msgid "Module contents"
msgstr ""

#: ../../source/api/python/osgeo.gdal.rst:7
msgid "osgeo.gdal module"
msgstr ""

#: of osgeo.gdal.AsyncReader:1 osgeo.gdal.EDTComponent:1
#: osgeo.gdal.GDALTransformerInfoShadow:1 osgeo.gdal.MajorObject:1
#: osgeo.gdal.StatBuf:1 osgeo.gdal.Statistics:1 osgeo.gdal.VSILFILE:1
#: osgeo.gdal.VirtualMem:1 osgeo.gdal_array.VirtualMem:1 osgeo.ogr.ArrowArray:1
#: osgeo.ogr.ArrowArrayStream:1 osgeo.ogr.ArrowSchema:1
#: osgeo.ogr.GeomTransformer:1 osgeo.ogr.MajorObject:1
#: osgeo.ogr.PreparedGeometry:1 osgeo.osr.AreaOfUse:1 osgeo.osr.CRSInfo:1
msgid "Bases: :py:class:`object`"
msgstr ""

#: of osgeo.gdal.AsyncReader:1
msgid "Proxy of C++ GDALAsyncReaderShadow class."
msgstr ""

#: of osgeo.gdal.EDTComponent:1
msgid "Proxy of C++ GDALEDTComponentHS class."
msgstr ""

#: of osgeo.gdal.GDALTransformerInfoShadow:1
msgid "Proxy of C++ GDALTransformerInfoShadow class."
msgstr ""

#: of osgeo.gdal.MajorObject:1 osgeo.ogr.MajorObject:1
msgid "Proxy of C++ GDALMajorObjectShadow class."
msgstr ""

#: of osgeo.gdal.StatBuf:1
msgid "Proxy of C++ StatBuf class."
msgstr ""

#: of osgeo.gdal.Statistics:1
msgid "Proxy of C++ Statistics class."
msgstr ""

#: of osgeo.gdal.GCP.GCPLine:1 osgeo.gdal.GCP.GCPPixel:1 osgeo.gdal.GCP.GCPX:1
#: osgeo.gdal.GCP.GCPY:1 osgeo.gdal.GCP.GCPZ:1 osgeo.gdal.Statistics.max:1
#: osgeo.gdal.Statistics.mean:1 osgeo.gdal.Statistics.min:1
#: osgeo.gdal.Statistics.std_dev:1 osgeo.osr.AreaOfUse.east_lon_degree:1
#: osgeo.osr.AreaOfUse.north_lat_degree:1
#: osgeo.osr.AreaOfUse.south_lat_degree:1 osgeo.osr.AreaOfUse.west_lon_degree:1
#: osgeo.osr.CRSInfo.east_lon_degree:1 osgeo.osr.CRSInfo.north_lat_degree:1
#: osgeo.osr.CRSInfo.south_lat_degree:1 osgeo.osr.CRSInfo.west_lon_degree:1
msgid "double"
msgstr ""

#: of osgeo.gdal.Statistics.max:3
msgid "max"
msgstr ""

#: of osgeo.gdal.Statistics.mean:3
msgid "mean"
msgstr ""

#: of osgeo.gdal.Statistics.min:3
msgid "min"
msgstr ""

#: of osgeo.gdal.Statistics.std_dev:3
msgid "std_dev"
msgstr ""

#: of osgeo.gdal.Statistics.valid_count:3
msgid "valid_count"
msgstr ""

#: of osgeo.gdal.VSILFILE:1
msgid "Proxy of C++ VSILFILE class."
msgstr ""

#: of osgeo.gdal.VirtualMem:1 osgeo.gdal_array.VirtualMem:1
msgid "Proxy of C++ CPLVirtualMemShadow class."
msgstr ""

#: of osgeo.gdal.listdir:1
msgid "Iterate over a directory."
msgstr ""

#: of osgeo.gdal.listdir:3
msgid "recursionLevel = -1 means unlimited level of recursion."
msgstr ""

#: ../../source/api/python/osgeo.gdal_array.rst:7
msgid "osgeo.gdal\\_array module"
msgstr ""

#: of osgeo.gdal_array.BandReadAsArray:1
msgid ""
"Pure python implementation of reading a chunk of a GDAL file into a numpy"
" array.  Used by the gdal.Band.ReadAsArray method."
msgstr ""

#: of osgeo.gdal_array.BandWriteArray:1
msgid ""
"Pure python implementation of writing a chunk of a GDAL file from a numpy"
" array.  Used by the gdal.Band.WriteArray method."
msgstr ""

#: of osgeo.gdal_array.CopyDatasetInfo:1
msgid ""
"Copy georeferencing information and metadata from one dataset to another."
" src: input dataset dst: output dataset - It can be a ROI - xoff, yoff:  "
"dst's offset with respect to src in pixel/line."
msgstr ""

#: of osgeo.gdal_array.CopyDatasetInfo:6
msgid "Notes: Destination dataset must have update access.  Certain formats"
msgstr ""

#: of osgeo.gdal_array.CopyDatasetInfo:7
msgid "do not support creation of geotransforms and/or gcps."
msgstr ""

#: of osgeo.gdal_array.DatasetReadAsArray:1
msgid ""
"Pure python implementation of reading a chunk of a GDAL file into a numpy"
" array.  Used by the gdal.Dataset.ReadAsArray method."
msgstr ""

#: of osgeo.gdal_array.DatasetWriteArray:1
msgid ""
"Pure python implementation of writing a chunk of a GDAL file from a numpy"
" array.  Used by the gdal.Dataset.WriteArray method."
msgstr ""

#: of osgeo.gdal_array.RATReadArray:1
msgid ""
"Pure Python implementation of reading a chunk of the RAT into a numpy "
"array. Called from RasterAttributeTable.ReadAsArray"
msgstr ""

#: of osgeo.gdal_array.RATWriteArray:1
msgid ""
"Pure Python implementation of writing a chunk of the RAT from a numpy "
"array. Type of array is coerced to one of the types (int, double, string)"
" supported. Called from RasterAttributeTable.WriteArray"
msgstr ""

#: ../../source/api/python/osgeo.gdalconst.rst:7
msgid "osgeo.gdalconst module"
msgstr ""

#: ../../source/api/python/osgeo.gnm.rst:7
msgid "osgeo.gnm module"
msgstr ""

#: of osgeo.gnm.GenericNetwork:1
msgid "Bases: :py:class:`~osgeo.gnm.Network`"
msgstr ""

#: of osgeo.gnm.GenericNetwork:1
msgid "Proxy of C++ GNMGenericNetworkShadow class."
msgstr ""

#: of osgeo.gnm.Network:1 osgeo.ogr.DataSource:1 osgeo.ogr.Driver:1
msgid "Bases: :py:class:`~osgeo.ogr.MajorObject`"
msgstr ""

#: of osgeo.gnm.Network:1
msgid "Proxy of C++ GNMNetworkShadow class."
msgstr ""

#: ../../source/api/python/osgeo.ogr.rst:7
msgid "osgeo.ogr module"
msgstr ""

#: of osgeo.ogr.ArrowArray:1
msgid "Proxy of C++ ArrowArray class."
msgstr ""

#: of osgeo.ogr.ArrowArrayStream:1
msgid "Proxy of C++ ArrowArrayStream class."
msgstr ""

#: of osgeo.ogr.ArrowSchema:1
msgid "Proxy of C++ ArrowSchema class."
msgstr ""

#: of osgeo.ogr.DataSource:1
msgid "Proxy of C++ OGRDataSourceShadow class."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:1
msgid ""
"OGRLayerH OGR_DS_CopyLayer(OGRDataSourceH hDS, OGRLayerH hSrcLayer, const"
" char \\*pszNewName, char \\*\\*papszOptions)"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:5
msgid "Duplicate an existing layer."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:7
msgid ""
"This function creates a new layer, duplicate the field definitions of the"
" source layer and then duplicate each features of the source layer. The "
"papszOptions argument can be used to control driver specific creation "
"options. These options are normally documented in the format specific "
"documentation. The source layer may come from another dataset."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:14
msgid "Deprecated Use GDALDatasetCopyLayer() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:16
msgid "handle to the data source where to create the new layer"
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:17
msgid "handle to the source layer."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:18
msgid "the name of the layer to create."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:19
msgid "a StringList of name=value options. Options are driver specific."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer:22
msgid "a handle to the layer, or NULL if an error occurs."
msgstr ""

#: of osgeo.ogr.DataSource.CopyLayer osgeo.ogr.DataSource.CreateLayer
#: osgeo.ogr.DataSource.DeleteLayer osgeo.ogr.DataSource.ExecuteSQL
#: osgeo.ogr.DataSource.GetDriver osgeo.ogr.DataSource.GetLayerByName
#: osgeo.ogr.DataSource.GetLayerCount osgeo.ogr.DataSource.GetName
#: osgeo.ogr.DataSource.TestCapability osgeo.ogr.Feature.Clone
#: osgeo.ogr.Feature.Equal osgeo.ogr.Feature.GetDefnRef
#: osgeo.ogr.Feature.GetFID osgeo.ogr.Feature.GetFieldAsBinary
#: osgeo.ogr.Feature.GetFieldAsDateTime osgeo.ogr.Feature.GetFieldAsDouble
#: osgeo.ogr.Feature.GetFieldAsDoubleList osgeo.ogr.Feature.GetFieldAsInteger
#: osgeo.ogr.Feature.GetFieldAsInteger64
#: osgeo.ogr.Feature.GetFieldAsInteger64List
#: osgeo.ogr.Feature.GetFieldAsIntegerList osgeo.ogr.Feature.GetFieldAsString
#: osgeo.ogr.Feature.GetFieldAsStringList osgeo.ogr.Feature.GetFieldCount
#: osgeo.ogr.Feature.GetFieldDefnRef osgeo.ogr.Feature.GetFieldIndex
#: osgeo.ogr.Feature.GetGeomFieldCount osgeo.ogr.Feature.GetGeomFieldDefnRef
#: osgeo.ogr.Feature.GetGeomFieldIndex osgeo.ogr.Feature.GetGeometryRef
#: osgeo.ogr.Feature.GetNativeData osgeo.ogr.Feature.GetNativeMediaType
#: osgeo.ogr.Feature.GetStyleString osgeo.ogr.Feature.IsFieldNull
#: osgeo.ogr.Feature.IsFieldSet osgeo.ogr.Feature.IsFieldSetAndNotNull
#: osgeo.ogr.Feature.SetFID osgeo.ogr.Feature.SetFrom
#: osgeo.ogr.Feature.SetFromWithMap osgeo.ogr.Feature.SetGeomField
#: osgeo.ogr.Feature.SetGeomFieldDirectly osgeo.ogr.Feature.SetGeometry
#: osgeo.ogr.Feature.SetGeometryDirectly osgeo.ogr.Feature.Validate
#: osgeo.ogr.Feature.geometry osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn
#: osgeo.ogr.FeatureDefn.GetFieldCount osgeo.ogr.FeatureDefn.GetFieldDefn
#: osgeo.ogr.FeatureDefn.GetFieldIndex osgeo.ogr.FeatureDefn.GetGeomFieldCount
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn
#: osgeo.ogr.FeatureDefn.GetGeomFieldIndex osgeo.ogr.FeatureDefn.GetGeomType
#: osgeo.ogr.FeatureDefn.GetName osgeo.ogr.FeatureDefn.GetReferenceCount
#: osgeo.ogr.FeatureDefn.IsGeometryIgnored osgeo.ogr.FeatureDefn.IsSame
#: osgeo.ogr.FeatureDefn.IsStyleIgnored
#: osgeo.ogr.FieldDefn.GetAlternativeNameRef osgeo.ogr.FieldDefn.GetDefault
#: osgeo.ogr.FieldDefn.GetDomainName osgeo.ogr.FieldDefn.GetJustify
#: osgeo.ogr.FieldDefn.GetNameRef osgeo.ogr.FieldDefn.GetPrecision
#: osgeo.ogr.FieldDefn.GetSubType osgeo.ogr.FieldDefn.GetType
#: osgeo.ogr.FieldDefn.GetWidth osgeo.ogr.FieldDefn.IsDefaultDriverSpecific
#: osgeo.ogr.FieldDefn.IsIgnored osgeo.ogr.FieldDefn.IsNullable
#: osgeo.ogr.FieldDefn.IsUnique osgeo.ogr.FieldDefn.justify
#: osgeo.ogr.FieldDefn.precision osgeo.ogr.FieldDefn.type
#: osgeo.ogr.FieldDefn.width osgeo.ogr.Geometry.Boundary
#: osgeo.ogr.Geometry.Buffer osgeo.ogr.Geometry.Centroid
#: osgeo.ogr.Geometry.Clone osgeo.ogr.Geometry.Contains
#: osgeo.ogr.Geometry.ConvexHull osgeo.ogr.Geometry.CoordinateDimension
#: osgeo.ogr.Geometry.Crosses osgeo.ogr.Geometry.DelaunayTriangulation
#: osgeo.ogr.Geometry.Difference osgeo.ogr.Geometry.Disjoint
#: osgeo.ogr.Geometry.Distance osgeo.ogr.Geometry.Distance3D
#: osgeo.ogr.Geometry.Equals osgeo.ogr.Geometry.ExportToIsoWkb
#: osgeo.ogr.Geometry.ExportToIsoWkt osgeo.ogr.Geometry.ExportToWkb
#: osgeo.ogr.Geometry.ExportToWkt osgeo.ogr.Geometry.GetCoordinateDimension
#: osgeo.ogr.Geometry.GetDimension osgeo.ogr.Geometry.GetGeometryName
#: osgeo.ogr.Geometry.GetGeometryType osgeo.ogr.Geometry.GetSpatialReference
#: osgeo.ogr.Geometry.Intersection osgeo.ogr.Geometry.Intersects
#: osgeo.ogr.Geometry.Is3D osgeo.ogr.Geometry.IsEmpty
#: osgeo.ogr.Geometry.IsMeasured osgeo.ogr.Geometry.IsRing
#: osgeo.ogr.Geometry.IsSimple osgeo.ogr.Geometry.IsValid
#: osgeo.ogr.Geometry.MakeValid osgeo.ogr.Geometry.Normalize
#: osgeo.ogr.Geometry.Overlaps osgeo.ogr.Geometry.PointOnSurface
#: osgeo.ogr.Geometry.Polygonize osgeo.ogr.Geometry.Simplify
#: osgeo.ogr.Geometry.SimplifyPreserveTopology osgeo.ogr.Geometry.SymDifference
#: osgeo.ogr.Geometry.Touches osgeo.ogr.Geometry.Transform
#: osgeo.ogr.Geometry.TransformTo osgeo.ogr.Geometry.Union
#: osgeo.ogr.Geometry.UnionCascaded osgeo.ogr.Geometry.Within
#: osgeo.ogr.Geometry.WkbSize osgeo.ogr.Layer.AlterFieldDefn
#: osgeo.ogr.Layer.Clip osgeo.ogr.Layer.CommitTransaction
#: osgeo.ogr.Layer.CreateFeature osgeo.ogr.Layer.CreateField
#: osgeo.ogr.Layer.CreateGeomField osgeo.ogr.Layer.DeleteFeature
#: osgeo.ogr.Layer.DeleteField osgeo.ogr.Layer.Erase
#: osgeo.ogr.Layer.FindFieldIndex osgeo.ogr.Layer.GetFIDColumn
#: osgeo.ogr.Layer.GetFeature osgeo.ogr.Layer.GetFeatureCount
#: osgeo.ogr.Layer.GetGeomType osgeo.ogr.Layer.GetGeometryColumn
#: osgeo.ogr.Layer.GetGeometryTypes osgeo.ogr.Layer.GetLayerDefn
#: osgeo.ogr.Layer.GetName osgeo.ogr.Layer.GetNextFeature
#: osgeo.ogr.Layer.GetSpatialFilter osgeo.ogr.Layer.GetSpatialRef
#: osgeo.ogr.Layer.Identity osgeo.ogr.Layer.Intersection
#: osgeo.ogr.Layer.ReorderField osgeo.ogr.Layer.ReorderFields
#: osgeo.ogr.Layer.RollbackTransaction osgeo.ogr.Layer.SetAttributeFilter
#: osgeo.ogr.Layer.SetFeature osgeo.ogr.Layer.SetIgnoredFields
#: osgeo.ogr.Layer.SetNextByIndex osgeo.ogr.Layer.StartTransaction
#: osgeo.ogr.Layer.SymDifference osgeo.ogr.Layer.SyncToDisk
#: osgeo.ogr.Layer.TestCapability osgeo.ogr.Layer.Union osgeo.ogr.Layer.Update
#: osgeo.ogr.Layer.UpsertFeature
#, fuzzy
msgid "Return type"
msgstr "返り値"

#: of osgeo.ogr.DataSource.CreateLayer:1
msgid ""
"OGRLayerH OGR_DS_CreateLayer(OGRDataSourceH hDS, const char \\*pszName, "
"OGRSpatialReferenceH hSpatialRef, OGRwkbGeometryType eType, char "
"\\*\\*papszOptions)"
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:6
msgid ""
"This function attempts to create a new layer on the data source with the "
"indicated name, coordinate system, geometry type."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:9
msgid ""
"The papszOptions argument can be used to control driver specific creation"
" options. These options are normally documented in the format specific "
"documentation."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:13
msgid "Deprecated Use GDALDatasetCreateLayer() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:15
msgid ""
"The dataset handle.pszName:  the name for the new layer. This should "
"ideally not match any existing layer on the datasource."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:17
msgid ""
"handle to the coordinate system to use for the new layer, or NULL if no "
"coordinate system is available. The driver might only increase the "
"reference counter of the object to take ownership, and not make a full "
"copy, so do not use OSRDestroySpatialReference(), but OSRRelease() "
"instead when you are done with the object."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:22
msgid ""
"the geometry type for the layer. Use wkbUnknown if there are no "
"constraints on the types geometry to be written."
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:24
msgid ""
"a StringList of name=value options. Options are driver specific, and "
"driver information can be found at the following "
"url:http://www.gdal.org/ogr_formats.html"
msgstr ""

#: of osgeo.ogr.DataSource.CreateLayer:28
msgid "NULL is returned on failure, or a new OGRLayer handle on success."
msgstr ""

#: of osgeo.ogr.DataSource.DeleteLayer:1
msgid "Delete the indicated layer from the datasource."
msgstr ""

#: of osgeo.ogr.DataSource.DeleteLayer:3
msgid "For more details: :c:func:`OGR_DS_DeleteLayer`"
msgstr ""

#: of osgeo.ogr.DataSource.DeleteLayer:5
msgid "index or name of the layer to delete."
msgstr ""

#: of osgeo.ogr.DataSource.DeleteLayer:8
msgid ""
":py:const:`osgeo.ogr.OGRERR_NONE` on success, or "
":py:const:`osgeo.ogr.OGRERR_UNSUPPORTED_OPERATION` if deleting layers is "
"not supported for this datasource."
msgstr ""

#: of osgeo.ogr.DataSource.Dereference:1 osgeo.ogr.DataSource.Reference:1
#: osgeo.ogr.Layer.Dereference:1 osgeo.ogr.Layer.Reference:1
msgid "For backwards compatibility only."
msgstr ""

#: of osgeo.ogr.DataSource.Destroy:1 osgeo.ogr.DataSource.Release:1
#: osgeo.ogr.Feature.Destroy:1 osgeo.ogr.FeatureDefn.Destroy:1
#: osgeo.ogr.FieldDefn.Destroy:1
msgid ""
"Once called, self has effectively been destroyed.  Do not access. For "
"backwards compatibility only"
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:1
msgid ""
"OGRLayerH OGR_DS_ExecuteSQL(OGRDataSourceH hDS, const char "
"\\*pszStatement, OGRGeometryH hSpatialFilter, const char \\*pszDialect)"
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:5
msgid "Execute an SQL statement against the data store."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:7
msgid ""
"The result of an SQL query is either NULL for statements that are in "
"error, or that have no results set, or an OGRLayer handle representing a "
"results set from the query. Note that this OGRLayer is in addition to the"
" layers in the data store and must be destroyed with "
"OGR_DS_ReleaseResultSet() before the data source is closed (destroyed)."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:14
msgid ""
"For more information on the SQL dialect supported internally by OGR "
"review theOGR SQL document. Some drivers (i.e. Oracle and PostGIS) pass "
"the SQL directly through to the underlying RDBMS."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:18
msgid "TheSQLITE dialect can also be used."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:20
msgid "Deprecated Use GDALDatasetExecuteSQL() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:22
msgid "handle to the data source on which the SQL query is executed."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:23
msgid "the SQL statement to execute."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:24
msgid "handle to a geometry which represents a spatial filter. Can be NULL."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:26
msgid ""
"allows control of the statement dialect. If set to NULL, the OGR SQL "
"engine will be used, except for RDBMS drivers that will use their "
"dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect. "
"The SQLITE dialect can also be used."
msgstr ""

#: of osgeo.ogr.DataSource.ExecuteSQL:31
msgid ""
"a handle to a OGRLayer containing the results of the query. Deallocate "
"with OGR_DS_ReleaseResultSet()."
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:1
msgid "OGRSFDriverH OGR_DS_GetDriver(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:4
msgid "Returns the driver that the dataset was opened with."
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:6
msgid ""
"NOTE: Starting with GDAL 2.0, it is NOT safe to cast the returned handle "
"to OGRSFDriver\\*. If a C++ object is needed, the handle should be cast "
"to GDALDriver\\*."
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:10
msgid "Deprecated Use GDALGetDatasetDriver() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:12
msgid "handle to the datasource"
msgstr ""

#: of osgeo.ogr.DataSource.GetDriver:14
msgid ""
"NULL if driver info is not available, or pointer to a driver owned by the"
" OGRSFDriverManager."
msgstr ""

#: of osgeo.gdal.Dataset.GetLayer:1 osgeo.ogr.DataSource.GetLayer:1
msgid "Return the layer given an index or a name"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:1
msgid ""
"OGRLayerH OGR_DS_GetLayerByName(OGRDataSourceH hDS, const char "
"\\*pszLayerName)"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:4
msgid "Fetch a layer by name."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:6
msgid ""
"The returned layer remains owned by the OGRDataSource and should not be "
"deleted by the application."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:9
msgid "Deprecated Use GDALDatasetGetLayerByName() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:11
msgid "handle to the data source from which to get the layer."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:12
msgid "Layer the layer name of the layer to fetch."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerByName:14
msgid ""
"a handle to the layer, or NULL if the layer is not found or an error "
"occurs."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:1
msgid "int OGR_DS_GetLayerCount(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:4
msgid "Get the number of layers in this data source."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:6
msgid "Deprecated Use GDALDatasetGetLayerCount() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:8
msgid "handle to the data source from which to get the number of layers."
msgstr ""

#: of osgeo.ogr.DataSource.GetLayerCount:11
msgid "layer count."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:1
msgid "const char\\* OGR_DS_GetName(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetName:4
msgid "Returns the name of the data source."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:6
msgid ""
"This string should be sufficient to open the data source if passed to the"
" same OGRSFDriver that this data source was opened with, but it need not "
"be exactly the same string that was used to open the data source. "
"Normally this is a filename."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:11
msgid "Deprecated Use GDALGetDescription() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.GetName:13
msgid "handle to the data source to get the name from."
msgstr ""

#: of osgeo.ogr.DataSource.GetName:15
msgid ""
"pointer to an internal name string which should not be modified or freed "
"by the caller."
msgstr ""

#: of osgeo.ogr.DataSource.GetRefCount:1
msgid "int OGR_DS_GetRefCount(OGRDataSourceH hDataSource)"
msgstr ""

#: of osgeo.ogr.DataSource.GetStyleTable:1
msgid "OGRStyleTableH OGR_DS_GetStyleTable(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.GetStyleTable:4 osgeo.ogr.Layer.GetStyleTable:1
msgid "Get style table."
msgstr ""

#: of osgeo.ogr.DataSource.GetSummaryRefCount:1
msgid "int OGR_DS_GetSummaryRefCount(OGRDataSourceH hDataSource)"
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:1
msgid "void OGR_DS_ReleaseResultSet(OGRDataSourceH hDS, OGRLayerH hLayer)"
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:4
msgid "Release results of OGR_DS_ExecuteSQL()."
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:6
msgid ""
"This function should only be used to deallocate OGRLayers resulting from "
"an OGR_DS_ExecuteSQL() call on the same OGRDataSource. Failure to "
"deallocate a results set before destroying the OGRDataSource may cause "
"errors."
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:11
msgid "Deprecated Use GDALDatasetReleaseResultSet() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:13
msgid "a handle to the data source on which was executed an SQL query."
msgstr ""

#: of osgeo.ogr.DataSource.ReleaseResultSet:14
msgid "handle to the result of a previous OGR_DS_ExecuteSQL() call."
msgstr ""

#: of osgeo.ogr.DataSource.SetStyleTable:1
msgid "void OGR_DS_SetStyleTable(OGRDataSourceH hDS, OGRStyleTableH hStyleTable)"
msgstr ""

#: of osgeo.ogr.DataSource.SetStyleTable:4 osgeo.ogr.Layer.SetStyleTable:1
msgid "Set style table."
msgstr ""

#: of osgeo.ogr.DataSource.SyncToDisk:1
msgid "OGRErr OGR_DS_SyncToDisk(OGRDataSourceH hDS)"
msgstr ""

#: of osgeo.ogr.DataSource.SyncToDisk:4 osgeo.ogr.Layer.SyncToDisk:1
msgid "Flush pending changes to disk."
msgstr ""

#: of osgeo.ogr.DataSource.SyncToDisk:6
msgid "See GDALDataset::FlushCache()"
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:1
msgid "int OGR_DS_TestCapability(OGRDataSourceH hDS, const char \\*pszCapability)"
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:4
msgid "Test if capability is available."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:6
msgid ""
"One of the following data source capability names can be passed into this"
" function, and a TRUE or FALSE value will be returned indicating whether "
"or not the capability is available for this object."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:10
msgid "ODsCCreateLayer: True if this datasource can create new layers."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:12
msgid "ODsCDeleteLayer: True if this datasource can delete existing layers."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:14
msgid ""
"ODsCCreateGeomFieldAfterCreateLayer: True if the layers of this "
"datasource support CreateGeomField() just after layer creation."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:17
msgid ""
"ODsCCurveGeometries: True if this datasource supports writing curve "
"geometries. (GDAL 2.0). In that case, OLCCurveGeometries must also be "
"declared in layers of that dataset."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:21
msgid ""
"The #define macro forms of the capability names should be used in "
"preference to the strings themselves to avoid misspelling."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:24
msgid "Deprecated Use GDALDatasetTestCapability() in GDAL 2.0"
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:26
msgid "handle to the data source against which to test the capability."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:27
msgid "the capability to test."
msgstr ""

#: of osgeo.ogr.DataSource.TestCapability:29
msgid "TRUE if capability available otherwise FALSE."
msgstr ""

#: of osgeo.gdal.Driver.HelpTopic:1 osgeo.gdal.Driver.LongName:1
#: osgeo.gdal.Driver.ShortName:1 osgeo.ogr.DataSource.name:1
#: osgeo.ogr.Driver.name:1
msgid "p.q(const).char"
msgstr ""

#: of osgeo.ogr.Driver:1
msgid "Proxy of C++ OGRDriverShadow class."
msgstr ""

#: of osgeo.ogr.GeomTransformer:1
msgid "Proxy of C++ OGRGeomTransformerShadow class."
msgstr ""

#: of osgeo.ogr.PreparedGeometry:1
msgid "Proxy of C++ OGRPreparedGeometryShadow class."
msgstr ""

#: ../../source/api/python/osgeo.osr.rst:7
msgid "osgeo.osr module"
msgstr ""

#: of osgeo.osr.AreaOfUse:1
msgid "Proxy of C++ OSRAreaOfUse class."
msgstr ""

#: of osgeo.osr.AreaOfUse.east_lon_degree:3 osgeo.osr.CRSInfo.east_lon_degree:3
msgid "east_lon_degree"
msgstr ""

#: of osgeo.osr.AreaOfUse.north_lat_degree:3
#: osgeo.osr.CRSInfo.north_lat_degree:3
msgid "north_lat_degree"
msgstr ""

#: of osgeo.osr.AreaOfUse.south_lat_degree:3
#: osgeo.osr.CRSInfo.south_lat_degree:3
msgid "south_lat_degree"
msgstr ""

#: of osgeo.osr.AreaOfUse.west_lon_degree:3 osgeo.osr.CRSInfo.west_lon_degree:3
msgid "west_lon_degree"
msgstr ""

#: of osgeo.osr.CRSInfo:1
msgid "Proxy of C++ OSRCRSInfo class."
msgstr ""

#: of osgeo.osr.CRSInfo.area_name:3
msgid "area_name"
msgstr ""

#: of osgeo.osr.CRSInfo.auth_name:3
msgid "auth_name"
msgstr ""

#: of osgeo.osr.CRSInfo.bbox_valid:3
msgid "bbox_valid"
msgstr ""

#: of osgeo.osr.CRSInfo.code:3
msgid "code"
msgstr ""

#: of osgeo.osr.CRSInfo.deprecated:3
msgid "deprecated"
msgstr ""

#: of osgeo.osr.CRSInfo.projection_method:3
msgid "projection_method"
msgstr ""

#: of osgeo.osr.CRSInfo.type:1
msgid "OSRCRSType"
msgstr ""

#: ../../source/api/python/raster_api.rst:9
msgid "Python Raster API"
msgstr ""

#: ../../source/api/python/raster_api.rst:11
msgid ""
"This page contains classes, methods, functions that relate to the GDAL "
":ref:`raster_data_model`:"
msgstr ""

#: ../../source/api/python/raster_api.rst:13
msgid "`Driver`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:14
msgid "`Dataset`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:15
msgid "`Band`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:16
msgid "`Other`_"
msgstr ""

#: ../../source/api/python/raster_api.rst:21
msgid "Driver"
msgstr ""

#: of osgeo.gdal.Driver:1
msgid "Proxy of C++ GDALDriverShadow class."
msgstr ""

#: of osgeo.gdal.Driver.HelpTopic:3
msgid "HelpTopic"
msgstr ""

#: of osgeo.gdal.Driver.LongName:3
msgid "LongName"
msgstr ""

#: of osgeo.gdal.Driver.ShortName:3
msgid "ShortName"
msgstr ""

#: ../../source/api/python/raster_api.rst:41
msgid "Dataset"
msgstr ""

#: of osgeo.gdal.Dataset:1
msgid "Proxy of C++ GDALDatasetShadow class."
msgstr ""

#: of osgeo.gdal.Dataset.DeleteLayer:1
msgid "Deletes the layer given an index or layer name"
msgstr ""

#: of osgeo.gdal.Dataset.GetTiledVirtualMemArray:1
msgid ""
"Return a NumPy array for the dataset, seen as a virtual memory mapping "
"with a tile organization. If there are several bands and "
"tile_organization = gdal.GTO_TIP, an element is accessed with "
"array[tiley][tilex][y][x][band]. If there are several bands and "
"tile_organization = gdal.GTO_BIT, an element is accessed with "
"array[tiley][tilex][band][y][x]. If there are several bands and "
"tile_organization = gdal.GTO_BSQ, an element is accessed with "
"array[band][tiley][tilex][y][x]. If there is only one band, an element is"
" accessed with array[tiley][tilex][y][x]. Any reference to the array must"
" be dropped before the last reference to the related dataset is also "
"dropped."
msgstr ""

#: of osgeo.gdal.Dataset.GetVirtualMemArray:1
msgid ""
"Return a NumPy array for the dataset, seen as a virtual memory mapping. "
"If there are several bands and band_sequential = True, an element is "
"accessed with array[band][y][x]. If there are several bands and "
"band_sequential = False, an element is accessed with array[y][x][band]. "
"If there is only one band, an element is accessed with array[y][x]. Any "
"reference to the array must be dropped before the last reference to the "
"related dataset is also dropped."
msgstr ""

#: of osgeo.gdal.Dataset.RasterCount:3
msgid "RasterCount"
msgstr ""

#: of osgeo.gdal.Dataset.RasterXSize:3
msgid "RasterXSize"
msgstr ""

#: of osgeo.gdal.Dataset.RasterYSize:3
msgid "RasterYSize"
msgstr ""

#: of osgeo.gdal.Band.ReadAsArray:1 osgeo.gdal.Dataset.ReadAsArray:1
msgid ""
"Reading a chunk of a GDAL band into a numpy array. The optional "
"(buf_xsize,buf_ysize,buf_type) parameters should generally not be "
"specified if buf_obj is specified. The array is returned"
msgstr ""

#: ../../source/api/python/raster_api.rst:55
msgid "Band"
msgstr ""

#: of osgeo.gdal.Band:1
msgid "Proxy of C++ GDALRasterBandShadow class."
msgstr ""

#: of osgeo.gdal.Band.DataType:1
msgid "GDALDataType"
msgstr ""

#: of osgeo.gdal.Band.DataType:3
msgid "DataType"
msgstr ""

#: of osgeo.gdal.Band.GetTiledVirtualMemArray:1
msgid ""
"Return a NumPy array for the band, seen as a virtual memory mapping with "
"a tile organization. An element is accessed with "
"array[tiley][tilex][y][x]. Any reference to the array must be dropped "
"before the last reference to the related dataset is also dropped."
msgstr ""

#: of osgeo.gdal.Band.GetVirtualMemArray:1
#: osgeo.gdal.Band.GetVirtualMemAutoArray:1
msgid ""
"Return a NumPy array for the band, seen as a virtual memory mapping. An "
"element is accessed with array[y][x]. Any reference to the array must be "
"dropped before the last reference to the related dataset is also dropped."
msgstr ""

#: of osgeo.gdal.Band.XSize:3
msgid "XSize"
msgstr ""

#: of osgeo.gdal.Band.YSize:3
msgid "YSize"
msgstr ""

#: ../../source/api/python/raster_api.rst:67
msgid "Other"
msgstr ""

#: of osgeo.gdal.RasterAttributeTable:1
msgid "Proxy of C++ GDALRasterAttributeTableShadow class."
msgstr ""

#: of osgeo.gdal.ColorTable:1
msgid "Proxy of C++ GDALColorTableShadow class."
msgstr ""

#: of osgeo.gdal.ColorEntry:1
msgid "Proxy of C++ GDALColorEntry class."
msgstr ""

#: of osgeo.gdal.ColorEntry.c1:1 osgeo.gdal.ColorEntry.c2:1
#: osgeo.gdal.ColorEntry.c3:1 osgeo.gdal.ColorEntry.c4:1
msgid "short"
msgstr ""

#: of osgeo.gdal.ColorEntry.c1:3
msgid "c1"
msgstr ""

#: of osgeo.gdal.ColorEntry.c2:3
msgid "c2"
msgstr ""

#: of osgeo.gdal.ColorEntry.c3:3
msgid "c3"
msgstr ""

#: of osgeo.gdal.ColorEntry.c4:3
msgid "c4"
msgstr ""

#: of osgeo.gdal.GCP:1
msgid "Proxy of C++ GDAL_GCP class."
msgstr ""

#: of osgeo.gdal.GCP.GCPLine:3
msgid "GCPLine"
msgstr ""

#: of osgeo.gdal.GCP.GCPPixel:3
msgid "GCPPixel"
msgstr ""

#: of osgeo.gdal.GCP.GCPX:3
msgid "GCPX"
msgstr ""

#: of osgeo.gdal.GCP.GCPY:3
msgid "GCPY"
msgstr ""

#: of osgeo.gdal.GCP.GCPZ:3
msgid "GCPZ"
msgstr ""

#: of osgeo.gdal.GCP.Id:3
msgid "Id"
msgstr ""

#: of osgeo.gdal.GCP.Info:3
msgid "Info"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:9
msgid "Python Spatial Reference System API"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:11
msgid ""
"This page contains classes, methods and functions that relate to spatial "
"reference systems:"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:13
msgid "`SpatialReference`_"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:14
msgid "`CoordinateTransformation`_"
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:17
msgid "SpatialReference"
msgstr ""

#: of osgeo.osr.SpatialReference:1
msgid "Proxy of C++ OSRSpatialReferenceShadow class."
msgstr ""

#: ../../source/api/python/spatial_ref_api.rst:25
msgid "CoordinateTransformation"
msgstr ""

#: of osgeo.osr.CoordinateTransformation:1
msgid "Proxy of C++ OSRCoordinateTransformationShadow class."
msgstr ""

#: of osgeo.osr.CoordinateTransformationOptions:1
msgid "Proxy of C++ OGRCoordinateTransformationOptions class."
msgstr ""

#: ../../source/api/python/utilities.rst:9
msgid "Python Utilities"
msgstr ""

#: ../../source/api/python/utilities.rst:12
msgid "Raster Utilities"
msgstr ""

#: of osgeo.gdal.BuildVRT:1
msgid "Build a VRT from a list of datasets."
msgstr ""

#: of osgeo.gdal.BuildVRT:3
msgid "Output dataset name."
msgstr ""

#: of osgeo.gdal.BuildVRT:4
msgid ""
"An array of Dataset objects or filenames, or a Dataset object or a "
"filename."
msgstr ""

#: of osgeo.gdal.BuildVRT:5
msgid ""
"options: return of gdal.BuildVRTOptions(), string or array of strings, "
"other keywords arguments of gdal.BuildVRTOptions(). If options is "
"provided as a gdal.BuildVRTOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:1
msgid "Create a BuildVRTOptions() object that can be passed to gdal.BuildVRT()"
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:3 osgeo.gdal.DEMProcessingOptions:3
#: osgeo.gdal.GridOptions:3 osgeo.gdal.MultiDimTranslateOptions:3
#: osgeo.gdal.NearblackOptions:3 osgeo.gdal.RasterizeOptions:3
#: osgeo.gdal.TranslateOptions:3 osgeo.gdal.VectorTranslateOptions:3
#: osgeo.gdal.WarpOptions:3
msgid ""
"can be be an array of strings, a string or let empty and filled from "
"other keywords."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:5
msgid "'highest', 'lowest', 'average', 'user'."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:6
msgid "output bounds as (minX, minY, maxX, maxY) in target SRS."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:8 osgeo.gdal.BuildVRTOptions:9
msgid "output resolution in target SRS."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:10
msgid "whether to force output bounds to be multiple of output resolution."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:11
msgid ""
"whether each source file goes into a separate stacked band in the VRT "
"band."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:12
msgid "array of band numbers (index start at 1)."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:13
msgid ""
"whether to add an alpha mask band to the VRT when the source raster have "
"none."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:14
msgid "resampling mode."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:15
msgid "assigned output SRS."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:16
msgid ""
"whether to accept input datasets have not the same projection. Note: they"
" will *not* be reprojected."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:18
msgid "source nodata value(s)."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:19
msgid "nodata values at the VRT band level."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:20
msgid "whether to make the VRT band not report the NoData value."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:21
msgid "set to True if warnings should be failures"
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:22
msgid "callback method."
msgstr ""

#: of osgeo.gdal.BuildVRTOptions:23
msgid "user data for callback."
msgstr ""

#: of osgeo.gdal.DEMProcessing:1
msgid "Apply a DEM processing."
msgstr ""

#: of osgeo.gdal.DEMProcessing:3 osgeo.gdal.Grid:3
#: osgeo.gdal.MultiDimTranslate:3 osgeo.gdal.Translate:3
msgid "Output dataset name"
msgstr ""

#: of osgeo.gdal.DEMProcessing:4 osgeo.gdal.Grid:4 osgeo.gdal.Info:3
#: osgeo.gdal.MultiDimInfo:3 osgeo.gdal.Nearblack:4 osgeo.gdal.Rasterize:4
#: osgeo.gdal.Translate:4 osgeo.gdal.VectorTranslate:4
msgid "a Dataset object or a filename"
msgstr ""

#: of osgeo.gdal.DEMProcessing:5
msgid ""
"one of \"hillshade\", \"slope\", \"aspect\", \"color-relief\", \"TRI\", "
"\"TPI\", \"Roughness\""
msgstr ""

#: of osgeo.gdal.DEMProcessing:6
msgid ""
"options: return of gdal.DEMProcessingOptions(), string or array of "
"strings, other keywords arguments of gdal.DEMProcessingOptions(). If "
"options is provided as a gdal.DEMProcessingOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:1
msgid ""
"Create a DEMProcessingOptions() object that can be passed to "
"gdal.DEMProcessing()"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:4
msgid ""
"(mandatory for \"color-relief\") name of file that contains palette "
"definition for the \"color-relief\" processing."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:5 osgeo.gdal.GridOptions:4
#: osgeo.gdal.MultiDimTranslateOptions:4 osgeo.gdal.NearblackOptions:4
#: osgeo.gdal.RasterizeOptions:4 osgeo.gdal.TranslateOptions:4
#: osgeo.gdal.WarpOptions:4
msgid "output format (\"GTiff\", etc...)"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:6 osgeo.gdal.GridOptions:8
#: osgeo.gdal.MultiDimTranslateOptions:5 osgeo.gdal.NearblackOptions:5
#: osgeo.gdal.RasterizeOptions:6 osgeo.gdal.TranslateOptions:14
#: osgeo.gdal.WarpOptions:23
msgid "list of creation options"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:7
msgid "whether to compute values at raster edges."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:8
msgid ""
"'Horn' (default) or 'ZevenbergenThorne' for hillshade, slope or aspect. "
"'Wilson' (default) or 'Riley' for TRI"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:9
msgid "source band number to use"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:10
msgid ""
"(hillshade only) vertical exaggeration used to pre-multiply the "
"elevations."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:11
msgid "ratio of vertical units to horizontal."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:12
msgid ""
"(hillshade only) azimuth of the light, in degrees. 0 if it comes from the"
" top of the raster, 90 from the east, ... The default value, 315, should "
"rarely be changed as it is the value generally used to generate shaded "
"maps."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:13
msgid ""
"(hillshade only) altitude of the light, in degrees. 90 if the light comes"
" from above the DEM, 0 if it is raking light."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:14
msgid ""
"(hillshade only) whether to compute combined shading, a combination of "
"slope and oblique shading. Only one of combined, multiDirectional and "
"igor can be specified."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:15
msgid ""
"(hillshade only) whether to compute multi-directional shading. Only one "
"of combined, multiDirectional and igor can be specified."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:16
msgid ""
"(hillshade only) whether to use Igor's hillshading from Maperitive.  Only"
" one of combined, multiDirectional and igor can be specified."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:17
msgid "(slope only) \"degree\" or \"percent\"."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:18
msgid ""
"(aspect only) whether to return trigonometric angle instead of azimuth. "
"Thus 0deg means East, 90deg North, 180deg West, 270deg South."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:19
msgid ""
"(aspect only) whether to return 0 for flat areas with slope=0, instead of"
" -9999."
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:20
msgid ""
"adds an alpha band to the output file (only for processing = 'color-"
"relief')"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:21
msgid ""
"(color-relief only) Determines how color entries are selected from an "
"input value. Can be \"nearest_color_entry\", \"exact_color_entry\" or "
"\"linear_interpolation\". Defaults to \"linear_interpolation\""
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:22 osgeo.gdal.GridOptions:26
#: osgeo.gdal.MultiDimTranslateOptions:14 osgeo.gdal.NearblackOptions:12
#: osgeo.gdal.RasterizeOptions:41 osgeo.gdal.TranslateOptions:34
#: osgeo.gdal.VectorTranslateOptions:31 osgeo.gdal.WarpOptions:42
msgid "callback method"
msgstr ""

#: of osgeo.gdal.DEMProcessingOptions:23 osgeo.gdal.GridOptions:27
#: osgeo.gdal.MultiDimTranslateOptions:15 osgeo.gdal.NearblackOptions:13
#: osgeo.gdal.RasterizeOptions:42 osgeo.gdal.TranslateOptions:35
#: osgeo.gdal.VectorTranslateOptions:32 osgeo.gdal.WarpOptions:43
msgid "user data for callback"
msgstr ""

#: of osgeo.gdal.Grid:1
msgid "Create raster from the scattered data."
msgstr ""

#: of osgeo.gdal.Grid:5
msgid ""
"options: return of gdal.GridOptions(), string or array of strings, other "
"keywords arguments of gdal.GridOptions() If options is provided as a "
"gdal.GridOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.GridOptions:1
msgid "Create a GridOptions() object that can be passed to gdal.Grid()"
msgstr ""

#: of osgeo.gdal.GridOptions:5 osgeo.gdal.RasterizeOptions:5
#: osgeo.gdal.TranslateOptions:5 osgeo.gdal.WarpOptions:17
msgid "output type (gdalconst.GDT_Byte, etc...)"
msgstr ""

#: of osgeo.gdal.GridOptions:6 osgeo.gdal.RasterizeOptions:11
#: osgeo.gdal.TranslateOptions:8 osgeo.gdal.WarpOptions:10
msgid "width of the output raster in pixel"
msgstr ""

#: of osgeo.gdal.GridOptions:7 osgeo.gdal.RasterizeOptions:12
#: osgeo.gdal.TranslateOptions:9 osgeo.gdal.WarpOptions:11
msgid "height of the output raster in pixel"
msgstr ""

#: of osgeo.gdal.GridOptions:9 osgeo.gdal.TranslateOptions:22
msgid "assigned output bounds: [ulx, uly, lrx, lry]"
msgstr ""

#: of osgeo.gdal.GridOptions:11 osgeo.gdal.RasterizeOptions:9
#: osgeo.gdal.TranslateOptions:24
msgid "assigned output SRS"
msgstr ""

#: of osgeo.gdal.GridOptions:12 osgeo.gdal.RasterizeOptions:16
msgid "nodata value"
msgstr ""

#: of osgeo.gdal.GridOptions:13
msgid ""
"e.g "
"\"invdist:power=2.0:smoothing=0.0:radius1=0.0:radius2=0.0:angle=0.0:max_points=0:min_points=0:nodata=0.0\""
msgstr ""

#: of osgeo.gdal.GridOptions:14 osgeo.gdal.VectorTranslateOptions:21
msgid "list of layers to convert"
msgstr ""

#: of osgeo.gdal.GridOptions:15 osgeo.gdal.RasterizeOptions:36
#: osgeo.gdal.VectorTranslateOptions:10
msgid "SQL statement to apply to the source dataset"
msgstr ""

#: of osgeo.gdal.GridOptions:16 osgeo.gdal.RasterizeOptions:38
#: osgeo.gdal.VectorTranslateOptions:12
msgid "WHERE clause to apply to source layer(s)"
msgstr ""

#: of osgeo.gdal.GridOptions:17 osgeo.gdal.VectorTranslateOptions:17
msgid "spatial filter as (minX, minY, maxX, maxY) bounding box"
msgstr ""

#: of osgeo.gdal.GridOptions:18
msgid ""
"Identifies an attribute field on the features to be used to get a Z value"
" from. This value overrides Z value read from feature geometry record."
msgstr ""

#: of osgeo.gdal.GridOptions:20
msgid ""
"Addition to the attribute field on the features to be used to get a Z "
"value from. The addition should be the same unit as Z value. The result "
"value will be Z value + Z increase value. The default value is 0."
msgstr ""

#: of osgeo.gdal.GridOptions:23
msgid ""
"Multiplication ratio for Z field. This can be used for shift from e.g. "
"foot to meters or from  elevation to deep. The result value will be (Z "
"value + Z increase value) * Z multiply value. The default value is 1."
msgstr ""

#: of osgeo.gdal.Info:1 osgeo.gdal.MultiDimInfo:1
msgid "Return information on a dataset."
msgstr ""

#: of osgeo.gdal.Info:4
msgid ""
"options: return of gdal.InfoOptions(), string or array of strings other "
"keywords arguments of gdal.InfoOptions(). If options is provided as a "
"gdal.InfoOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.InfoOptions:1
msgid ""
"Create a InfoOptions() object that can be passed to gdal.Info() options "
"can be be an array of strings, a string or let empty and filled from "
"other keywords."
msgstr ""

#: of osgeo.gdal.Nearblack:1
msgid "Convert nearly black/white borders to exact value."
msgstr ""

#: of osgeo.gdal.Nearblack:3 osgeo.gdal.Rasterize:3
#: osgeo.gdal.VectorTranslate:3 osgeo.gdal.Warp:3
msgid "Output dataset name or object"
msgstr ""

#: of osgeo.gdal.Nearblack:5
msgid ""
"options: return of gdal.NearblackOptions(), string or array of strings, "
"other keywords arguments of gdal.NearblackOptions(). If options is "
"provided as a gdal.NearblackOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.NearblackOptions:1
msgid "Create a NearblackOptions() object that can be passed to gdal.Nearblack()"
msgstr ""

#: of osgeo.gdal.NearblackOptions:6
msgid ""
"whether to search for nearly white (255) pixels instead of nearly black "
"pixels."
msgstr ""

#: of osgeo.gdal.NearblackOptions:7
msgid ""
"list of colors  to search for, e.g. ((0,0,0),(255,255,255)). The pixels "
"that are considered as the collar are set to 0"
msgstr ""

#: of osgeo.gdal.NearblackOptions:8
msgid ""
"number of non-black (or other searched colors specified with white / "
"colors) pixels that can be encountered before the giving up search "
"inwards. Defaults to 2."
msgstr ""

#: of osgeo.gdal.NearblackOptions:9
msgid ""
"select how far from black, white or custom colors the pixel values can be"
" and still considered near black, white or custom color.  Defaults to 15."
msgstr ""

#: of osgeo.gdal.NearblackOptions:10
msgid "adds an alpha band to the output file."
msgstr ""

#: of osgeo.gdal.NearblackOptions:11
msgid "adds a mask band to the output file."
msgstr ""

#: of osgeo.gdal.Rasterize:1
msgid "Burns vector geometries into a raster"
msgstr ""

#: of osgeo.gdal.Rasterize:5
msgid ""
"options: return of gdal.RasterizeOptions(), string or array of strings, "
"other keywords arguments of gdal.RasterizeOptions() If options is "
"provided as a gdal.RasterizeOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:1
msgid "Create a RasterizeOptions() object that can be passed to gdal.Rasterize()"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:7
msgid "assigned output bounds: [minx, miny, maxx, maxy]"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:10 osgeo.gdal.WarpOptions:31
msgid "list of transformer options"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:13 osgeo.gdal.RasterizeOptions:14
#: osgeo.gdal.WarpOptions:7 osgeo.gdal.WarpOptions:8
msgid "output resolution in target SRS"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:15 osgeo.gdal.WarpOptions:9
msgid "whether to force output bounds to be multiple of output resolution"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:17
msgid ""
"Value or list of values to pre-initialize the output image bands with.  "
"However, it is not marked as the nodata value in the output file.   If "
"only one value is given, the same value is used in all the bands."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:19
msgid "Value or list of values to pre-initialize the output image bands with."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:19
msgid "However, it is not marked as the nodata value in the output file."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:20
msgid "If only one value is given, the same value is used in all the bands."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:21
msgid "list of output bands to burn values into"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:22
msgid ""
"whether to invert rasterization, i.e. burn the fixed burn value, or the "
"burn value associated with the first feature into all parts of the image "
"not inside the provided a polygon."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:25
msgid ""
"whether to enable the ALL_TOUCHED rasterization option so that all pixels"
" touched by lines or polygons will be updated, not just those on the line"
" render path, or whose center point is within the polygon."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:28
msgid ""
"list of fixed values to burn into each band for all objects. Excusive "
"with attribute."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:30
msgid ""
"identifies an attribute field on the features to be used for a burn-in "
"value. The value will be burned into all output bands. Excusive with "
"burnValues."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:32
msgid ""
"whether to indicate that a burn value should be extracted from the \"Z\" "
"values of the feature. These values are added to the burn value given by "
"burnValues or attribute if provided. As of now, only points and lines are"
" drawn in 3D."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:35
msgid "list of layers from the datasource that will be used for input features."
msgstr ""

#: of osgeo.gdal.RasterizeOptions:37 osgeo.gdal.VectorTranslateOptions:11
msgid "SQL dialect ('OGRSQL', 'SQLITE', ...)"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:39
msgid "optimization mode ('RASTER', 'VECTOR')"
msgstr ""

#: of osgeo.gdal.RasterizeOptions:40
msgid "set to True to use additive mode instead of replace when burning values"
msgstr ""

#: of osgeo.gdal.Translate:1
msgid "Convert a dataset."
msgstr ""

#: of osgeo.gdal.Translate:5
msgid ""
"options: return of gdal.TranslateOptions(), string or array of strings "
"other keywords arguments of gdal.TranslateOptions(). If options is "
"provided as a gdal.TranslateOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.TranslateOptions:1
msgid "Create a TranslateOptions() object that can be passed to gdal.Translate()"
msgstr ""

#: of osgeo.gdal.TranslateOptions:6
msgid "array of band numbers (index start at 1)"
msgstr ""

#: of osgeo.gdal.TranslateOptions:7
msgid "mask band to generate or not (\"none\", \"auto\", \"mask\", 1, ...)"
msgstr ""

#: of osgeo.gdal.TranslateOptions:10
msgid "width of the output raster in percentage (100 = original width)"
msgstr ""

#: of osgeo.gdal.TranslateOptions:11
msgid "height of the output raster in percentage (100 = original height)"
msgstr ""

#: of osgeo.gdal.TranslateOptions:12
msgid "output horizontal resolution"
msgstr ""

#: of osgeo.gdal.TranslateOptions:13
msgid "output vertical resolution"
msgstr ""

#: of osgeo.gdal.TranslateOptions:15
msgid "subwindow in pixels to extract: [left_x, top_y, width, height]"
msgstr ""

#: of osgeo.gdal.TranslateOptions:16
msgid "subwindow in projected coordinates to extract: [ulx, uly, lrx, lry]"
msgstr ""

#: of osgeo.gdal.TranslateOptions:17
msgid "SRS in which projWin is expressed"
msgstr ""

#: of osgeo.gdal.TranslateOptions:18
msgid "strict mode"
msgstr ""

#: of osgeo.gdal.TranslateOptions:19
msgid "unscale values with scale and offset metadata"
msgstr ""

#: of osgeo.gdal.TranslateOptions:20
msgid ""
"list of scale parameters, each of the form [src_min,src_max] or "
"[src_min,src_max,dst_min,dst_max]"
msgstr ""

#: of osgeo.gdal.TranslateOptions:21
msgid "list of exponentiation parameters"
msgstr ""

#: of osgeo.gdal.TranslateOptions:23
msgid "list of metadata options"
msgstr ""

#: of osgeo.gdal.TranslateOptions:25
msgid "ignore GCP in the raster"
msgstr ""

#: of osgeo.gdal.TranslateOptions:26
msgid "list of GCPs"
msgstr ""

#: of osgeo.gdal.TranslateOptions:27
msgid "nodata value (or \"none\" to unset it)"
msgstr ""

#: of osgeo.gdal.TranslateOptions:28
msgid "Color palette expansion mode: \"gray\", \"rgb\", \"rgba\""
msgstr ""

#: of osgeo.gdal.TranslateOptions:29
msgid "whether to calculate statistics"
msgstr ""

#: of osgeo.gdal.TranslateOptions:30
msgid "whether to write source RAT"
msgstr ""

#: of osgeo.gdal.TranslateOptions:31
msgid "whether to copy XMP metadata"
msgstr ""

#: of osgeo.gdal.TranslateOptions:32 osgeo.gdal.WarpOptions:22
msgid "resampling mode"
msgstr ""

#: of osgeo.gdal.TranslateOptions:33 osgeo.gdal.WarpOptions:41
msgid "To specify which overview level of source files must be used"
msgstr ""

#: of osgeo.gdal.Warp:1
msgid "Warp one or several datasets."
msgstr ""

#: of osgeo.gdal.MultiDimTranslate:4 osgeo.gdal.Warp:4
msgid ""
"an array of Dataset objects or filenames, or a Dataset object or a "
"filename"
msgstr ""

#: of osgeo.gdal.Warp:5
msgid ""
"options: return of gdal.WarpOptions(), string or array of strings, other "
"keywords arguments of gdal.WarpOptions(). If options is provided as a "
"gdal.WarpOptions() object, other keywords are ignored."
msgstr ""

#: of osgeo.gdal.WarpOptions:1
msgid "Create a WarpOptions() object that can be passed to gdal.Warp()"
msgstr ""

#: of osgeo.gdal.WarpOptions:5
msgid "output bounds as (minX, minY, maxX, maxY) in target SRS"
msgstr ""

#: of osgeo.gdal.WarpOptions:6
msgid ""
"SRS in which output bounds are expressed, in the case they are not "
"expressed in dstSRS"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:6 osgeo.gdal.WarpOptions:12
msgid "source SRS"
msgstr ""

#: of osgeo.gdal.WarpOptions:13
msgid "output SRS"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:8 osgeo.gdal.WarpOptions:14
msgid "coordinate operation as a PROJ string or WKT string"
msgstr ""

#: of osgeo.gdal.WarpOptions:15
msgid ""
"whether to force the last band of the input dataset to be considered as "
"an alpha band"
msgstr ""

#: of osgeo.gdal.WarpOptions:16
msgid "whether to force the creation of an output alpha band"
msgstr ""

#: of osgeo.gdal.WarpOptions:18
msgid "working type (gdalconst.GDT_Byte, etc...)"
msgstr ""

#: of osgeo.gdal.WarpOptions:19
msgid "list of warping options"
msgstr ""

#: of osgeo.gdal.WarpOptions:20
msgid "error threshold for approximation transformer (in pixels)"
msgstr ""

#: of osgeo.gdal.WarpOptions:21
msgid "size of working buffer in MB"
msgstr ""

#: of osgeo.gdal.WarpOptions:24
msgid "source nodata value(s)"
msgstr ""

#: of osgeo.gdal.WarpOptions:25
msgid "output nodata value(s)"
msgstr ""

#: of osgeo.gdal.WarpOptions:26
msgid "whether to multithread computation and I/O operations"
msgstr ""

#: of osgeo.gdal.WarpOptions:27
msgid "whether to use Thin Plate Spline GCP transformer"
msgstr ""

#: of osgeo.gdal.WarpOptions:28
msgid "whether to use RPC transformer"
msgstr ""

#: of osgeo.gdal.WarpOptions:29
msgid "whether to use GeoLocation array transformer"
msgstr ""

#: of osgeo.gdal.WarpOptions:30
msgid "order of polynomial GCP interpolation"
msgstr ""

#: of osgeo.gdal.WarpOptions:32
msgid "cutline dataset name"
msgstr ""

#: of osgeo.gdal.WarpOptions:33
msgid "cutline layer name"
msgstr ""

#: of osgeo.gdal.WarpOptions:34
msgid "cutline WHERE clause"
msgstr ""

#: of osgeo.gdal.WarpOptions:35
msgid "cutline SQL statement"
msgstr ""

#: of osgeo.gdal.WarpOptions:36
msgid "cutline blend distance in pixels"
msgstr ""

#: of osgeo.gdal.WarpOptions:37
msgid "whether to use cutline extent for output bounds"
msgstr ""

#: of osgeo.gdal.WarpOptions:38
msgid "whether to copy source metadata"
msgstr ""

#: of osgeo.gdal.WarpOptions:39
msgid "metadata data conflict value"
msgstr ""

#: of osgeo.gdal.WarpOptions:40
msgid "whether to force color interpretation of input bands to output bands"
msgstr ""

#: ../../source/api/python/utilities.rst:75
msgid "Multidimensional Raster Utilities"
msgstr ""

#: of osgeo.gdal.MultiDimInfo:4
msgid ""
"options: return of gdal.MultiDimInfoOptions(), string or array of strings"
" other keywords arguments of gdal.MultiDimInfoOptions(). If options is "
"provided as a gdal.MultiDimInfoOptions() object, other keywords are "
"ignored."
msgstr ""

#: of osgeo.gdal.MultiDimInfoOptions:1
msgid ""
"Create a MultiDimInfoOptions() object that can be passed to "
"gdal.MultiDimInfo() options can be be an array of strings, a string or "
"let empty and filled from other keywords."
msgstr ""

#: of osgeo.gdal.MultiDimTranslate:1
msgid "MultiDimTranslate one or several datasets."
msgstr ""

#: of osgeo.gdal.MultiDimTranslate:5
msgid ""
"options: return of gdal.MultiDimTranslateOptions(), string or array of "
"strings other keywords arguments of gdal.MultiDimTranslateOptions(). If "
"options is provided as a gdal.MultiDimTranslateOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:1
msgid ""
"Create a MultiDimTranslateOptions() object that can be passed to "
"gdal.MultiDimTranslate()"
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:6
msgid ""
"list of array specifications, each of them being an array name or "
"\"name={src_array_name},dstname={dst_name},transpose=[1,0],view=[:,::-1]\""
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:8
msgid ""
"list of group specifications, each of them being a group name or "
"\"name={src_array_name},dstname={dst_name},recursive=no\""
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:10
msgid ""
"list of subset specifications, each of them being like "
"\"{dim_name}({min_val},{max_val})\" or \"{dim_name}({slice_va})\""
msgstr ""

#: of osgeo.gdal.MultiDimTranslateOptions:12
msgid ""
"list of dimension scaling specifications, each of them being like "
"\"{dim_name}({scale_factor})\""
msgstr ""

#: ../../source/api/python/utilities.rst:86
msgid "Vector Utilities"
msgstr ""

#: of osgeo.gdal.VectorTranslate:1
msgid "Convert one vector dataset"
msgstr ""

#: of osgeo.gdal.VectorTranslate:5
msgid ""
"options: return of gdal.VectorTranslateOptions(), string or array of "
"strings, other keywords arguments of gdal.VectorTranslateOptions(). If "
"options is provided as a gdal.VectorTranslateOptions() object, other "
"keywords are ignored."
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:1
msgid ""
"Create a VectorTranslateOptions() object that can be passed to "
"gdal.VectorTranslate()"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:4
msgid "format (\"ESRI Shapefile\", etc...)"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:5
msgid "None for creation, 'update', 'append', 'upsert', 'overwrite'"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:7
msgid "output SRS (with reprojection if reproject = True)"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:9
msgid "whether to do reprojection"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:13
msgid "list of fields to select"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:14
msgid ""
"whether to add new fields found in source layers (to be used with "
"accessMode == 'append' or 'upsert')"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:15
msgid "whether to drop NOT NULL constraints on newly created fields"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:16
msgid "whether to treat empty string values as NULL"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:18
msgid ""
"SRS in which the spatFilter is expressed. If not specified, it is assumed"
" to be the one of the layer(s)"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:19
msgid "list of dataset creation options"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:20
msgid "list of layer creation options"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:22
msgid "output layer name"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:23
msgid "output layer geometry type ('POINT', ....)"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:24
msgid "output dimension ('XY', 'XYZ', 'XYM', 'XYZM', 'layer_dim')"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:25
msgid "maximum distance between consecutive nodes of a line geometry"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:26
msgid "run MakeValid() on geometries"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:27
msgid "name of field to use to set the Z component of geometries"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:28
msgid ""
"whether to create an additional field for each field associated with a "
"coded field domain."
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:29
msgid "whether to skip failures"
msgstr ""

#: of osgeo.gdal.VectorTranslateOptions:30
msgid "maximum number of features to read per layer"
msgstr ""

#: ../../source/api/python/vector_api.rst:9
msgid "Python Vector API"
msgstr ""

#: ../../source/api/python/vector_api.rst:11
msgid ""
"This page contains classes, methods, functions that relate to the GDAL "
":ref:`vector_data_model`. The :py:class:`Driver` and :py:class:`Dataset` "
"classes, which applies to both vector and raster data, are documented "
"with the :ref:`python_raster_api`."
msgstr ""

#: ../../source/api/python/vector_api.rst:13
msgid "`Layer`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:14
msgid "`Feature`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:15
msgid "`Geometry`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:16
msgid "`FeatureDefn`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:17
msgid "`FieldDefn`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:18
msgid "`GeomFieldDefn`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:19
msgid "`FieldDomain`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:20
msgid "`Relationship`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:21
msgid "`StyleTable`_"
msgstr ""

#: ../../source/api/python/vector_api.rst:24
msgid "Layer"
msgstr ""

#: of osgeo.ogr.Layer:1
msgid "Proxy of C++ OGRLayerShadow class."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:1
msgid "Alter the definition of an existing field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:3
msgid "For more details: :cpp:func:`OGR_L_AlterFieldDefn`"
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:5
msgid "index of the field whose definition must be altered."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:7
msgid "new field definition"
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:9
msgid ""
"Combination of :py:const:`osgeo.ogr.ALTER_NAME_FLAG`, "
":py:const:`osgeo.ogr.ALTER_TYPE_FLAG`, "
":py:const:`osgeo.ogr.ALTER_WIDTH_PRECISION_FLAG`, "
":py:const:`osgeo.ogr.ALTER_NULLABLE_FLAG` and "
":py:const:`osgeo.ogr.ALTER_DEFAULT_FLAG` to indicate which of the name "
"and/or type and/or width and precision fields and/or nullability from the"
" new field definition must be taken into account."
msgstr ""

#: of osgeo.ogr.Layer.AlterFieldDefn:20 osgeo.ogr.Layer.CommitTransaction:5
#: osgeo.ogr.Layer.CreateFeature:10 osgeo.ogr.Layer.CreateField:11
#: osgeo.ogr.Layer.CreateGeomField:11 osgeo.ogr.Layer.DeleteField:8
#: osgeo.ogr.Layer.ReorderField:12 osgeo.ogr.Layer.ReorderFields:10
#: osgeo.ogr.Layer.RollbackTransaction:5 osgeo.ogr.Layer.StartTransaction:5
#: osgeo.ogr.Layer.UpsertFeature:8
msgid ":py:const:`osgeo.ogr.OGRERR_NONE` on success."
msgstr ""

#: of osgeo.ogr.Layer.Clip:1
msgid "Clip off areas that are not covered by the method layer."
msgstr ""

#: of osgeo.ogr.Layer.Clip:3
msgid "For more details: :cpp:func:`OGR_L_Clip`"
msgstr ""

#: of osgeo.ogr.Layer.Clip:5 osgeo.ogr.Layer.Erase:5 osgeo.ogr.Layer.Identity:5
#: osgeo.ogr.Layer.Intersection:5 osgeo.ogr.Layer.SymDifference:5
#: osgeo.ogr.Layer.Union:7 osgeo.ogr.Layer.Update:5
msgid "the method layer. Should not be None."
msgstr ""

#: of osgeo.ogr.Layer.Clip:7 osgeo.ogr.Layer.Erase:7 osgeo.ogr.Layer.Identity:7
#: osgeo.ogr.Layer.Intersection:7 osgeo.ogr.Layer.SymDifference:7
#: osgeo.ogr.Layer.Union:9 osgeo.ogr.Layer.Update:7
msgid ""
"the layer where the features resulting from the operation are inserted. "
"Should not be None."
msgstr ""

#: of osgeo.ogr.Layer.Clip:10 osgeo.ogr.Layer.Erase:10
#: osgeo.ogr.Layer.Identity:10 osgeo.ogr.Layer.Intersection:10
#: osgeo.ogr.Layer.SymDifference:10 osgeo.ogr.Layer.Union:12
#: osgeo.ogr.Layer.Update:10
msgid ""
"List of options (empty list is allowed). For example "
"[\"PROMOTE_TO_MULTI=YES\"]."
msgstr ""

#: of osgeo.ogr.Layer.Clip:12 osgeo.ogr.Layer.Erase:12
#: osgeo.ogr.Layer.Identity:12 osgeo.ogr.Layer.Intersection:12
#: osgeo.ogr.Layer.SymDifference:12 osgeo.ogr.Layer.Union:14
#: osgeo.ogr.Layer.Update:12
msgid ""
"a GDALProgressFunc() compatible callback function for reporting progress "
"or None."
msgstr ""

#: of osgeo.ogr.Layer.Clip:15 osgeo.ogr.Layer.Erase:15
#: osgeo.ogr.Layer.GetGeometryTypes:14 osgeo.ogr.Layer.Identity:15
#: osgeo.ogr.Layer.Intersection:15 osgeo.ogr.Layer.SymDifference:15
#: osgeo.ogr.Layer.Union:17 osgeo.ogr.Layer.Update:15
msgid "Argument to be passed to 'callback'. May be None."
msgstr ""

#: of osgeo.ogr.Layer.Clip:17 osgeo.ogr.Layer.Erase:17
#: osgeo.ogr.Layer.Identity:17 osgeo.ogr.Layer.Intersection:17
#: osgeo.ogr.Layer.SymDifference:17 osgeo.ogr.Layer.Union:19
#: osgeo.ogr.Layer.Update:17
msgid ""
"An error code if there was an error or the execution was interrupted, "
":py:const:`osgeo.ogr.OGRERR_NONE` otherwise."
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:1
msgid "For datasources which support transactions, this commits a transaction."
msgstr ""

#: of osgeo.ogr.Layer.CommitTransaction:3
msgid "For more details: :cpp:func:`OGR_L_CommitTransaction`"
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:1
msgid "Create and write a new feature within a layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:3
msgid "For more details: :cpp:func:`OGR_L_CreateFeature`"
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:5
msgid ""
"To create a feature, but set it if it exists see "
":py:meth:`.Layer.UpsertFeature`."
msgstr ""

#: of osgeo.ogr.Layer.CreateFeature:7 osgeo.ogr.Layer.UpsertFeature:5
msgid "The feature to write to disk."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:1
msgid "Create a new field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:3
msgid "For more details: :cpp:func:`OGR_L_CreateField`"
msgstr ""

#: of osgeo.ogr.Layer.CreateField:5
msgid "The field definition to write to disk."
msgstr ""

#: of osgeo.ogr.Layer.CreateField:7 osgeo.ogr.Layer.CreateGeomField:7
msgid ""
"If True, the field may be created in a slightly different form depending "
"on the limitations of the format driver."
msgstr ""

#: of osgeo.ogr.Layer.CreateFields:1
msgid "Create a list of fields on the Layer"
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:1
msgid "Create a new geometry field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:3
msgid "For more details: :cpp:func:`OGR_L_CreateGeomField`"
msgstr ""

#: of osgeo.ogr.Layer.CreateGeomField:5
msgid "The geometry field definition to write to disk."
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:1
msgid "Delete feature from layer."
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:3
msgid "For more details: :cpp:func:`OGR_L_DeleteFeature`"
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:5
msgid "The feature id to be deleted from the layer"
msgstr ""

#: of osgeo.ogr.Layer.DeleteFeature:8
msgid ""
":py:const:`osgeo.ogr.OGRERR_NONE` if the operation works, otherwise an "
"appropriate error code (e.g "
":py:const:`osgeo.ogr.OGRERR_NON_EXISTING_FEATURE`) if the feature does "
"not exist."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:1
msgid "Delete an existing field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:3
msgid "For more details: :cpp:func:`OGR_L_DeleteField`"
msgstr ""

#: of osgeo.ogr.Layer.DeleteField:5
msgid "index of the field to delete."
msgstr ""

#: of osgeo.ogr.Layer.Erase:1
msgid "Remove areas that are covered by the method layer."
msgstr ""

#: of osgeo.ogr.Layer.Erase:3
msgid "For more details: :cpp:func:`OGR_L_Erase`"
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:1
msgid "Find the index of field in a layer."
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:3
msgid "For more details: :cpp:func:`OGR_L_FindFieldIndex`"
msgstr ""

#: of osgeo.ogr.Layer.FindFieldIndex:5
msgid "field index, or -1 if the field doesn't exist"
msgstr ""

#: of osgeo.ogr.Layer.GetArrowStreamAsNumPy:1
msgid ""
"Return an ArrowStream as NumPy Array objects. A specific option to this "
"method is USE_MASKED_ARRAYS=YES/NO (default is YES)."
msgstr ""

#: of osgeo.ogr.Layer.GetArrowStreamAsPyArrow:1
msgid "Return an ArrowStream as PyArrow Schema and Array objects"
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:1
msgid "Fetch the extent of this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:3 osgeo.ogr.Layer.SetSpatialFilter:3
#: osgeo.ogr.Layer.SetSpatialFilterRect:3
msgid "For more details:"
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:5
msgid ":cpp:func:`OGR_L_GetExtent`"
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:6
msgid ":cpp:func:`OGR_L_GetExtentEx`"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:6 osgeo.ogr.Geometry.GetEnvelope3D:6
#: osgeo.ogr.Layer.GetExtent:8
msgid "Check the return order of the bounds."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:10
msgid ""
"Flag indicating whether the extent should be computed even if it is "
"expensive."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:13
msgid "Whether None can be returned in the response."
msgstr ""

#: of osgeo.ogr.Layer.GetExtent:15
msgid ""
"Ithe index of the geometry field on which to compute the extent. Can be "
"iterated over using :py:func:`range` and :py:func:`GetGeomFieldCount`."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:8 osgeo.ogr.Layer.GetExtent:19
msgid ""
"* **minx** (*float*) * **maxx** (*float*) * **miny** (*float*) * **maxy**"
" (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:8 osgeo.ogr.Geometry.GetEnvelope3D:8
#: osgeo.ogr.Layer.GetExtent:19
msgid "**minx** (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:9 osgeo.ogr.Geometry.GetEnvelope3D:9
#: osgeo.ogr.Layer.GetExtent:20
msgid "**maxx** (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:10 osgeo.ogr.Geometry.GetEnvelope3D:10
#: osgeo.ogr.Layer.GetExtent:21
msgid "**miny** (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:11 osgeo.ogr.Geometry.GetEnvelope3D:11
#: osgeo.ogr.Layer.GetExtent:22
msgid "**maxy** (*float*)"
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:1
msgid ""
"This method returns the name of the underlying database column being used"
" as the FID column, or '' if not supported."
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:4
msgid "For more details: :cpp:func:`OGR_L_GetFIDColumn`"
msgstr ""

#: of osgeo.ogr.Layer.GetFIDColumn:6
msgid "fid column name."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:1
msgid "Fetch a feature by its identifier."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:3
msgid "For more details: :cpp:func:`OGR_L_GetFeature`"
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:5
msgid ""
"Use :py:func:`TestCapability` with (:py:const:`osgeo.ogr.OLCRandomRead`) "
"to establish if this layer supports efficient random access reading via "
":py:func:`GetFeature`; However, the call should always work if the "
"feature exists."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:9
msgid ""
"Sequential reads (with :py:func:`GetNextFeature`) are generally "
"considered interrupted by a :py:func:`GetFeature` call."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:12
msgid "The feature id of the feature to read."
msgstr ""

#: of osgeo.ogr.Layer.GetFeature:15
msgid ""
"A new feature now owned by the caller, or None on failure. The returned "
"feature should be deleted with :py:func:`Destroy`."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:1
msgid "Fetch the feature count in this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:3
msgid "For more details: :cpp:func:`OGR_L_GetFeatureCount`"
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:5
msgid ""
"Flag indicating whether the count should be computed even if it is "
"expensive."
msgstr ""

#: of osgeo.ogr.Layer.GetFeatureCount:9
msgid "Feature count, -1 if count not known."
msgstr ""

#: of osgeo.ogr.Layer.GetFeaturesRead:1
msgid "For more details: :cpp:func:`OGR_L_GetFeaturesRead`"
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:1
msgid "Return the layer geometry type."
msgstr ""

#: of osgeo.ogr.Layer.GetGeomType:3
msgid "For more details: :cpp:func:`OGR_L_GetGeomType`"
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:5 osgeo.ogr.Layer.GetGeomType:5
msgid ""
"The geometry type code. The types can be found with 'osgeo.ogr.wkb' "
"prefix. For example :py:const:`osgeo.ogr.wkbPolygon`."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:1
msgid ""
"This method returns the name of the underlying database column being used"
" as the geometry column, or '' if not supported."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:4
msgid "For more details: :cpp:func:`OGR_L_GetGeometryColumn`"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryColumn:6
msgid "geometry column name."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryTypes:1
msgid "Get actual geometry types found in features."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryTypes:3
msgid "For more details: :cpp:func:`OGR_L_GetGeometryTypes`"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryTypes:5
msgid "index of the geometry field"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryTypes:7
msgid ""
"0, or a combination of :py:const:`osgeo.ogr.GGT_COUNT_NOT_NEEDED`, "
":py:const:`osgeo.ogr.GGT_STOP_IF_MIXED` and "
":py:const:`osgeo.ogr.GGT_GEOMCOLLECTIONZ_TINZ`"
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryTypes:11
msgid ""
"a GDALProgressFunc() compatible callback function for cancellation or "
"None."
msgstr ""

#: of osgeo.ogr.Layer.GetGeometryTypes:16
msgid ""
"A dictionary whose keys are :py:const:`osgeo.ogr.wkbXXXX` constants and "
"values the corresponding number of geometries of that type in the layer."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:1
msgid "Fetch the schema information for this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:3
msgid "For more details: :cpp:func:`OGR_L_GetLayerDefn`"
msgstr ""

#: of osgeo.ogr.Layer.GetLayerDefn:5
msgid "The feature definition."
msgstr ""

#: of osgeo.ogr.Layer.GetName:1
msgid "Return the layer name."
msgstr ""

#: of osgeo.ogr.Layer.GetName:3
msgid "For more details: :cpp:func:`OGR_L_GetName`"
msgstr ""

#: of osgeo.ogr.Layer.GetName:5
msgid "The layer name"
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:1
msgid "Fetch the next available feature from this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:3
msgid "For more details: :cpp:func:`OGR_L_GetNextFeature`"
msgstr ""

#: of osgeo.ogr.Layer.GetNextFeature:5
msgid "A feature or None if no more features are available."
msgstr ""

#: of osgeo.ogr.Layer.GetRefCount:1
msgid "For more details: :cpp:func:`OGR_L_GetRefCount`"
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:1
msgid "This function returns the current spatial filter for this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:3
msgid "For more details: :cpp:func:`OGR_L_GetSpatialFilter`"
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialFilter:5
msgid "The spatial filter geometry."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:1
msgid "Fetch the spatial reference system for this layer."
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:3
msgid "For more details: :cpp:func:`OGR_L_GetSpatialRef`"
msgstr ""

#: of osgeo.ogr.Layer.GetSpatialRef:5
msgid "spatial reference, or None if there isn't one."
msgstr ""

#: of osgeo.ogr.Layer.GetStyleTable:3
msgid "For more details: :cpp:func:`OGR_L_GetStyleTable`"
msgstr ""

#: of osgeo.ogr.Layer.Identity:1
msgid "Identify the features of this layer with the ones from the identity layer."
msgstr ""

#: of osgeo.ogr.Layer.Identity:3
msgid "For more details: :cpp:func:`OGR_L_Identity`"
msgstr ""

#: of osgeo.ogr.Layer.Intersection:1
msgid "Intersection of two layers."
msgstr ""

#: of osgeo.ogr.Layer.Intersection:3
msgid "For more details: :cpp:func:`OGR_L_Intersection`"
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:1
msgid "Reorder an existing field on a layer."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:3
msgid "For more details: :cpp:func:`OGR_L_ReorderField`"
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:5
msgid ""
"previous position of the field to move. Must be in the range "
"[0,GetFieldCount()-1]."
msgstr ""

#: of osgeo.ogr.Layer.ReorderField:8
msgid ""
"new position of the field to move. Must be in the range "
"[0,GetFieldCount()-1]."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:1
msgid "Reorder all the fields of a layer."
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:3
msgid "For more details: :cpp:func:`OGR_L_ReorderFields`"
msgstr ""

#: of osgeo.ogr.Layer.ReorderFields:5
msgid ""
"A list of GetLayerDefn().GetFieldCount() elements which is a permutation "
"of [0, GetLayerDefn().GetFieldCount()-1]."
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:1
msgid "Reset feature reading to start on the first feature."
msgstr ""

#: of osgeo.ogr.Layer.ResetReading:3
msgid "For more details: :cpp:func:`OGR_L_ResetReading`"
msgstr ""

#: of osgeo.ogr.Layer.RollbackTransaction:1
msgid ""
"Roll back a datasource to its state before the start of the current "
"transaction."
msgstr ""

#: of osgeo.ogr.Layer.RollbackTransaction:3
msgid "For more details: :cpp:func:`OGR_L_RollbackTransaction`"
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:1
msgid "Set a new attribute query."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:3
msgid "For more details: :cpp:func:`OGR_L_SetAttributeFilter`"
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:5
msgid "query in restricted SQL WHERE format, or None to clear the current query."
msgstr ""

#: of osgeo.ogr.Layer.SetAttributeFilter:9
msgid ""
":py:const:`osgeo.ogr.OGRERR_NONE` if successfully installed, or an error "
"code if the query expression is in error, or some other failure occurs."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:1
msgid "Rewrite an existing feature."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:3
msgid "For more details: :cpp:func:`OGR_L_SetFeature`"
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:5
msgid ""
"To set a feature, but create it if it doesn't exist see "
":py:meth:`.Layer.UpsertFeature`."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:7
msgid "The feature to write."
msgstr ""

#: of osgeo.ogr.Layer.SetFeature:10
msgid ""
":py:const:`osgeo.ogr.OGRERR_NONE` if the operation works, otherwise an "
"appropriate error code (e.g "
":py:const:`osgeo.ogr.OGRERR_NON_EXISTING_FEATURE` if the feature does not"
" exist)."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:1
msgid "Set which fields can be omitted when retrieving features from the layer."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:4
msgid "For more details: :cpp:func:`OGR_L_SetIgnoredFields`"
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:6
msgid ""
"A list of field names. If an empty list is passed, the ignored list is "
"cleared."
msgstr ""

#: of osgeo.ogr.Layer.SetIgnoredFields:10
msgid ""
":py:const:`osgeo.ogr.OGRERR_NONE` if all field names have been resolved "
"(even if the driver does not support this method)"
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:1
msgid "Move read cursor to the nIndex'th feature in the current resultset."
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:3
msgid "For more details: :cpp:func:`OGR_L_SetNextByIndex`"
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:5
msgid "The index indicating how many steps into the result set to seek."
msgstr ""

#: of osgeo.ogr.Layer.SetNextByIndex:8
msgid ":py:const:`osgeo.ogr.OGRERR_NONE` on success or an error code."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:1
msgid "Set a new spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:5
msgid ":cpp:func:`OGR_L_SetSpatialFilter`"
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:6
msgid ":cpp:func:`OGR_L_SetSpatialFilterEx`"
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:8 osgeo.ogr.Layer.SetSpatialFilterRect:8
msgid "index of the geometry field on which the spatial filter operates."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilter:10
msgid ""
"The geometry to use as a filtering region. None may be passed indicating "
"that the current spatial filter should be cleared, but no new one "
"instituted."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:1
msgid "Set a new rectangular spatial filter."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:5
msgid ":cpp:func:`OGR_L_SetSpatialFilterRect`"
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:6
msgid ":cpp:func:`OGR_L_SetSpatialFilterRectEx`"
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:10
msgid "the minimum X coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:12
msgid "the minimum Y coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:14
msgid "the maximum X coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetSpatialFilterRect:16
msgid "the maximum Y coordinate for the rectangular region."
msgstr ""

#: of osgeo.ogr.Layer.SetStyleTable:3
msgid "For more details: :cpp:func:`OGR_L_SetStyleTable`"
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:1
msgid "For datasources which support transactions, this creates a transaction."
msgstr ""

#: of osgeo.ogr.Layer.StartTransaction:3
msgid "For more details: :cpp:func:`OGR_L_StartTransaction`"
msgstr ""

#: of osgeo.ogr.Layer.SymDifference:1
msgid "Symmetrical difference of two layers."
msgstr ""

#: of osgeo.ogr.Layer.SymDifference:3
msgid "For more details: :cpp:func:`OGR_L_SymDifference`"
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:3
msgid "For more details: :cpp:func:`OGR_L_SyncToDisk`"
msgstr ""

#: of osgeo.ogr.Layer.SyncToDisk:5
msgid ""
":py:const:`osgeo.ogr.OGRERR_NONE` if no error occurs (even if nothing is "
"done) or an error code."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:1
msgid "Test if this layer supported the named capability."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:3
msgid "For more details: :cpp:func:`OGR_L_TestCapability`"
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:5
msgid ""
"The name of the capability to test. These can be found in the `osgeo.ogr`"
" namespace. For example, :py:const:`osgeo.ogr.OLCRandomRead`."
msgstr ""

#: of osgeo.ogr.Layer.TestCapability:10
msgid ""
"True if the layer has the requested capability, or False otherwise. Will "
"return False for any unrecognized capabilities."
msgstr ""

#: of osgeo.ogr.Layer.Union:1
msgid "Union of two layers."
msgstr ""

#: of osgeo.ogr.Layer.Union:3
msgid "For more details: :cpp:func:`OGR_L_Union`"
msgstr ""

#: of osgeo.ogr.Layer.Union:5
msgid "The first geometry field is always used."
msgstr ""

#: of osgeo.ogr.Layer.Update:1
msgid "Update this layer with features from the update layer."
msgstr ""

#: of osgeo.ogr.Layer.Update:3
msgid "For more details: :cpp:func:`OGR_L_Update`"
msgstr ""

#: of osgeo.ogr.Layer.UpsertFeature:1
msgid "Rewrite an existing feature or create a new feature within a layer."
msgstr ""

#: of osgeo.ogr.Layer.UpsertFeature:3
msgid "For more details: :cpp:func:`OGR_L_UpsertFeature`"
msgstr ""

#: ../../source/api/python/vector_api.rst:32
msgid "Feature"
msgstr ""

#: of osgeo.ogr.Feature:1
msgid "Proxy of C++ OGRFeatureShadow class."
msgstr ""

#: of osgeo.ogr.Feature.Clone:1
msgid "OGRFeatureH OGR_F_Clone(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.Clone:3
msgid "Duplicate feature."
msgstr ""

#: of osgeo.ogr.Feature.Clone:5
msgid ""
"The newly created feature is owned by the caller, and will have its own "
"reference to the OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.Feature.Clone:8
msgid "This function is the same as the C++ method OGRFeature::Clone()."
msgstr ""

#: of osgeo.ogr.Feature.Clone:10
msgid "handle to the feature to clone."
msgstr ""

#: of osgeo.ogr.Feature.Clone:12
msgid "a handle to the new feature, exactly matching this feature."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:1
msgid "void OGR_F_DumpReadable(OGRFeatureH hFeat, FILE \\*fpOut)"
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:4
msgid "Dump this feature in a human readable form."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:6
msgid ""
"This dumps the attributes, and geometry; however, it doesn't definition "
"information (other than field types and names), nor does it report the "
"geometry spatial reference system."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:10
msgid "This function is the same as the C++ method OGRFeature::DumpReadable()."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:13
msgid "handle to the feature to dump."
msgstr ""

#: of osgeo.ogr.Feature.DumpReadable:14
msgid "the stream to write to, such as strout."
msgstr ""

#: of osgeo.ogr.Feature.Equal:1
msgid "int OGR_F_Equal(OGRFeatureH hFeat, OGRFeatureH hOtherFeat)"
msgstr ""

#: of osgeo.ogr.Feature.Equal:4
msgid "Test if two features are the same."
msgstr ""

#: of osgeo.ogr.Feature.Equal:6
msgid ""
"Two features are considered equal if the share them (handle equality) "
"same OGRFeatureDefn, have the same field values, and the same geometry "
"(as tested by OGR_G_Equal()) as well as the same feature id."
msgstr ""

#: of osgeo.ogr.Feature.Equal:10
msgid "This function is the same as the C++ method OGRFeature::Equal()."
msgstr ""

#: of osgeo.ogr.Feature.Equal:12
msgid "handle to one of the feature."
msgstr ""

#: of osgeo.ogr.Feature.Equal:13
msgid "handle to the other feature to test this one against."
msgstr ""

#: of osgeo.ogr.Feature.Equal:15
msgid "TRUE if they are equal, otherwise FALSE."
msgstr ""

#: of osgeo.ogr.Feature.ExportToJson:1
msgid ""
"Exports a GeoJSON object which represents the Feature. The as_object "
"parameter determines whether the returned value should be a Python object"
" instead of a string. Defaults to False. The options parameter is passed "
"to Geometry.ExportToJson()"
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:1
msgid ""
"void OGR_F_FillUnsetWithDefault(OGRFeatureH hFeat, int bNotNullableOnly, "
"char \\*\\*papszOptions)"
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:5
msgid "Fill unset fields with default values that might be defined."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:7
msgid ""
"This function is the same as the C++ method "
"OGRFeature::FillUnsetWithDefault()."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:12
#: osgeo.ogr.Feature.GetNativeData:28 osgeo.ogr.Feature.GetNativeMediaType:18
#: osgeo.ogr.Feature.SetNativeData:18 osgeo.ogr.Feature.SetNativeMediaType:20
msgid "handle to the feature."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:13
msgid "if we should fill only unset fields with a not-null constraint."
msgstr ""

#: of osgeo.ogr.Feature.FillUnsetWithDefault:15
msgid "unused currently. Must be set to NULL."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:1
msgid "OGRFeatureDefnH OGR_F_GetDefnRef(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:3
msgid "Fetch feature definition."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:5
msgid "This function is the same as the C++ method OGRFeature::GetDefnRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:7
msgid "handle to the feature to get the feature definition from."
msgstr ""

#: of osgeo.ogr.Feature.GetDefnRef:9
msgid "a handle to the feature definition object on which feature depends."
msgstr ""

#: of osgeo.ogr.Feature.GetFID:1
msgid "GIntBig OGR_F_GetFID(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetFID:4
msgid "Get feature identifier."
msgstr ""

#: of osgeo.ogr.Feature.GetFID:6
msgid ""
"This function is the same as the C++ method OGRFeature::GetFID(). Note: "
"since GDAL 2.0, this method returns a GIntBig (previously a long)"
msgstr ""

#: of osgeo.ogr.Feature.GetFID:10
msgid "handle to the feature from which to get the feature"
msgstr ""

#: of osgeo.ogr.Feature.GetFID:13
msgid "feature id or OGRNullFID if none has been assigned."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:1
msgid ""
"GByte\\* OGR_F_GetFieldAsBinary(OGRFeatureH hFeat, int iField, int "
"\\*pnBytes)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:4
msgid "Fetch field value as binary."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:6
msgid "This method only works for OFTBinary and OFTString fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:8
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsBinary()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:11
#: osgeo.ogr.Feature.GetFieldAsDateTime:16
#: osgeo.ogr.Feature.GetFieldAsDouble:12
#: osgeo.ogr.Feature.GetFieldAsDoubleList:12
#: osgeo.ogr.Feature.GetFieldAsInteger:12
#: osgeo.ogr.Feature.GetFieldAsInteger64:15
#: osgeo.ogr.Feature.GetFieldAsInteger64List:14
#: osgeo.ogr.Feature.GetFieldAsIntegerList:11
#: osgeo.ogr.Feature.GetFieldAsString:12
#: osgeo.ogr.Feature.GetFieldAsStringList:14
#: osgeo.ogr.Feature.SetFieldDoubleList:18
#: osgeo.ogr.Feature.SetFieldInteger64:21
#: osgeo.ogr.Feature.SetFieldInteger64List:20
#: osgeo.ogr.Feature.SetFieldIntegerList:18 osgeo.ogr.Feature.SetFieldString:21
#: osgeo.ogr.Feature.SetFieldStringList:17
msgid "handle to the feature that owned the field."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:12
#: osgeo.ogr.Feature.GetFieldAsDateTime:17
#: osgeo.ogr.Feature.GetFieldAsDouble:13
#: osgeo.ogr.Feature.GetFieldAsDoubleList:13
#: osgeo.ogr.Feature.GetFieldAsInteger:13
#: osgeo.ogr.Feature.GetFieldAsInteger64:16
#: osgeo.ogr.Feature.GetFieldAsInteger64List:15
#: osgeo.ogr.Feature.GetFieldAsIntegerList:12
#: osgeo.ogr.Feature.GetFieldAsString:13
#: osgeo.ogr.Feature.GetFieldAsStringList:15
#: osgeo.ogr.Feature.GetFieldDefnRef:9 osgeo.ogr.Feature.SetFieldInteger64:22
#: osgeo.ogr.Feature.SetFieldString:22
msgid "the field to fetch, from 0 to GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:13
msgid "location to place count of bytes returned."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsBinary:15
#: osgeo.ogr.Feature.GetFieldAsStringList:17
msgid ""
"the field value. This list is internal, and should not be modified, or "
"freed. Its lifetime may be very brief."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:1
msgid ""
"int OGR_F_GetFieldAsDateTime(OGRFeatureH hFeat, int iField, int "
"\\*pnYear, int \\*pnMonth, int \\*pnDay, int \\*pnHour, int \\*pnMinute, "
"int \\*pnSecond, int \\*pnTZFlag)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:6
msgid "Fetch field value as date and time."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:8
msgid ""
"Currently this method only works for OFTDate, OFTTime and OFTDateTime "
"fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:11
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsDateTime()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:14
msgid "Use OGR_F_GetFieldAsDateTimeEx() for second with millisecond accuracy."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:18
msgid "(including century)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:19
msgid "(1-12)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:20
msgid "(1-31)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:21
msgid "(0-23)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:22
#: osgeo.ogr.Feature.GetFieldAsDateTime:23
msgid "(0-59)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:24
msgid "(0=unknown, 1=localtime, 100=GMT, see data model for"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDateTime:27
msgid "TRUE on success or FALSE on failure."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:1
msgid "double OGR_F_GetFieldAsDouble(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:3
msgid "Fetch field value as a double."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:5
msgid ""
"OFTString features will be translated using CPLAtof(). OFTInteger fields "
"will be cast to double. Other field types, or errors will result in a "
"return value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsDouble()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDouble:15
#: osgeo.ogr.Feature.GetFieldAsInteger:15
#: osgeo.ogr.Feature.GetFieldAsInteger64:18
msgid "the field value."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:1
msgid ""
"const double\\* OGR_F_GetFieldAsDoubleList(OGRFeatureH hFeat, int iField,"
" int \\*pnCount)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:5
msgid "Fetch field value as a list of doubles."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:7
msgid "Currently this function only works for OFTRealList fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsDoubleList()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:14
msgid "an integer to put the list count (number of doubles) into."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsDoubleList:16
#: osgeo.ogr.Feature.GetFieldAsInteger64List:18
#: osgeo.ogr.Feature.GetFieldAsIntegerList:15
msgid ""
"the field value. This list is internal, and should not be modified, or "
"freed. Its lifetime may be very brief. If \\*pnCount is zero on return "
"the returned pointer may be NULL or non-NULL."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:1
msgid "int OGR_F_GetFieldAsInteger(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:3
msgid "Fetch field value as integer."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:5
msgid ""
"OFTString features will be translated using atoi(). OFTReal fields will "
"be cast to integer. Other field types, or errors will result in a return "
"value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsInteger()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:1
msgid "GIntBig OGR_F_GetFieldAsInteger64(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:3
msgid "Fetch field value as integer 64 bit."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:5
msgid ""
"OFTInteger are promoted to 64 bit. OFTString features will be translated "
"using CPLAtoGIntBig(). OFTReal fields will be cast to integer. Other "
"field types, or errors will result in a return value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64:10
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsInteger64()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:1
msgid ""
"const GIntBig\\* OGR_F_GetFieldAsInteger64List(OGRFeatureH hFeat, int "
"iField, int \\*pnCount)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:5
msgid "Fetch field value as a list of 64 bit integers."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:7
msgid "Currently this function only works for OFTInteger64List fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsInteger64List()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsInteger64List:16
#: osgeo.ogr.Feature.GetFieldAsIntegerList:13
msgid "an integer to put the list count (number of integers) into."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:1
msgid ""
"const int\\* OGR_F_GetFieldAsIntegerList(OGRFeatureH hFeat, int iField, "
"int \\*pnCount)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:4
msgid "Fetch field value as a list of integers."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:6
msgid "Currently this function only works for OFTIntegerList fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsIntegerList:8
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsIntegerList()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:1
msgid "const char\\* OGR_F_GetFieldAsString(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:3
msgid "Fetch field value as a string."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:5
msgid ""
"OFTReal and OFTInteger fields will be translated to string using "
"sprintf(), but not necessarily using the established formatting rules. "
"Other field types, or errors will result in a return value of zero."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsString()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsString:15
msgid ""
"the field value. This string is internal, and should not be modified, or "
"freed. Its lifetime may be very brief."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:1
msgid "char\\*\\* OGR_F_GetFieldAsStringList(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:4
msgid "Fetch field value as a list of strings."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:6
msgid "Currently this method only works for OFTStringList fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:8
msgid ""
"The returned list is terminated by a NULL pointer. The number of elements"
" can also be calculated using CSLCount()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldAsStringList:11
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetFieldAsStringList()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:1
msgid "int OGR_F_GetFieldCount(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:3
msgid ""
"Fetch number of fields on this feature This will always be the same as "
"the field count for the OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:6
msgid "This function is the same as the C++ method OGRFeature::GetFieldCount()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:9
msgid "handle to the feature to get the fields count from."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldCount:11 osgeo.ogr.FeatureDefn.GetFieldCount:10
msgid "count of fields."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:1
msgid "OGRFieldDefnH OGR_F_GetFieldDefnRef(OGRFeatureH hFeat, int i)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:3
msgid "Fetch definition for this field."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:5
msgid "This function is the same as the C++ method OGRFeature::GetFieldDefnRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:8 osgeo.ogr.Feature.GetFieldIndex:10
#: osgeo.ogr.Feature.GetGeomFieldDefnRef:10
msgid "handle to the feature on which the field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldDefnRef:11
#: osgeo.ogr.Feature.GetGeomFieldDefnRef:13
msgid ""
"a handle to the field definition (from the OGRFeatureDefn). This is an "
"internal reference, and should not be deleted or modified."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:1
msgid "int OGR_F_GetFieldIndex(OGRFeatureH hFeat, const char \\*pszName)"
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:3
msgid "Fetch the field index given field name."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:5
msgid "This is a cover for the OGRFeatureDefn::GetFieldIndex() method."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:7
msgid "This function is the same as the C++ method OGRFeature::GetFieldIndex()."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:11
msgid "the name of the field to search for."
msgstr ""

#: of osgeo.ogr.Feature.GetFieldIndex:13
msgid "the field index, or -1 if no matching field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:1
msgid "int OGR_F_GetGeomFieldCount(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:3
msgid ""
"Fetch number of geometry fields on this feature This will always be the "
"same as the geometry field count for the OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:6
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetGeomFieldCount()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:11
msgid "handle to the feature to get the geometry fields count from."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldCount:13
#: osgeo.ogr.FeatureDefn.GetGeomFieldCount:13
msgid "count of geometry fields."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:1
msgid "OGRGeomFieldDefnH OGR_F_GetGeomFieldDefnRef(OGRFeatureH hFeat, int i)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:3
msgid "Fetch definition for this geometry field."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:5
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetGeomFieldDefnRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldDefnRef:11
msgid "the field to fetch, from 0 to GetGeomFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:1
msgid "int OGR_F_GetGeomFieldIndex(OGRFeatureH hFeat, const char \\*pszName)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:3
msgid "Fetch the geometry field index given geometry field name."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:5
msgid "This is a cover for the OGRFeatureDefn::GetGeomFieldIndex() method."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:7
msgid ""
"This function is the same as the C++ method "
"OGRFeature::GetGeomFieldIndex()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:12
msgid "handle to the feature on which the geometry field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:13
msgid "the name of the geometry field to search for."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldIndex:15
msgid "the geometry field index, or -1 if no matching geometry field is found."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:1
msgid "OGRGeometryH OGR_F_GetGeomFieldRef(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:4
msgid "Fetch a handle to feature geometry."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:6
msgid "This function is the same as the C++ method OGRFeature::GetGeomFieldRef()."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:9
msgid "handle to the feature to get geometry from."
msgstr ""

#: of osgeo.ogr.Feature.GetGeomFieldRef:10
msgid "geometry field to get."
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:1 osgeo.ogr.Feature.geometry:1
msgid "Return the feature geometry"
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:3 osgeo.ogr.Feature.geometry:3
msgid ""
"The lifetime of the returned geometry is bound to the one of its "
"belonging feature."
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:6 osgeo.ogr.Feature.geometry:6
msgid "For more details: :cpp:func:`OGR_F_GetGeometryRef`"
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:8
msgid "The geometry() method is also available as an alias of GetGeometryRef()"
msgstr ""

#: of osgeo.ogr.Feature.GetGeometryRef:10 osgeo.ogr.Feature.geometry:10
msgid "the geometry, or None."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:1
msgid "const char\\* OGR_F_GetNativeData(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:4
msgid "Returns the native data for the feature."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:6 osgeo.ogr.Feature.SetNativeData:6
msgid ""
"The native data is the representation in a \"natural\" form that comes "
"from the driver that created this feature, or that is aimed at an output "
"driver. The native data may be in different format, which is indicated by"
" OGR_F_GetNativeMediaType()."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:11
msgid ""
"Note that most drivers do not support storing the native data in the "
"feature object, and if they do, generally the NATIVE_DATA open option "
"must be passed at dataset opening."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:15
msgid ""
"The \"native data\" does not imply it is something more performant or "
"powerful than what can be obtained with the rest of the API, but it may "
"be useful in round-tripping scenarios where some characteristics of the "
"underlying format are not captured otherwise by the OGR abstraction."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:21
msgid "This function is the same as the C++ method OGRFeature::GetNativeData()."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:24
#: osgeo.ogr.Feature.GetNativeMediaType:14 osgeo.ogr.Feature.SetNativeData:14
#: osgeo.ogr.Feature.SetNativeMediaType:15
msgid "See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeData:30 osgeo.ogr.Feature.SetNativeData:19
msgid "a string with the native data, or NULL if there is none."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:1
msgid "const char\\* OGR_F_GetNativeMediaType(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:4
msgid "Returns the native media type for the feature."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:6
#: osgeo.ogr.Feature.SetNativeMediaType:7
msgid ""
"The native media type is the identifier for the format of the native "
"data. It follows the IANA RFC 2045 "
"(seehttps://en.wikipedia.org/wiki/Media_type), e.g. "
"\"application/vnd.geo+json\" for JSon."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:11
msgid "This function is the same as the C function OGR_F_GetNativeMediaType()."
msgstr ""

#: of osgeo.ogr.Feature.GetNativeMediaType:20
#: osgeo.ogr.Feature.SetNativeMediaType:21
msgid "a string with the native media type, or NULL if there is none."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:1
msgid "const char\\* OGR_F_GetStyleString(OGRFeatureH hFeat)"
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:4
msgid "Fetch style string for this feature."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:6
msgid ""
"Set the OGR Feature Style Specification for details on the format of this"
" string, and ogr_featurestyle.h for services available to parse it."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:10
msgid "This function is the same as the C++ method OGRFeature::GetStyleString()."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:13
msgid "handle to the feature to get the style from."
msgstr ""

#: of osgeo.ogr.Feature.GetStyleString:15
msgid ""
"a reference to a representation in string format, or NULL if there isn't "
"one."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:1
msgid "int OGR_F_IsFieldNull(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:3
msgid "Test if a field is null."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:5
msgid "This function is the same as the C++ method OGRFeature::IsFieldNull()."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:9 osgeo.ogr.Feature.IsFieldSet:7
#: osgeo.ogr.Feature.IsFieldSetAndNotNull:10 osgeo.ogr.Feature.SetFieldNull:10
#: osgeo.ogr.Feature.UnsetField:7
msgid "handle to the feature on which the field is."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:10 osgeo.ogr.Feature.IsFieldSet:8
#: osgeo.ogr.Feature.IsFieldSetAndNotNull:11
msgid "the field to test."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldNull:12
msgid "TRUE if the field is null, otherwise false."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:1
msgid "int OGR_F_IsFieldSet(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:3
msgid "Test if a field has ever been assigned a value or not."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:5
msgid "This function is the same as the C++ method OGRFeature::IsFieldSet()."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSet:10
msgid "TRUE if the field has been set, otherwise false."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:1
msgid "int OGR_F_IsFieldSetAndNotNull(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:3
msgid "Test if a field is set and not null."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:5
msgid ""
"This function is the same as the C++ method "
"OGRFeature::IsFieldSetAndNotNull()."
msgstr ""

#: of osgeo.ogr.Feature.IsFieldSetAndNotNull:13
msgid "TRUE if the field is set and not null, otherwise false."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:1
msgid "OGRErr OGR_F_SetFID(OGRFeatureH hFeat, GIntBig nFID)"
msgstr ""

#: of osgeo.ogr.Feature.SetFID:4
msgid "Set the feature identifier."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:6
msgid ""
"For specific types of features this operation may fail on illegal "
"features ids. Generally it always succeeds. Feature ids should be greater"
" than or equal to zero, with the exception of OGRNullFID (-1) indicating "
"that the feature id is unknown."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:11
msgid "This function is the same as the C++ method OGRFeature::SetFID()."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:13
msgid "handle to the feature to set the feature id to."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:14
msgid "the new feature identifier value to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFID:16
msgid "On success OGRERR_NONE, or on failure some other value."
msgstr ""

#: of osgeo.ogr.Feature.SetField:1
msgid "SetField(self, int id, int year, int month, int day, int hour, int minute,"
msgstr ""

#: of osgeo.ogr.Feature.SetField:2
msgid "int second, int tzflag)"
msgstr ""

#: of osgeo.ogr.Feature.SetField:3
msgid "SetField(self, char name, int year, int month, int day, int hour,"
msgstr ""

#: of osgeo.ogr.Feature.SetField:4
msgid "int minute, int second, int tzflag)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:1
msgid ""
"void OGR_F_SetFieldDoubleList(OGRFeatureH hFeat, int iField, int nCount, "
"const double \\*padfValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:5
msgid "Set field to list of doubles value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:7
msgid ""
"This function currently on has an effect of OFTIntegerList, "
"OFTInteger64List, OFTRealList fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:10
#: osgeo.ogr.Feature.SetFieldInteger64:11
#: osgeo.ogr.Feature.SetFieldInteger64List:10
#: osgeo.ogr.Feature.SetFieldIntegerList:10 osgeo.ogr.Feature.SetFieldString:13
#: osgeo.ogr.Feature.SetFieldStringList:9
msgid "This function is the same as the C++ method OGRFeature::SetField()."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:12
#: osgeo.ogr.Feature.SetFieldInteger64:13
#: osgeo.ogr.Feature.SetFieldInteger64List:12
#: osgeo.ogr.Feature.SetFieldIntegerList:12 osgeo.ogr.Feature.SetFieldString:15
#: osgeo.ogr.Feature.SetFieldStringList:11 osgeo.ogr.Feature.SetGeometry:11
#: osgeo.ogr.Feature.SetGeometryDirectly:12
msgid ""
"This method has only an effect on the in-memory feature object. If this "
"object comes from a layer and the modifications must be serialized back "
"to the datasource, OGR_L_SetFeature() must be used afterwards. Or if this"
" is a new feature, OGR_L_CreateFeature() must be used afterwards."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:19
#: osgeo.ogr.Feature.SetFieldInteger64List:21
#: osgeo.ogr.Feature.SetFieldIntegerList:19
#: osgeo.ogr.Feature.SetFieldStringList:18
msgid "the field to set, from 0 to GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:20
#: osgeo.ogr.Feature.SetFieldInteger64List:22
#: osgeo.ogr.Feature.SetFieldIntegerList:20
msgid "the number of values in the list being assigned."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldDoubleList:21
#: osgeo.ogr.Feature.SetFieldInteger64List:23
#: osgeo.ogr.Feature.SetFieldIntegerList:21
msgid "the values to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:1
msgid ""
"void OGR_F_SetFieldInteger64(OGRFeatureH hFeat, int iField, GIntBig "
"nValue)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:4
msgid "Set field to 64 bit integer value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:6
msgid ""
"OFTInteger, OFTInteger64 and OFTReal fields will be set directly. "
"OFTString fields will be assigned a string representation of the value, "
"but not necessarily taking into account formatting constraints on this "
"field. Other field types may be unaffected."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64:23
#: osgeo.ogr.Feature.SetFieldString:23
msgid "the value to assign."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:1
msgid ""
"void OGR_F_SetFieldInteger64List(OGRFeatureH hFeat, int iField, int "
"nCount, const GIntBig \\*panValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:5
msgid "Set field to list of 64 bit integers value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldInteger64List:7
#: osgeo.ogr.Feature.SetFieldIntegerList:7
msgid ""
"This function currently on has an effect of OFTIntegerList, "
"OFTInteger64List and OFTRealList fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldIntegerList:1
msgid ""
"void OGR_F_SetFieldIntegerList(OGRFeatureH hFeat, int iField, int nCount,"
" const int \\*panValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldIntegerList:5
msgid "Set field to list of integers value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:1
msgid "void OGR_F_SetFieldNull(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:3
msgid "Clear a field, marking it as null."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:5
msgid "This function is the same as the C++ method OGRFeature::SetFieldNull()."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldNull:11
msgid "the field to set to null."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:1
msgid ""
"void OGR_F_SetFieldString(OGRFeatureH hFeat, int iField, const char "
"\\*pszValue)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:5
msgid "Set field to string value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldString:7
msgid ""
"OFTInteger fields will be set based on an atoi() conversion of the "
"string. OFTInteger64 fields will be set based on an CPLAtoGIntBig() "
"conversion of the string. OFTReal fields will be set based on an "
"CPLAtof() conversion of the string. Other field types may be unaffected."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:1
msgid ""
"void OGR_F_SetFieldStringList(OGRFeatureH hFeat, int iField, CSLConstList"
" papszValues)"
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:5
msgid "Set field to list of strings value."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:7
msgid "This function currently on has an effect of OFTStringList fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFieldStringList:19
msgid "the values to assign. List of NUL-terminated string,"
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:1
msgid ""
"OGRErr OGR_F_SetFrom(OGRFeatureH hFeat, OGRFeatureH hOtherFeat, int "
"bForgiving)"
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:4 osgeo.ogr.Feature.SetFromWithMap:5
msgid "Set one feature from another."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:6
msgid ""
"Overwrite the contents of this feature from the geometry and attributes "
"of another. The hOtherFeature does not need to have the same "
"OGRFeatureDefn. Field values are copied by corresponding field names. "
"Field types do not have to exactly match. OGR_F_SetField\\*() function "
"conversion rules will be applied as needed."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:12 osgeo.ogr.Feature.SetFromWithMap:16
msgid "This function is the same as the C++ method OGRFeature::SetFrom()."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:14 osgeo.ogr.Feature.SetFromWithMap:18
msgid "handle to the feature to set to."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:15 osgeo.ogr.Feature.SetFromWithMap:19
msgid ""
"handle to the feature from which geometry, and field values will be "
"copied."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:17 osgeo.ogr.Feature.SetFromWithMap:26
msgid ""
"TRUE if the operation should continue despite lacking output fields "
"matching some of the source fields."
msgstr ""

#: of osgeo.ogr.Feature.SetFrom:20 osgeo.ogr.Feature.SetFromWithMap:29
msgid ""
"OGRERR_NONE if the operation succeeds, even if some values are not "
"transferred, otherwise an error code."
msgstr ""

#: of osgeo.ogr.Feature.SetFromWithMap:1
msgid ""
"OGRErr OGR_F_SetFromWithMap(OGRFeatureH hFeat, OGRFeatureH hOtherFeat, "
"int bForgiving, const int \\*panMap)"
msgstr ""

#: of osgeo.ogr.Feature.SetFromWithMap:7
msgid ""
"Overwrite the contents of this feature from the geometry and attributes "
"of another. The hOtherFeature does not need to have the same "
"OGRFeatureDefn. Field values are copied according to the provided indices"
" map. Field types do not have to exactly match. OGR_F_SetField\\*() "
"function conversion rules will be applied as needed. This is more "
"efficient than OGR_F_SetFrom() in that this doesn't lookup the fields by "
"their names. Particularly useful when the field names don't match."
msgstr ""

#: of osgeo.ogr.Feature.SetFromWithMap:21
msgid ""
"Array of the indices of the destination feature's fields stored at the "
"corresponding index of the source feature's fields. A value of -1 should "
"be used to ignore the source's field. The array should not be NULL and be"
" as long as the number of fields in the source feature."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:1
msgid ""
"OGRErr OGR_F_SetGeomField(OGRFeatureH hFeat, int iField, OGRGeometryH "
"hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:4 osgeo.ogr.Feature.SetGeomFieldDirectly:3
msgid "Set feature geometry of a specified geometry field."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:6 osgeo.ogr.Feature.SetGeometry:5
msgid ""
"This function updates the features geometry, and operate exactly as "
"SetGeometryDirectly(), except that this function does not assume "
"ownership of the passed geometry, but instead makes a copy of it."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:10
msgid "This function is the same as the C++ OGRFeature::SetGeomField()."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:12 osgeo.ogr.Feature.SetGeometry:17
msgid "handle to the feature on which new geometry is applied to."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:13
#: osgeo.ogr.Feature.SetGeomFieldDirectly:15
msgid "geometry field to set."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:14
#: osgeo.ogr.Feature.SetGeomFieldDirectly:16 osgeo.ogr.Feature.SetGeometry:18
#: osgeo.ogr.Feature.SetGeometryDirectly:19
msgid "handle to the new geometry to apply to feature."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomField:16 osgeo.ogr.Feature.SetGeometry:20
#: osgeo.ogr.Feature.SetGeometryDirectly:21
msgid ""
"OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the "
"geometry type is illegal for the OGRFeatureDefn (checking not yet "
"implemented)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:1
msgid ""
"OGRErr OGR_F_SetGeomFieldDirectly(OGRFeatureH hFeat, int iField, "
"OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:5
msgid ""
"This function updates the features geometry, and operate exactly as "
"SetGeomField(), except that this function assumes ownership of the passed"
" geometry (even in case of failure of that function)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::SetGeomFieldDirectly."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:14
#: osgeo.ogr.Feature.SetGeometryDirectly:18
msgid "handle to the feature on which to apply the geometry."
msgstr ""

#: of osgeo.ogr.Feature.SetGeomFieldDirectly:18
msgid ""
"OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid, or "
"OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the "
"OGRFeatureDefn (checking not yet implemented)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometry:1
msgid "OGRErr OGR_F_SetGeometry(OGRFeatureH hFeat, OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeometry:3 osgeo.ogr.Feature.SetGeometryDirectly:3
msgid "Set feature geometry."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometry:9
msgid "This function is the same as the C++ OGRFeature::SetGeometry()."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometryDirectly:1
msgid "OGRErr OGR_F_SetGeometryDirectly(OGRFeatureH hFeat, OGRGeometryH hGeom)"
msgstr ""

#: of osgeo.ogr.Feature.SetGeometryDirectly:5
msgid ""
"This function updates the features geometry, and operate exactly as "
"SetGeometry(), except that this function assumes ownership of the passed "
"geometry (even in case of failure of that function)."
msgstr ""

#: of osgeo.ogr.Feature.SetGeometryDirectly:9
msgid ""
"This function is the same as the C++ method "
"OGRFeature::SetGeometryDirectly."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:1
msgid "void OGR_F_SetNativeData(OGRFeatureH hFeat, const char \\*pszNativeData)"
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:4
msgid "Sets the native data for the feature."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeData:11
msgid "This function is the same as the C++ method OGRFeature::SetNativeData()."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:1
msgid ""
"void OGR_F_SetNativeMediaType(OGRFeatureH hFeat, const char "
"\\*pszNativeMediaType)"
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:5
msgid "Sets the native media type for the feature."
msgstr ""

#: of osgeo.ogr.Feature.SetNativeMediaType:12
msgid ""
"This function is the same as the C++ method "
"OGRFeature::SetNativeMediaType()."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:1
msgid "void OGR_F_SetStyleString(OGRFeatureH hFeat, const char \\*pszStyle)"
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:4
msgid "Set feature style string."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:6
msgid ""
"This method operate exactly as OGR_F_SetStyleStringDirectly() except that"
" it does not assume ownership of the passed string, but instead makes a "
"copy of it."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:10
msgid "This function is the same as the C++ method OGRFeature::SetStyleString()."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:13
msgid "handle to the feature to set style to."
msgstr ""

#: of osgeo.ogr.Feature.SetStyleString:14
msgid "the style string to apply to this feature, cannot be NULL."
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:1
msgid "void OGR_F_UnsetField(OGRFeatureH hFeat, int iField)"
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:3
msgid "Clear a field, marking it as unset."
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:5
msgid "This function is the same as the C++ method OGRFeature::UnsetField()."
msgstr ""

#: of osgeo.ogr.Feature.UnsetField:8
msgid "the field to unset."
msgstr ""

#: of osgeo.ogr.Feature.Validate:1
msgid "int OGR_F_Validate(OGRFeatureH hFeat, int nValidateFlags, int bEmitError)"
msgstr ""

#: of osgeo.ogr.Feature.Validate:4
msgid "Validate that a feature meets constraints of its schema."
msgstr ""

#: of osgeo.ogr.Feature.Validate:6
msgid "The scope of test is specified with the nValidateFlags parameter."
msgstr ""

#: of osgeo.ogr.Feature.Validate:8
msgid ""
"Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width "
"must be interpreted as the number of UTF-8 characters. Some drivers might"
" interpret the width as the number of bytes instead. So this test is "
"rather conservative (if it fails, then it will fail for all "
"interpretations)."
msgstr ""

#: of osgeo.ogr.Feature.Validate:14
msgid "This function is the same as the C++ method OGRFeature::Validate()."
msgstr ""

#: of osgeo.ogr.Feature.Validate:18
msgid "handle to the feature to validate."
msgstr ""

#: of osgeo.ogr.Feature.Validate:19
msgid ""
"OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL, OGR_F_VAL_GEOM_TYPE, "
"OGR_F_VAL_WIDTH and OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with '|' operator"
msgstr ""

#: of osgeo.ogr.Feature.Validate:22
msgid "TRUE if a CPLError() must be emitted when a check fails"
msgstr ""

#: of osgeo.ogr.Feature.Validate:24
msgid "TRUE if all enabled validation tests pass."
msgstr ""

#: of osgeo.ogr.Feature.geometry:8
msgid "The GetGeometryRef() method is also available as an alias of geometry()"
msgstr ""

#: of osgeo.ogr.Feature.items:1
msgid ""
"Return a dictionary with the field names as key, and their value in the "
"feature"
msgstr ""

#: of osgeo.ogr.Feature.keys:1
msgid "Return the list of field names (of the layer definition)"
msgstr ""

#: ../../source/api/python/vector_api.rst:40
msgid "Geometry"
msgstr ""

#: of osgeo.ogr.Geometry:1
msgid "Proxy of C++ OGRGeometryShadow class."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:1
msgid "Assign spatial reference to this object."
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:3
msgid "For more details: :cpp:func:`OGR_G_AssignSpatialReference`"
msgstr ""

#: of osgeo.ogr.Geometry.AssignSpatialReference:5
msgid "The new spatial reference system to apply."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:1
msgid "Compute boundary."
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:3
msgid "For more details: :cpp:func:`OGR_G_Boundary`"
msgstr ""

#: of osgeo.ogr.Geometry.Boundary:5 osgeo.ogr.Geometry.Polygonize:5
msgid "A new geometry or None on failure."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:1
msgid "Compute buffer of geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:3
msgid "For more details: :cpp:func:`OGR_G_Buffer`"
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:5
msgid ""
"The buffer distance to be applied. Should be expressed into the same unit"
" as the coordinates of the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:8
msgid ""
"The number of segments used to approximate a 90 degree (quadrant) of "
"curvature."
msgstr ""

#: of osgeo.ogr.Geometry.Buffer:12
msgid "The newly created geometry or None if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:1
msgid "Compute the geometry centroid."
msgstr ""

#: of osgeo.ogr.Geometry.Centroid:3
msgid "For more details: :cpp:func:`OGR_G_Centroid`"
msgstr ""

#: of osgeo.ogr.Geometry.Clone:1
msgid "Make a copy of this object."
msgstr ""

#: of osgeo.ogr.Geometry.Clone:3
msgid "For more details: :cpp:func:`OGR_G_Clone`"
msgstr ""

#: of osgeo.ogr.Geometry.Clone:5
msgid ""
"The copy of the geometry with the same spatial reference system as the "
"original."
msgstr ""

#: of osgeo.ogr.Geometry.CloseRings:1
msgid "Force rings to be closed."
msgstr ""

#: of osgeo.ogr.Geometry.CloseRings:3
msgid "For more details: :cpp:func:`OGR_G_CloseRings`"
msgstr ""

#: of osgeo.ogr.Geometry.Contains:1 osgeo.ogr.Geometry.Within:1
msgid "Test for containment."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:3
msgid "For more details: :cpp:func:`OGR_G_Contains`"
msgstr ""

#: of osgeo.ogr.Geometry.Contains:5 osgeo.ogr.Geometry.Crosses:5
#: osgeo.ogr.Geometry.Overlaps:5 osgeo.ogr.Geometry.Touches:5
#: osgeo.ogr.Geometry.Within:5
msgid "the other geometry to compare."
msgstr ""

#: of osgeo.ogr.Geometry.Contains:8
msgid "True if this contains the other geometry, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:1
msgid "Compute convex hull."
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:3
msgid "For more details: :cpp:func:`OGR_G_ConvexHull`"
msgstr ""

#: of osgeo.ogr.Geometry.ConvexHull:5
msgid ""
"a handle to A newly allocated geometry now owned by the caller, or None "
"on failure."
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:1
#: osgeo.ogr.Geometry.GetCoordinateDimension:1
msgid "Get the dimension of the coordinates in this geometry."
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:3
msgid "For more details: :cpp:func:`OGR_G_CoordinateDimension`"
msgstr ""

#: of osgeo.ogr.Geometry.CoordinateDimension:7
msgid "This will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data."
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:1
msgid "Test for crossing."
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:3
msgid "For more details: :cpp:func:`OGR_G_Crosses`"
msgstr ""

#: of osgeo.ogr.Geometry.Crosses:8
msgid "True if they are crossing, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:1
msgid "Return a Delaunay triangulation of the vertices of the geometry."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:3
msgid "For more details: :cpp:func:`OGR_G_DelaunayTriangulation`"
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:7
msgid "optional snapping tolerance to use for improved robustness"
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:9
msgid ""
"If True, will return a MULTILINESTRING, otherwise it will return a "
"GEOMETRYCOLLECTION containing triangular POLYGONs."
msgstr ""

#: of osgeo.ogr.Geometry.DelaunayTriangulation:13
msgid ""
"The geometry resulting from the Delaunay triangulation or None if an "
"error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:1
msgid "Compute difference."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:3
msgid "For more details: :cpp:func:`OGR_G_Difference`"
msgstr ""

#: of osgeo.ogr.Geometry.Difference:5 osgeo.ogr.Geometry.Intersection:5
#: osgeo.ogr.Geometry.Union:5
msgid "The other geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Difference:8
msgid ""
"A new geometry representing the difference or None if the difference is "
"empty or an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:1
msgid "Test for disjointness."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:3
msgid "For more details: :cpp:func:`OGR_G_Disjoint`"
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:5
msgid "The other geometry to compare."
msgstr ""

#: of osgeo.ogr.Geometry.Disjoint:8
msgid "True if they are disjoint, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:1
msgid "Compute distance between two geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:3
msgid "For more details: :cpp:func:`OGR_G_Distance`"
msgstr ""

#: of osgeo.ogr.Geometry.Distance:5 osgeo.ogr.Geometry.Distance3D:7
msgid "The other geometry to compare against."
msgstr ""

#: of osgeo.ogr.Geometry.Distance:8 osgeo.ogr.Geometry.Distance3D:10
msgid "The distance between the geometries or -1 if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:1
msgid "Returns the 3D distance between two geometries."
msgstr ""

#: of osgeo.ogr.Geometry.Distance3D:3
msgid "For more details: :cpp:func:`OGR_G_Distance3D`"
msgstr ""

#: of osgeo.ogr.Geometry.Empty:1
msgid "Clear geometry information."
msgstr ""

#: of osgeo.ogr.Geometry.Empty:3
msgid "For more details: :cpp:func:`OGR_G_Empty`"
msgstr ""

#: of osgeo.ogr.Geometry.Equals:1
msgid "Returns True if two geometries are equivalent."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:3
msgid "For more details: :cpp:func:`OGR_G_Equals`"
msgstr ""

#: of osgeo.ogr.Geometry.Equals:5 osgeo.ogr.Geometry.Intersects:5
msgid "The other geometry to test against."
msgstr ""

#: of osgeo.ogr.Geometry.Equals:8
msgid "True if equivalent or False otherwise."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:1
msgid ""
"Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary "
"format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:4
msgid "For more details: :cpp:func:`OGR_G_ExportToIsoWkb`"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkb:8 osgeo.ogr.Geometry.ExportToWkb:5
msgid "One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:1
msgid ""
"Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text "
"format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToIsoWkt:4
msgid "For more details: :cpp:func:`OGR_G_ExportToIsoWkt`"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:1
msgid "Convert a geometry well known binary format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkb:3
msgid "For more details: :cpp:func:`OGR_G_ExportToWkb`"
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:1
msgid "Convert a geometry into well known text format."
msgstr ""

#: of osgeo.ogr.Geometry.ExportToWkt:3
msgid "For more details: :cpp:func:`OGR_G_ExportToWkt`"
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:1
msgid "Convert geometry to strictly 2D."
msgstr ""

#: of osgeo.ogr.Geometry.FlattenTo2D:3
msgid "For more details: :cpp:func:`OGR_G_FlattenTo2D`"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:1
msgid "Compute boundary (deprecated)"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:3
msgid "For more details: :cpp:func:`OGR_G_GetBoundary`"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:5
msgid "..warning:: Deprecated"
msgstr ""

#: of osgeo.ogr.Geometry.GetBoundary:7
msgid "See: :cpp:func:`OGR_G_Boundary`"
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:3
msgid "For more details: :cpp:func:`OGR_G_GetCoordinateDimension`"
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:5
msgid ""
"Deprecated. Use :py:func:`CoordinateDimension`, :py:func:`Is3D`, or "
":py:func:`IsMeasured`."
msgstr ""

#: of osgeo.ogr.Geometry.GetCoordinateDimension:8
msgid "This will return 2 or 3."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:1
msgid "Get the dimension of this geometry."
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:3
msgid "For more details: :cpp:func:`OGR_G_GetDimension`"
msgstr ""

#: of osgeo.ogr.Geometry.GetDimension:5
msgid "0 for points, 1 for lines, and 2 for surfaces."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:1
msgid ""
"Computes and returns the bounding envelope for this geometry in the "
"passed psEnvelope structure."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope:4
msgid "For more details: :cpp:func:`OGR_G_GetEnvelope`"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:1
msgid ""
"Computes and returns the bounding envelope (3D) for this geometry in the "
"passed psEnvelope structure."
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:4
msgid "For more details: :cpp:func:`OGR_G_GetEnvelope3D`"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:8
msgid ""
"* **minx** (*float*) * **maxx** (*float*) * **miny** (*float*) * **maxy**"
" (*float*) * **minz** (*float*) * **maxz** (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:12
msgid "**minz** (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetEnvelope3D:13
msgid "**maxz** (*float*)"
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:1
msgid "Fetch WKT name for geometry type."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:3
msgid "For more details: :cpp:func:`OGR_G_GetGeometryName`"
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryName:5
msgid "geometry to get name from."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:1
msgid "Fetch geometry type."
msgstr ""

#: of osgeo.ogr.Geometry.GetGeometryType:3
msgid "For more details: :cpp:func:`OGR_G_GetGeometryType`"
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:1
msgid "For more details: :cpp:func:`OGR_G_GetSpatialReference`"
msgstr ""

#: of osgeo.ogr.Geometry.GetSpatialReference:3
msgid "Returns spatial reference system for geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:1
msgid "Compute intersection."
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:3
msgid "For more details: :cpp:func:`OGR_G_Intersection`"
msgstr ""

#: of osgeo.ogr.Geometry.Intersection:8
msgid ""
"A new geometry representing the intersection or None if there is no "
"intersection or an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:1
msgid "Determines whether two geometries intersect."
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:3
msgid "For more details: :cpp:func:`OGR_G_Intersects`"
msgstr ""

#: of osgeo.ogr.Geometry.Intersects:8
msgid "True if the geometries intersect, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:1
msgid "See whether this geometry has Z coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:3
msgid "For more details: :cpp:func:`OGR_G_Is3D`"
msgstr ""

#: of osgeo.ogr.Geometry.Is3D:7
msgid "True if the geometry has Z coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:1
msgid "Test if the geometry is empty."
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:3
msgid "For more details: :cpp:func:`OGR_G_IsEmpty`"
msgstr ""

#: of osgeo.ogr.Geometry.IsEmpty:5 osgeo.ogr.Geometry.IsRing:5
#: osgeo.ogr.Geometry.IsValid:5
msgid "True if the geometry has no points, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:1
msgid "See whether this geometry is measured."
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:3
msgid "For more details: :cpp:func:`OGR_G_IsMeasured`"
msgstr ""

#: of osgeo.ogr.Geometry.IsMeasured:7
msgid "True if the geometry has M coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.IsRing:1
msgid "Test if the geometry is a ring."
msgstr ""

#: of osgeo.ogr.Geometry.IsRing:3
msgid "For more details: :cpp:func:`OGR_G_IsRing`"
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:1
msgid "Returns True if the geometry is simple."
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:3
msgid "For more details: :cpp:func:`OGR_G_IsSimple`"
msgstr ""

#: of osgeo.ogr.Geometry.IsSimple:5
msgid "True if object is simple, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.IsValid:1
msgid "Test if the geometry is valid."
msgstr ""

#: of osgeo.ogr.Geometry.IsValid:3
msgid "For more details: :cpp:func:`OGR_G_IsValid`"
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:1
msgid "Attempts to make an invalid geometry valid without losing vertices."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:3
msgid "For more details: :cpp:func:`OGR_G_MakeValidEx`"
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:6
msgid "options"
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:8
msgid "papszOptions to be passed in. For example: [\"METHOD=STRUCTURE\"]."
msgstr ""

#: of osgeo.ogr.Geometry.MakeValid:11 osgeo.ogr.Geometry.Normalize:7
msgid "A newly allocated geometry now owned by the caller, or None on failure."
msgstr ""

#: of osgeo.ogr.Geometry.Normalize:1
msgid "Attempts to bring geometry into normalized/canonical form."
msgstr ""

#: of osgeo.ogr.Geometry.Normalize:3
msgid "For more details: :cpp:func:`OGR_G_Normalize`"
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:1
msgid "Test for overlap."
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:3
msgid "For more details: :cpp:func:`OGR_G_Overlaps`"
msgstr ""

#: of osgeo.ogr.Geometry.Overlaps:8
msgid "True if they are overlapping, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:1
msgid "Returns a point guaranteed to lie on the surface."
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:3
msgid "For more details: :cpp:func:`OGR_G_PointOnSurface`"
msgstr ""

#: of osgeo.ogr.Geometry.PointOnSurface:5
msgid "A point guaranteed to lie on the surface or None if an error occurred."
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:1
msgid "Polygonizes a set of sparse edges."
msgstr ""

#: of osgeo.ogr.Geometry.Polygonize:3
msgid "For more details: :cpp:func:`OGR_G_Polygonize`"
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:1
msgid "Modify the geometry such it has no segment longer then the given distance."
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:4
msgid "For more details: :cpp:func:`OGR_G_Segmentize`"
msgstr ""

#: of osgeo.ogr.Geometry.Segmentize:6
msgid "the maximum distance between 2 points after segmentization"
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:1
msgid "Add or remove the Z coordinate dimension."
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:3
msgid "For more details: :cpp:func:`OGR_G_Set3D`"
msgstr ""

#: of osgeo.ogr.Geometry.Set3D:7
msgid "Should the geometry have a Z dimension, either True or False."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:1
msgid "Set the coordinate dimension."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:3
msgid "For more details: :cpp:func:`OGR_G_SetCoordinateDimension`"
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:5
msgid "Deprecated. Use :py:func:`Set3D` or :py:func:`SetMeasured`."
msgstr ""

#: of osgeo.ogr.Geometry.SetCoordinateDimension:7
msgid "New coordinate dimension value, either 2 or 3."
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:1
msgid "Add or remove the M coordinate dimension."
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:3
msgid "For more details: :cpp:func:`OGR_G_SetMeasured`"
msgstr ""

#: of osgeo.ogr.Geometry.SetMeasured:7
msgid "Should the geometry have a M dimension, either True or False."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:1
msgid "Compute a simplified geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:3
msgid "For more details: :cpp:func:`OGR_G_Simplify`"
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:5
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:5
msgid "The distance tolerance for the simplification."
msgstr ""

#: of osgeo.ogr.Geometry.Simplify:8
#: osgeo.ogr.Geometry.SimplifyPreserveTopology:8
msgid "The simplified geometry or None if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.SimplifyPreserveTopology:1
msgid "Simplify the geometry while preserving topology."
msgstr ""

#: of osgeo.ogr.Geometry.SimplifyPreserveTopology:3
msgid "For more details: :cpp:func:`OGR_G_SimplifyPreserveTopology`"
msgstr ""

#: of osgeo.ogr.Geometry.SwapXY:1
msgid "Swap x and y coordinates."
msgstr ""

#: of osgeo.ogr.Geometry.SwapXY:3
msgid "For more details: :cpp:func:`OGR_G_SwapXY`"
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:1
msgid "Compute symmetric difference."
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:3
msgid "For more details: :cpp:func:`OGR_G_SymDifference`"
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:5
msgid "the other geometry."
msgstr ""

#: of osgeo.ogr.Geometry.SymDifference:7
msgid ""
"A new geometry representing the symmetric difference or None if the "
"difference is empty or an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.SymmetricDifference:1
msgid "Compute symmetric difference (deprecated)"
msgstr ""

#: of osgeo.ogr.Geometry.SymmetricDifference:3
msgid "For more details: :cpp:func:`OGR_G_SymmetricDifference`"
msgstr ""

#: of osgeo.ogr.Geometry.SymmetricDifference:5
msgid "Deprecated"
msgstr ""

#: of osgeo.ogr.Geometry.Touches:1
msgid "Test for touching."
msgstr ""

#: of osgeo.ogr.Geometry.Touches:3
msgid "For more details: :cpp:func:`OGR_G_Touches`"
msgstr ""

#: of osgeo.ogr.Geometry.Touches:7
msgid "True if they are touching, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:1
msgid "Apply arbitrary coordinate transformation to geometry."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:3
msgid "For more details: :cpp:func:`OGR_G_Transform`"
msgstr ""

#: of osgeo.ogr.Geometry.Transform:5
msgid "The transformation to apply."
msgstr ""

#: of osgeo.ogr.Geometry.Transform:8
msgid "The transformed geometry."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:1
msgid "Transform geometry to new spatial reference system."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:3
msgid "For more details: :cpp:func:`OGR_G_TransformTo`"
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:5
msgid "The spatial reference system to apply."
msgstr ""

#: of osgeo.ogr.Geometry.TransformTo:8
msgid ":py:const:`osgeo.ogr.OGRERR_NONE` on success, or an error code."
msgstr ""

#: of osgeo.ogr.Geometry.Union:1
msgid "Compute union."
msgstr ""

#: of osgeo.ogr.Geometry.Union:3
msgid "For more details: :cpp:func:`OGR_G_Union`"
msgstr ""

#: of osgeo.ogr.Geometry.Union:8 osgeo.ogr.Geometry.UnionCascaded:5
msgid "A new geometry representing the union or None if an error occurs."
msgstr ""

#: of osgeo.ogr.Geometry.UnionCascaded:1
msgid "Compute union using cascading."
msgstr ""

#: of osgeo.ogr.Geometry.UnionCascaded:3
msgid "For more deails: :cpp:func:`OGR_G_UnionCascaded`"
msgstr ""

#: of osgeo.ogr.Geometry.Within:3
msgid "For more details: :cpp:func:`OGR_G_Within`"
msgstr ""

#: of osgeo.ogr.Geometry.Within:8
msgid "True if this is within other, otherwise False."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:1
msgid "Returns size of related binary representation."
msgstr ""

#: of osgeo.ogr.Geometry.WkbSize:3
msgid "For more details: :cpp:func:`OGR_G_WkbSize`"
msgstr ""

#: ../../source/api/python/vector_api.rst:98
msgid "FeatureDefn"
msgstr ""

#: of osgeo.ogr.FeatureDefn:1
msgid "Proxy of C++ OGRFeatureDefnShadow class."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:1
msgid "void OGR_FD_AddFieldDefn(OGRFeatureDefnH hDefn, OGRFieldDefnH hNewField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:4
#: osgeo.ogr.FeatureDefn.AddGeomFieldDefn:5
msgid "Add a new field definition to the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:6
msgid ""
"To add a new field definition to a layer definition, do not use this "
"function directly, but use OGR_L_CreateField() instead."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:9
msgid ""
"This function should only be called while there are no OGRFeature objects"
" in existence based on this OGRFeatureDefn. The OGRFieldDefn passed in is"
" copied, and remains the responsibility of the caller."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:13
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::AddFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:16
msgid "handle to the feature definition to add the field definition to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddFieldDefn:17
#: osgeo.ogr.FeatureDefn.AddGeomFieldDefn:22
msgid "handle to the new field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:1
msgid ""
"void OGR_FD_AddGeomFieldDefn(OGRFeatureDefnH hDefn, OGRGeomFieldDefnH "
"hNewGeomField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:7
msgid ""
"To add a new field definition to a layer definition, do not use this "
"function directly, but use OGR_L_CreateGeomField() instead."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:10
msgid ""
"This function should only be called while there are no OGRFeature objects"
" in existence based on this OGRFeatureDefn. The OGRGeomFieldDefn passed "
"in is copied, and remains the responsibility of the caller."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:15
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::AddGeomFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.AddGeomFieldDefn:20
msgid "handle to the feature definition to add the geometry field definition to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:1
msgid "OGRErr OGR_FD_DeleteGeomFieldDefn(OGRFeatureDefnH hDefn, int iGeomField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:4
msgid "Delete an existing geometry field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:6
msgid ""
"To delete an existing geometry field definition from a layer definition, "
"do not use this function directly, but use OGR_L_DeleteGeomField() "
"instead ( not implemented yet)."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:10
msgid ""
"This method should only be called while there are no OGRFeature objects "
"in existence based on this OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:13
msgid ""
"This method is the same as the C++ method "
"OGRFeatureDefn::DeleteGeomFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:18
msgid "handle to the feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:19
msgid "the index of the geometry field definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.DeleteGeomFieldDefn:21
msgid "OGRERR_NONE in case of success."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:1
msgid "int OGR_FD_GetFieldCount(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:4
msgid "Fetch number of fields on the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:6
msgid "This function is the same as the C++ OGRFeatureDefn::GetFieldCount()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldCount:8
#: osgeo.ogr.FeatureDefn.GetGeomFieldCount:11
msgid "handle to the feature definition to get the fields count from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:1
msgid "OGRFieldDefnH OGR_FD_GetFieldDefn(OGRFeatureDefnH hDefn, int iField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:4
msgid "Fetch field definition of the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:9
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn:11
msgid "handle to the feature definition to get the field definition from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:10
msgid "the field to fetch, between 0 and GetFieldCount()-1."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldDefn:12
#: osgeo.ogr.FeatureDefn.GetGeomFieldDefn:14
msgid ""
"a handle to an internal field definition object or NULL if invalid index."
" This object should not be modified or freed by the application."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:1
msgid ""
"int OGR_FD_GetFieldIndex(OGRFeatureDefnH hDefn, const char "
"\\*pszFieldName)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:4
msgid "Find field by name."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:6
msgid ""
"The field index of the first field matching the passed field name (case "
"insensitively) is returned."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:9
msgid "This function is the same as the C++ method OGRFeatureDefn::GetFieldIndex."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:12
#: osgeo.ogr.FeatureDefn.GetGeomFieldIndex:13
msgid "handle to the feature definition to get field index from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:13
msgid "the field name to search for."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetFieldIndex:15
msgid "the field index, or -1 if no match found."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldCount:1
msgid "int OGR_FD_GetGeomFieldCount(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldCount:4
msgid "Fetch number of geometry fields on the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldCount:6
msgid "This function is the same as the C++ OGRFeatureDefn::GetGeomFieldCount()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:1
msgid ""
"OGRGeomFieldDefnH OGR_FD_GetGeomFieldDefn(OGRFeatureDefnH hDefn, int "
"iGeomField)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:4
msgid "Fetch geometry field definition of the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetGeomFieldDefn()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldDefn:12
msgid "the geometry field to fetch, between 0 and GetGeomFieldCount() - 1."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:1
msgid ""
"int OGR_FD_GetGeomFieldIndex(OGRFeatureDefnH hDefn, const char "
"\\*pszGeomFieldName)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:5
msgid "Find geometry field by name."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:7
msgid ""
"The geometry field index of the first geometry field matching the passed "
"field name (case insensitively) is returned."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:10
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetGeomFieldIndex."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:14
msgid "the geometry field name to search for."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomFieldIndex:16
msgid "the geometry field index, or -1 if no match found."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:1
msgid "OGRwkbGeometryType OGR_FD_GetGeomType(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:4
msgid "Fetch the geometry base type of the passed feature definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:6
msgid "This function is the same as the C++ method OGRFeatureDefn::GetGeomType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:9
msgid ""
"Starting with GDAL 1.11, this method returns "
"GetGeomFieldDefn(0)->GetType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:12
msgid "handle to the feature definition to get the geometry type from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetGeomType:14
msgid "the base type for all geometry related to this definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:1
msgid "const char\\* OGR_FD_GetName(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:4
msgid "Get name of the OGRFeatureDefn passed as an argument."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:6
msgid "This function is the same as the C++ method OGRFeatureDefn::GetName()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:8
msgid "handle to the feature definition to get the name from."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetName:10
msgid "the name. This name is internal and should not be modified, or freed."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:1
msgid "int OGR_FD_GetReferenceCount(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:4
msgid "Fetch current reference count."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::GetReferenceCount()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:9
#: osgeo.ogr.FeatureDefn.IsGeometryIgnored:12 osgeo.ogr.FeatureDefn.IsSame:8
#: osgeo.ogr.FeatureDefn.SetGeometryIgnored:12
#: osgeo.ogr.FeatureDefn.SetStyleIgnored:9
msgid "handle to the feature definition on witch OGRFeature are based on."
msgstr ""

#: of osgeo.ogr.FeatureDefn.GetReferenceCount:11
msgid "the current reference count."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:1
msgid "int OGR_FD_IsGeometryIgnored(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:4
msgid "Determine whether the geometry can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::IsGeometryIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:9
msgid ""
"Starting with GDAL 1.11, this method returns "
"GetGeomFieldDefn(0)->IsIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsGeometryIgnored:14
#: osgeo.ogr.FeatureDefn.IsStyleIgnored:11
#: osgeo.ogr.FeatureDefn.SetGeometryIgnored:13
#: osgeo.ogr.FeatureDefn.SetStyleIgnored:10 osgeo.ogr.FieldDefn.IsIgnored:10
#: osgeo.ogr.FieldDefn.SetIgnored:9
msgid "ignore state"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:1
msgid "int OGR_FD_IsSame(OGRFeatureDefnH hFDefn, OGRFeatureDefnH hOtherFDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:4
msgid "Test if the feature definition is identical to the other one."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:9
msgid "handle to the other feature definition to compare to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsSame:11
msgid "TRUE if the feature definition is identical to the other one."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:1
msgid "int OGR_FD_IsStyleIgnored(OGRFeatureDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:4
msgid "Determine whether the style can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::IsStyleIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.IsStyleIgnored:9
msgid "handle to the feature definition on which OGRFeature are based on."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:1
msgid "void OGR_FD_SetGeomType(OGRFeatureDefnH hDefn, OGRwkbGeometryType eType)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:4
msgid ""
"Assign the base geometry type for the passed layer (the same as the "
"feature definition)."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:7
msgid ""
"All geometry objects using this type must be of the defined type or a "
"derived type. The default upon creation is wkbUnknown which allows for "
"any geometry type. The geometry type should generally not be changed "
"after any OGRFeatures have been created against this definition."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:12
msgid "This function is the same as the C++ method OGRFeatureDefn::SetGeomType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:15
msgid "Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)->SetType()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:18
msgid "handle to the layer or feature definition to set the geometry type to."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeomType:19
msgid "the new type to assign."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:1
msgid "void OGR_FD_SetGeometryIgnored(OGRFeatureDefnH hDefn, int bIgnore)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:4
msgid "Set whether the geometry can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::SetGeometryIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetGeometryIgnored:9
msgid ""
"Starting with GDAL 1.11, this method calls "
"GetGeomFieldDefn(0)->SetIgnored()."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetStyleIgnored:1
msgid "void OGR_FD_SetStyleIgnored(OGRFeatureDefnH hDefn, int bIgnore)"
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetStyleIgnored:4
msgid "Set whether the style can be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FeatureDefn.SetStyleIgnored:6
msgid ""
"This function is the same as the C++ method "
"OGRFeatureDefn::SetStyleIgnored()."
msgstr ""

#: ../../source/api/python/vector_api.rst:106
msgid "FieldDefn"
msgstr ""

#: of osgeo.ogr.FieldDefn:1
msgid "Proxy of C++ OGRFieldDefnShadow class."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:1
msgid "const char\\* OGR_Fld_GetAlternativeNameRef(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:4
msgid "Fetch the alternative name (or \"alias\") for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:6
#: osgeo.ogr.FieldDefn.SetAlternativeName:7
msgid ""
"The alternative name is an optional attribute for a field which can "
"provide a more user-friendly, descriptive name of a field which is not "
"subject to the usual naming constraints defined by the data provider."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:10
#: osgeo.ogr.FieldDefn.SetAlternativeName:11
msgid ""
"This is a metadata style attribute only: the alternative name cannot be "
"used in place of the actual field name during SQL queries or other field "
"name dependent API calls."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:14
msgid ""
"This function is the same as the CPP method "
"OGRFieldDefn::GetAlternativeNameRef()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:19
#: osgeo.ogr.FieldDefn.GetDefault:11 osgeo.ogr.FieldDefn.GetNameRef:9
#: osgeo.ogr.FieldDefn.SetDefault:29
msgid "handle to the field definition."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetAlternativeNameRef:21
msgid "the alternative name of the field definition."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:1
msgid "const char\\* OGR_Fld_GetDefault(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:4
msgid "Get default field value."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:6
msgid "This function is the same as the C++ method OGRFieldDefn::GetDefault()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDefault:13
msgid "default field value or NULL."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:1
msgid "const char\\* OGR_Fld_GetDomainName(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:4
msgid "Return the name of the field domain for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:6
msgid "By default, none (empty string) is returned."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:8
msgid ""
"Field domains ( OGRFieldDomain class) are attached at the GDALDataset "
"level and should be retrieved with GDALDatasetGetFieldDomain()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:11
msgid "This method is the same as the C++ method OGRFieldDefn::GetDomainName()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:16
#: osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:16
#: osgeo.ogr.FieldDefn.IsIgnored:8 osgeo.ogr.FieldDefn.IsNullable:17
#: osgeo.ogr.FieldDefn.IsUnique:12 osgeo.ogr.FieldDefn.SetDomainName:13
#: osgeo.ogr.FieldDefn.SetIgnored:8 osgeo.ogr.FieldDefn.SetNullable:16
#: osgeo.ogr.FieldDefn.SetUnique:17
msgid "handle to the field definition"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetDomainName:18
msgid "the field domain name, or an empty string if there is none."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:1
msgid "OGRJustification OGR_Fld_GetJustify(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:4 osgeo.ogr.FieldDefn.justify:5
msgid "Get the justification for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:6 osgeo.ogr.FieldDefn.justify:7
msgid "This function is the same as the CPP method OGRFieldDefn::GetJustify()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:9 osgeo.ogr.FieldDefn.SetJustify:6
#: osgeo.ogr.FieldDefn.justify:10
msgid "Note: no driver is know to use the concept of field justification."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:11 osgeo.ogr.FieldDefn.justify:12
msgid "handle to the field definition to get justification from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetJustify:13 osgeo.ogr.FieldDefn.justify:14
msgid "the justification."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:1
msgid "const char\\* OGR_Fld_GetNameRef(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:4
msgid "Fetch name of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:6
msgid "This function is the same as the CPP method OGRFieldDefn::GetNameRef()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetNameRef:11
msgid "the name of the field definition."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:1
msgid "int OGR_Fld_GetPrecision(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:4 osgeo.ogr.FieldDefn.precision:5
msgid "Get the formatting precision for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:6 osgeo.ogr.FieldDefn.SetPrecision:6
#: osgeo.ogr.FieldDefn.precision:7
msgid "This should normally be zero for fields of types other than OFTReal."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:8 osgeo.ogr.FieldDefn.precision:9
msgid "This function is the same as the CPP method OGRFieldDefn::GetPrecision()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:11 osgeo.ogr.FieldDefn.precision:12
msgid "handle to the field definition to get precision from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetPrecision:13 osgeo.ogr.FieldDefn.precision:14
msgid "the precision."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:1
msgid "OGRFieldSubType OGR_Fld_GetSubType(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:4
msgid "Fetch subtype of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:6
msgid "This function is the same as the CPP method OGRFieldDefn::GetSubType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:11
msgid "handle to the field definition to get subtype from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetSubType:13
msgid "field subtype."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:1
msgid "OGRFieldType OGR_Fld_GetType(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:4 osgeo.ogr.FieldDefn.type:5
msgid "Fetch type of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:6 osgeo.ogr.FieldDefn.type:7
msgid "This function is the same as the CPP method OGRFieldDefn::GetType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:8 osgeo.ogr.FieldDefn.type:9
msgid "handle to the field definition to get type from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetType:10 osgeo.ogr.FieldDefn.type:11
msgid "field type."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:1
msgid "int OGR_Fld_GetWidth(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:4 osgeo.ogr.FieldDefn.width:5
msgid "Get the formatting width for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:6 osgeo.ogr.FieldDefn.width:7
msgid "This function is the same as the CPP method OGRFieldDefn::GetWidth()."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:8 osgeo.ogr.FieldDefn.width:9
msgid "handle to the field definition to get width from."
msgstr ""

#: of osgeo.ogr.FieldDefn.GetWidth:10 osgeo.ogr.FieldDefn.width:11
msgid "the width, zero means no specified width."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:1
msgid "int OGR_Fld_IsDefaultDriverSpecific(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:4
msgid "Returns whether the default value is driver specific."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:6
msgid ""
"Driver specific default values are those that are not NULL, a numeric "
"value, a literal value enclosed between single quote characters, "
"CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal value."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:11
msgid ""
"This function is the same as the C++ method "
"OGRFieldDefn::IsDefaultDriverSpecific()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsDefaultDriverSpecific:18
msgid "TRUE if the default value is driver specific."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsIgnored:1
msgid "int OGR_Fld_IsIgnored(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsIgnored:4
msgid "Return whether this field should be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsIgnored:6
msgid "This method is the same as the C++ method OGRFieldDefn::IsIgnored()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:1
msgid "int OGR_Fld_IsNullable(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:4
msgid "Return whether this field can receive null values."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:6
msgid "By default, fields are nullable."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:8
msgid ""
"Even if this method returns FALSE (i.e not-nullable field), it doesn't "
"mean that OGRFeature::IsFieldSet() will necessary return TRUE, as fields "
"can be temporary unset and null/not-null validation is usually done when "
"OGRLayer::CreateFeature()/SetFeature() is called."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:13
msgid "This method is the same as the C++ method OGRFieldDefn::IsNullable()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsNullable:19
msgid "TRUE if the field is authorized to be null."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:1
msgid "int OGR_Fld_IsUnique(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:4
msgid "Return whether this field has a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:6
msgid "By default, fields have no unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:8
msgid "This method is the same as the C++ method OGRFieldDefn::IsUnique()."
msgstr ""

#: of osgeo.ogr.FieldDefn.IsUnique:14
msgid "TRUE if the field has a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:1
msgid ""
"void OGR_Fld_SetAlternativeName(OGRFieldDefnH hDefn, const char "
"\\*pszAlternativeName)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:5
msgid "Reset the alternative name (or \"alias\") for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:15
msgid ""
"This function is the same as the CPP method "
"OGRFieldDefn::SetAlternativeName()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:20
msgid "handle to the field definition to apply the new alternative name to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetAlternativeName:21
msgid "the new alternative name to apply."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:1
msgid "void OGR_Fld_SetDefault(OGRFieldDefnH hDefn, const char \\*pszDefault)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:4
msgid "Set default field value."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:6
msgid ""
"The default field value is taken into account by drivers (generally those"
" with a SQL interface) that support it at field creation time. OGR will "
"generally not automatically set the default field value to null fields by"
" itself when calling OGRFeature::CreateFeature() / "
"OGRFeature::SetFeature(), but will let the low-level layers to do the "
"job. So retrieving the feature from the layer is recommended."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:13
msgid ""
"The accepted values are NULL, a numeric value, a literal value enclosed "
"between single quote characters (and inner single quote characters "
"escaped by repetition of the single quote character), CURRENT_TIMESTAMP, "
"CURRENT_TIME, CURRENT_DATE or a driver specific expression (that might be"
" ignored by other drivers). For a datetime literal value, format should "
"be 'YYYY/MM/DD HH:MM:SS[.sss]' (considered as UTC time)."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:21
msgid ""
"Drivers that support writing DEFAULT clauses will advertise the "
"GDAL_DCAP_DEFAULT_FIELDS driver metadata item."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:24
msgid "This function is the same as the C++ method OGRFieldDefn::SetDefault()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDefault:30
msgid "new default field value or NULL pointer."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDomainName:1
msgid ""
"void OGR_Fld_SetDomainName(OGRFieldDefnH hDefn, const char "
"\\*pszFieldName)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDomainName:4
msgid "Set the name of the field domain for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDomainName:6
msgid "Field domains ( OGRFieldDomain) are attached at the GDALDataset level."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDomainName:8
msgid "This method is the same as the C++ method OGRFieldDefn::SetDomainName()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetDomainName:14
msgid "Field domain name."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:1
msgid "void OGR_Fld_SetIgnored(OGRFieldDefnH hDefn, int ignore)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:4
msgid "Set whether this field should be omitted when fetching features."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetIgnored:6
msgid "This method is the same as the C++ method OGRFieldDefn::SetIgnored()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:1
msgid "void OGR_Fld_SetJustify(OGRFieldDefnH hDefn, OGRJustification eJustify)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:4
msgid "Set the justification for this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:8
msgid "This function is the same as the CPP method OGRFieldDefn::SetJustify()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:11
msgid "handle to the field definition to set justification to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetJustify:12
msgid "the new justification."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:1
msgid "void OGR_Fld_SetName(OGRFieldDefnH hDefn, const char \\*pszName)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:4
msgid "Reset the name of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:6
msgid "This function is the same as the CPP method OGRFieldDefn::SetName()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:8
msgid "handle to the field definition to apply the new name to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetName:9
msgid "the new name to apply."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:1
msgid "void OGR_Fld_SetNullable(OGRFieldDefnH hDefn, int bNullableIn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:4
msgid "Set whether this field can receive null values."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:6
msgid ""
"By default, fields are nullable, so this method is generally called with "
"FALSE to set a not-null constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:9
msgid ""
"Drivers that support writing not-null constraint will advertise the "
"GDAL_DCAP_NOTNULL_FIELDS driver metadata item."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:12
msgid "This method is the same as the C++ method OGRFieldDefn::SetNullable()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetNullable:17
msgid "FALSE if the field must have a not-null constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:1
msgid "void OGR_Fld_SetPrecision(OGRFieldDefnH hDefn, int nPrecision)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:4
msgid "Set the formatting precision for this field in characters."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:8
msgid "This function is the same as the CPP method OGRFieldDefn::SetPrecision()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:11
msgid "handle to the field definition to set precision to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetPrecision:12
msgid "the new precision."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:1
msgid "void OGR_Fld_SetSubType(OGRFieldDefnH hDefn, OGRFieldSubType eSubType)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:4
msgid "Set the subtype of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:6 osgeo.ogr.FieldDefn.SetType:6
msgid ""
"This should never be done to an OGRFieldDefn that is already part of an "
"OGRFeatureDefn."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:9
msgid "This function is the same as the CPP method OGRFieldDefn::SetSubType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:14 osgeo.ogr.FieldDefn.SetType:11
msgid "handle to the field definition to set type to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetSubType:15
msgid "the new field subtype."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:1
msgid "void OGR_Fld_SetType(OGRFieldDefnH hDefn, OGRFieldType eType)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:4
msgid "Set the type of this field."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:9
msgid "This function is the same as the CPP method OGRFieldDefn::SetType()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetType:12
msgid "the new field type."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:1
msgid "void OGR_Fld_SetUnique(OGRFieldDefnH hDefn, int bUniqueIn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:4
msgid "Set whether this field has a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:6
msgid ""
"By default, fields have no unique constraint, so this method is generally"
" called with TRUE to set a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:9
msgid ""
"Drivers that support writing unique constraint will advertise the "
"GDAL_DCAP_UNIQUE_FIELDS driver metadata item. field can receive null "
"values."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:13
msgid "This method is the same as the C++ method OGRFieldDefn::SetUnique()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetUnique:18
msgid "TRUE if the field must have a unique constraint."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:1
msgid "void OGR_Fld_SetWidth(OGRFieldDefnH hDefn, int nNewWidth)"
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:4
msgid "Set the formatting width for this field in characters."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:6
msgid "This function is the same as the CPP method OGRFieldDefn::SetWidth()."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:8
msgid "handle to the field definition to set width to."
msgstr ""

#: of osgeo.ogr.FieldDefn.SetWidth:9
msgid "the new width."
msgstr ""

#: of osgeo.ogr.FieldDefn.justify:1
msgid ""
"GetJustify(FieldDefn self) -> OGRJustification OGRJustification "
"OGR_Fld_GetJustify(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.name:1
msgid "GetName(FieldDefn self) -> char const *"
msgstr ""

#: of osgeo.ogr.FieldDefn.precision:1
msgid ""
"GetPrecision(FieldDefn self) -> int int "
"OGR_Fld_GetPrecision(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.type:1
msgid ""
"GetType(FieldDefn self) -> OGRFieldType OGRFieldType "
"OGR_Fld_GetType(OGRFieldDefnH hDefn)"
msgstr ""

#: of osgeo.ogr.FieldDefn.width:1
msgid "GetWidth(FieldDefn self) -> int int OGR_Fld_GetWidth(OGRFieldDefnH hDefn)"
msgstr ""

#: ../../source/api/python/vector_api.rst:118
msgid "GeomFieldDefn"
msgstr ""

#: of osgeo.ogr.GeomFieldDefn:1
msgid "Proxy of C++ OGRGeomFieldDefnShadow class."
msgstr ""

#: of osgeo.ogr.GeomFieldDefn.name:1
msgid "GetName(GeomFieldDefn self) -> char const *"
msgstr ""

#: of osgeo.ogr.GeomFieldDefn.srs:1
msgid "GetSpatialRef(GeomFieldDefn self) -> SpatialReference"
msgstr ""

#: of osgeo.ogr.GeomFieldDefn.type:1
msgid "GetType(GeomFieldDefn self) -> OGRwkbGeometryType"
msgstr ""

#: ../../source/api/python/vector_api.rst:126
msgid "FieldDomain"
msgstr ""

#: of osgeo.ogr.FieldDomain:1
msgid "Proxy of C++ OGRFieldDomainShadow class."
msgstr ""

#: ../../source/api/python/vector_api.rst:140
msgid "Relationship"
msgstr ""

#: of osgeo.gdal.Relationship:1
msgid "Proxy of C++ GDALRelationshipShadow class."
msgstr ""

#: ../../source/api/python/vector_api.rst:148
msgid "StyleTable"
msgstr ""

#: of osgeo.ogr.StyleTable:1
msgid "Proxy of C++ OGRStyleTableShadow class."
msgstr ""

#: ../../source/api/python_bindings.rst:5
msgid "General information"
msgstr ""

#: ../../source/api/python_bindings.rst:7
msgid ""
"This Python package and extensions are a number of tools for programming "
"and manipulating the GDAL_ Geospatial Data Abstraction Library."
msgstr ""

#: ../../source/api/python_bindings.rst:9
msgid ""
"The GDAL project maintains SWIG generated Python bindings for GDAL/OGR. "
"Generally speaking the classes and methods mostly match those of the GDAL"
" and OGR C++ classes. There is no Python specific reference "
"documentation, but the :ref:`tutorials <tutorials>` includes Python "
"examples."
msgstr ""

#: ../../source/api/python_bindings.rst:15
msgid "Dependencies"
msgstr ""

#: ../../source/api/python_bindings.rst:17
msgid "libgdal and header files (gdal-devel)"
msgstr ""

#: ../../source/api/python_bindings.rst:18
msgid ""
"numpy (1.0.0 or greater) and header files (numpy-devel) (not explicitly "
"required, but many examples and utilities will not work without it)"
msgstr ""

#: ../../source/api/python_bindings.rst:25
msgid "Conda"
msgstr ""

#: ../../source/api/python_bindings.rst:27
msgid ""
"GDAL can be quite complex to build and install, particularly on Windows "
"and MacOS. Pre built binaries are provided for the conda system:"
msgstr ""

#: ../../source/api/python_bindings.rst:30
msgid "https://docs.conda.io/en/latest/"
msgstr ""

#: ../../source/api/python_bindings.rst:32
msgid "By the conda-forge project:"
msgstr ""

#: ../../source/api/python_bindings.rst:34
msgid "https://conda-forge.org/"
msgstr ""

#: ../../source/api/python_bindings.rst:36
msgid ""
"Once you have Anaconda or Miniconda installed, you should be able to "
"install GDAL with:"
msgstr ""

#: ../../source/api/python_bindings.rst:38
msgid "``conda install -c conda-forge gdal``"
msgstr ""

#: ../../source/api/python_bindings.rst:41
msgid "Unix"
msgstr ""

#: ../../source/api/python_bindings.rst:43
msgid "The GDAL Python bindings requires setuptools."
msgstr ""

#: ../../source/api/python_bindings.rst:46
msgid "pip"
msgstr ""

#: ../../source/api/python_bindings.rst:48
msgid ""
"GDAL can be installed from the `Python Package Index "
"<https://pypi.org/project/GDAL>`__:"
msgstr ""

#: ../../source/api/python_bindings.rst:55
msgid ""
"In order to enable numpy-based raster support, libgdal and its "
"development headers must be installed as well as the Python packages "
"numpy, setuptools, and wheel. To install the Python dependencies and "
"build numpy-based raster support:"
msgstr ""

#: ../../source/api/python_bindings.rst:65
msgid "Users can verify that numpy-based raster support has been installed with:"
msgstr ""

#: ../../source/api/python_bindings.rst:72
msgid ""
"If this command raises an ImportError, numpy-based raster support has not"
" been properly installed:"
msgstr ""

#: ../../source/api/python_bindings.rst:83
msgid ""
"This is most often due to pip reusing a cached GDAL installation. Verify "
"that the necessary dependencies have been installed and then run the "
"following to force a clean build:"
msgstr ""

#: ../../source/api/python_bindings.rst:92
msgid "Potential issues with GDAL >= 3.9, Python >= 3.9 and NumPy 2.0"
msgstr ""

#: ../../source/api/python_bindings.rst:94
msgid ""
"The pyproject.toml file of GDAL 3.9 requires numpy >= 2.0.0rc1 (for "
"Python >= 3.9) at build time to be able to build bindings that are "
"compatible of both NumPy 1 and NumPy 2. If for some reason the numpy >= "
"2.0.0rc1 build dependency can not be installed, it is possible to "
"manually install the build requirements, and invoke ``pip install`` with "
"the ``--no-build-isolation`` flag."
msgstr ""

#: ../../source/api/python_bindings.rst:108
msgid "Building as part of the GDAL library source tree"
msgstr ""

#: ../../source/api/python_bindings.rst:110
msgid ""
"Python bindings are generated by default when building GDAL from source. "
"For more detail, see :ref:`building-python-bindings`."
msgstr ""

#: ../../source/api/python_bindings.rst:113
msgid ""
"The GDAL Python package is built using `SWIG <https://www.swig.org>`__. "
"The currently supported version is SWIG >= 4"
msgstr ""

#: ../../source/api/python_bindings.rst:120
msgid "Imports"
msgstr ""

#: ../../source/api/python_bindings.rst:122
msgid ""
"There are five major modules that are included with the GDAL_ Python "
"bindings.:"
msgstr ""

#: ../../source/api/python_bindings.rst:135
msgid "API documentation is available at :ref:`python_osgeo`"
msgstr ""

#: ../../source/api/python_bindings.rst:138
msgid "Numpy"
msgstr ""

#: ../../source/api/python_bindings.rst:140
msgid ""
"One advanced feature of the GDAL Python bindings not found in the other "
"language bindings is integration with the Python numerical array "
"facilities. The gdal.Dataset.ReadAsArray() method can be used to read "
"raster data as numerical arrays, ready to use with the Python numerical "
"array capabilities."
msgstr ""

#: ../../source/api/python_bindings.rst:147
msgid "Tutorials"
msgstr ""

#: ../../source/api/python_bindings.rst:149
msgid ""
"Chris Garrard has given courses at Utah State University on "
"\"Geoprocessing with Python using Open Source GIS\" "
"(`http://www.gis.usu.edu/~chrisg/python "
"<http://www.gis.usu.edu/~chrisg/python>`__). There a re many slides, "
"examples, test data... and homework ;-) that can -be greatly helpful for "
"beginners with GDAL/OGR in Python."
msgstr ""

#: ../../source/api/python_bindings.rst:153
msgid ""
"A cookbook full of recipes for using the Python GDAL/OGR bindings : "
"`http://pcjericks.github.io/py-gdalogr-cookbook/index.html "
"<http://pcjericks.github.io/py-gdalogr-cookbook/index.html>`__"
msgstr ""

#: ../../source/api/python_bindings.rst:156
msgid "Gotchas"
msgstr ""

#: ../../source/api/python_bindings.rst:158
msgid ""
"Although GDAL's and OGR's Python bindings provide a fairly \"Pythonic\" "
"wrapper around the underlying C++ code, there are several ways in which "
"the Python bindings differ from typical Python libraries. These "
"differences can catch Python programmers by surprise and lead to "
"unexpected results. These differences result from the complexity of "
"developing a large, long-lived library while continuing to maintain "
"backward compatibility. They are being addressed over time, but until "
"they are all gone, please review this list of :ref:`python_gotchas`."
msgstr ""

#: ../../source/api/python_bindings.rst:163
msgid "Examples"
msgstr ""

#: ../../source/api/python_bindings.rst:165
msgid ""
"An assortment of other samples are available in the `Python github "
"samples directory <https://github.com/OSGeo/gdal/tree/master/swig/python"
"/gdal-utils/osgeo_utils/samples>`__ with some description in the "
":ref:`python_samples`."
msgstr ""

#: ../../source/api/python_bindings.rst:167
msgid ""
"Several `GDAL utilities "
"<https://github.com/OSGeo/gdal/tree/master/swig/python/gdal-"
"utils/osgeo_utils/>`__ are implemented in Python and can be useful "
"examples."
msgstr ""

#: ../../source/api/python_bindings.rst:169
msgid ""
"The majority of GDAL regression tests are written in Python. They are "
"available at `https://github.com/OSGeo/gdal/tree/master/autotest "
"<https://github.com/OSGeo/gdal/tree/master/autotest>`__"
msgstr ""

#: ../../source/api/python_bindings.rst:171
msgid ""
"Some examples of GDAL/numpy integration can be found is found in the "
"following scripts:"
msgstr ""

#: ../../source/api/python_bindings.rst:173
msgid "`gdal_calc.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:174
msgid "`val_repl.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:175
msgid "`gdal_merge.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:176
msgid "`gdal2tiles.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:177
msgid "`gdal2xyz.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:178
msgid "`pct2rgb.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:179
msgid "`gdallocationinfo.py`"
msgstr ""

#: ../../source/api/python_bindings.rst:181
msgid ""
"One example of GDAL/numpy integration is found in the `val_repl.py "
"<https://github.com/OSGeo/gdal/tree/master/swig/python/gdal-"
"utils/osgeo_utils/samples/val_repl.py>`__ script."
msgstr ""

#: ../../source/api/python_bindings.rst:184
msgid "**Performance Notes**"
msgstr ""

#: ../../source/api/python_bindings.rst:186
msgid ""
"ReadAsArray expects to make an entire copy of a raster band or dataset "
"unless the data are explicitly subsetted as part of the function call. "
"For large data, this approach is expected to be prohibitively memory "
"intensive."
msgstr ""

#: ../../source/api/python_gotchas.rst:5
msgid "Python Gotchas in the GDAL and OGR Python Bindings"
msgstr ""

#: ../../source/api/python_gotchas.rst:7
msgid ""
"This page lists aspects of GDAL's and OGR's Python bindings that may "
"catch Python programmers by surprise. If you find something new, feel "
"free to open a pull request adding it to the list. Consider discussing it"
" on the `gdal-dev mailing list <https://lists.osgeo.org/mailman/listinfo"
"/gdal-dev>`__  first, to make sure you fully understand the issue and "
"that others agree that it is unexpected, \"non-Pythonic\", or something "
"that would catch many Python programmers by surprise. Be sure to "
"reference email threads, GitHub tickets, and other sources of additional "
"information."
msgstr ""

#: ../../source/api/python_gotchas.rst:13
msgid ""
"This list is not the place to report bugs. If you believe something is a "
"bug, please `open a ticket <https://github.com/OSGeo/gdal/issues>`__ and "
"report the problem to gdal-dev. Then consider listing it here if it is "
"something related to Python specifically. Do not list it here if it "
"relates to GDAL or OGR generally, and not the Python bindings "
"specifically."
msgstr ""

#: ../../source/api/python_gotchas.rst:16
msgid ""
"Not all items listed here are bugs. Some of these are just how GDAL and "
"OGR work and cannot be fixed easily without breaking existing code. If "
"you don't like how something works and think it should be changed, feel "
"free to discuss it on gdal-dev and see what can be done."
msgstr ""

#: ../../source/api/python_gotchas.rst:21
msgid "Gotchas that are by design... or per history"
msgstr ""

#: ../../source/api/python_gotchas.rst:23
msgid ""
"These are unexpected behaviors that are not considered by the GDAL and "
"OGR teams to be bugs and are unlikely to be changed due to effort "
"required, or whose fixing might affect backward compatibility, etc."
msgstr ""

#: ../../source/api/python_gotchas.rst:27
msgid ""
"Python bindings do not raise exceptions unless you explicitly call "
"``UseExceptions()``"
msgstr ""

#: ../../source/api/python_gotchas.rst:29
msgid ""
"By default, the GDAL and OGR Python bindings do not raise exceptions when"
" errors occur. Instead they return an error value such as ``None`` and "
"write an error message to ``sys.stdout``. For example, when you try to "
"open a non-existing dataset with GDAL:"
msgstr ""

#: ../../source/api/python_gotchas.rst:41
msgid ""
"In Python, it is traditional to report errors by raising exceptions. You "
"can enable this behavior in GDAL and OGR by calling the "
"``UseExceptions()`` function:"
msgstr ""

#: ../../source/api/python_gotchas.rst:58
msgid ""
"It is planned that exceptions will be enabled by default in GDAL 4.0. "
"Code that does not want exceptions to be raised in a future version of "
"GDAL should explicitly disable them with ``gdal.DontUseExceptions()``."
msgstr ""

#: ../../source/api/python_gotchas.rst:62
msgid ""
"Python crashes or throws an exception if you use an object after deleting"
" a related object"
msgstr ""

#: ../../source/api/python_gotchas.rst:64
msgid "Consider this example:"
msgstr ""

#: ../../source/api/python_gotchas.rst:74
msgid ""
"In this example, ``band`` has a relationship with ``dataset`` that "
"requires ``dataset`` to remain allocated in order for ``band`` to work. "
"If we delete ``dataset`` and then try to use ``band``, Python will throw "
"a confusing exception:"
msgstr ""

#: ../../source/api/python_gotchas.rst:88
msgid ""
"In GDAL 3.7 and earlier, using a band after the dataset has been "
"destroyed will cause a crash instead of an exception."
msgstr ""

#: ../../source/api/python_gotchas.rst:90
msgid ""
"This problem can manifest itself in subtle ways. For example, it can "
"occur if you try to instantiate a temporary dataset instance within a "
"single line of code:"
msgstr ""

#: ../../source/api/python_gotchas.rst:98
msgid ""
"In this example, the dataset instance was no longer needed after the call"
" to ``GetRasterBand()`` so Python deallocated it *before* calling "
"``Checksum()``."
msgstr ""

#: ../../source/api/python_gotchas.rst:112
msgid ""
"This example is the same case as above but it looks different. The "
"dataset object is only available in the ``load_band`` function and will "
"be deleted right after leaving the function."
msgstr ""

#: ../../source/api/python_gotchas.rst:116
msgid ""
"The problem is not restricted to GDAL band and dataset objects and "
"happens in other areas where objects have relationships with each other. "
"The issue occurs because deleting an object in Python causes not only the"
" C++ object behind it to be deallocated, but also other objects for which"
" that C++ object maintains ownership (e.g., a Dataset owning a Band, a "
"Feature owning a Geometry.) If the Python object associated with one of "
"these child objects retains a reference to that object, Python will crash"
" when the object is accessed. In common cases such as the Band/Dataset "
"relationship above, the GDAL bindings invalidate references to objects "
"that no longer exist so that an exception is thrown instead of a crash, "
"but the work is not complete."
msgstr ""

#: ../../source/api/python_gotchas.rst:127
msgid ""
"Unfortunately there is no complete list of such relationships, so you "
"have to watch for it yourself."
msgstr ""

#: ../../source/api/python_gotchas.rst:130
msgid ""
"Python crashes if you add a new field to an OGR layer when features "
"deriving from this layer definition are still active"
msgstr ""

#: ../../source/api/python_gotchas.rst:132
msgid "For example:"
msgstr ""

#: ../../source/api/python_gotchas.rst:142
msgid ""
"For more information, please see `#3552 "
"<https://trac.osgeo.org/gdal/ticket/3552>`__."
msgstr ""

#: ../../source/api/python_gotchas.rst:145
msgid ""
"Layers with attribute filters (``SetAttributeFilter()``) will only return"
" filtered features when using ``GetNextFeature()``"
msgstr ""

#: ../../source/api/python_gotchas.rst:147
msgid ""
"If you read the documentation for ``SetAttributeFilter()`` carefully you "
"will see the caveat about ``OGR_L_GetNextFeature()``. This means that if "
"you use ``GetFeature()``, instead of ``GetNextFeature()``, then you can "
"still access and work with features from the layer that are not covered "
"by the filter. ``GetFeatureCount()`` will respect the filter and show the"
" correct number of features filtered. However, working with "
"``GetFeatureCount()`` in a loop can lead to some subtle confusion. "
"Iterating over the Layer object or using ``GetNextFeature()`` should be "
"the default method for accessing features:"
msgstr ""

#: ../../source/api/python_gotchas.rst:162
msgid ""
"Certain objects contain a ``Destroy()`` method, but you should never use "
"it"
msgstr ""

#: ../../source/api/python_gotchas.rst:164
msgid ""
"You may come across examples that call the ``Destroy()`` method. `This "
"tutorial "
"<https://www.gis.usu.edu/~chrisg/python/2009/lectures/ospy_slides2.pdf>`__"
" even gives specific advice on page 12 about when to call ``Destroy``."
msgstr ""

#: ../../source/api/python_gotchas.rst:166
msgid ""
"Calling ``Destroy`` forces the underlying native object to be destroyed."
"  This is typically unnecessary because these objects are automatically "
"destroyed during garbage collection when no references to the Python "
"object remain."
msgstr ""

#: ../../source/api/python_gotchas.rst:170
msgid ""
"In most situations, it is not necessary to force the object to be "
"destroyed at a specific point in time. However, because the contents of "
"``gdal.Dataset`` and ``ogr.DataSource`` objects are only guaranteed to be"
" written to disk when the backing native object is destroyed, it may be "
"necessary to explicitly destroy these objects. In these cases, a context "
"manager (``with`` block) is often a good solution, e.g.:"
msgstr ""

#: ../../source/api/python_gotchas.rst:187
msgid ""
"If this is not possible, for example if the object needs to be destroyed "
"within a function, then the ``Close()`` method may be called."
msgstr ""

#: ../../source/api/python_gotchas.rst:192
msgid ""
"Context managers and the ``Close()`` method are available beginning in "
"GDAL 3.8. In earlier versions, ``Destroy()`` can be used for "
"``ogr.DataSource`` objects, or garbage collection may be forced by "
"destroying reference using ``del`` or setting variables to ``None``."
msgstr ""

#: ../../source/api/python_gotchas.rst:197
msgid ""
"With some drivers, raster datasets can be intermittently saved without "
"closing using ``FlushCache()``. Similarly, vector datasets can be saved "
"using ``SyncToDisk()``.  However, neither of these methods guarantee that"
" the data are written to disk, so the preferred method is to use a "
"context manager or call ``Close()``."
msgstr ""

#: ../../source/api/python_gotchas.rst:205
msgid "Exceptions raised in custom error handlers do not get caught"
msgstr ""

#: ../../source/api/python_gotchas.rst:207
msgid ""
"The python bindings allow you to specify a python callable as an error "
"handler (`#4993 <https://trac.osgeo.org/gdal/ticket/4993>`__). However, "
"these error handlers appear to be called in a separate thread and any "
"exceptions raised do not propagate back to the main thread (`#5186 "
"<https://trac.osgeo.org/gdal/ticket/5186>`__)."
msgstr ""

#: ../../source/api/python_gotchas.rst:210
msgid ""
"So if you want to  `catch warnings as well as errors "
"<https://gis.stackexchange.com/questions/43404/how-to-detect-a-gdal-ogr-"
"warning/68042>`__, something like this won't work:"
msgstr ""

#: ../../source/api/python_gotchas.rst:228
msgid "But you can do something like this instead:"
msgstr ""

#: ../../source/api/python_gotchas.rst:283
msgid "Gotchas that result from bugs or behaviors of other software"
msgstr ""

#: ../../source/api/python_gotchas.rst:286
msgid "Python crashes in GDAL functions when you upgrade or downgrade numpy"
msgstr ""

#: ../../source/api/python_gotchas.rst:288
msgid ""
"Much of GDAL's Python bindings are implemented in C++. Much of the core "
"of numpy is implemented in C. The C++ part of GDAL's Python bindings "
"interacts with the C part of numpy through numpy's ABI (application "
"binary interface). This requires GDAL's Python bindings to be compiled "
"using numpy header files that define numpy C data structures. Those data "
"structures sometimes change between numpy versions. When this happens, "
"the new version of numpy is not be compatible at the binary level with "
"the old version, and the GDAL Python bindings must be recompiled before "
"they will work with the new version of numpy. And when they are "
"recompiled, they probably won't work with the old version."
msgstr ""

#: ../../source/api/python_gotchas.rst:292
msgid ""
"If you obtained a precompiled version of GDAL's Python bindings, such as "
"the Windows packages from `http://gisinternals.com/sdk.php "
"<http://gisinternals.com/sdk.php>`__ be sure you look up what version of "
"numpy was used to compile them, and install that version of numpy on your"
" machine."
msgstr ""

#: ../../source/api/python_gotchas.rst:295
msgid ""
"Python bindings cannot be used successfully from ArcGIS in-process "
"geoprocessing tools (ArcGIS 9.3 and later)"
msgstr ""

#: ../../source/api/python_gotchas.rst:297
msgid ""
"ArcGIS allows the creation of custom, Python-based geoprocessing tools. "
"Until ArcGIS 10, there was no easy way to read raster data into memory. "
"GDAL provides such a mechanism."
msgstr ""

#: ../../source/api/python_gotchas.rst:299
msgid ""
"Starting with ArcGIS 9.3, geoprocessing tools can either run in the "
"ArcGIS process itself (ArcCatalog.exe or ArcMap.exe) or run in a separate"
" python.exe worker process. Unfortunately ArcGIS contains a bug in how it"
" runs in-process tools. Thus, if you use GDAL from an in-process tool, it"
" will run fine the first time but after that it may fail with "
"``TypeError`` exceptions until you restart the ArcGIS process. For "
"example, band.ReadAsArray() fails with:"
msgstr ""

#: ../../source/api/python_gotchas.rst:301
msgid ""
"``TypeError: in method 'BandRasterIONumpy', argument 1 of type "
"'GDALRasterBandShadow *``'"
msgstr ""

#: ../../source/api/python_gotchas.rst:303
msgid ""
"This is a bug in ArcGIS. Please see `#3672 "
"<https://trac.osgeo.org/gdal/ticket/3672>`__ for complete details and "
"advice on workarounds."
msgstr ""

#: ../../source/api/python_samples.rst:5
msgid "Python Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:7
msgid ""
"The following are sample scripts intended to give an idea how to use the "
"GDAL's Python interface. Please feel free to use them in your "
"applications."
msgstr ""

#: ../../source/api/python_samples.rst:10
msgid ""
"From GDAL 3.2, Python utility scripts :ref:`programs` are located inside "
"the `osgeo_utils` module. From GDAL 3.3, Python sample scripts are "
"located inside the `osgeo_utils.samples` sub-module."
msgstr ""

#: ../../source/api/python_samples.rst:14
msgid "Python Raster Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:18
msgid ""
"assemblepoly: Script demonstrates how to assemble polygons from arcs. "
"Demonstrates various aspects of OGR Python API."
msgstr ""

#: ../../source/api/python_samples.rst:19
msgid ""
"fft: Script to perform forward and inverse two-dimensional fast Fourier "
"transform."
msgstr ""

#: ../../source/api/python_samples.rst:20
msgid ""
"gdal2grd: Script to write out ASCII GRD rasters (used in Golden Software "
"Surfer). from any source supported by GDAL."
msgstr ""

#: ../../source/api/python_samples.rst:21
msgid "gdal_vrtmerge: Similar to gdal_merge, but produces a VRT file."
msgstr ""

#: ../../source/api/python_samples.rst:22
msgid ""
"gdalcopyproj: Duplicate the geotransform, projection and/or GCPs from one"
" raster dataset to another, which can be useful after performing image "
"manipulations with other software that ignores or discards georeferencing"
" metadata."
msgstr ""

#: ../../source/api/python_samples.rst:24
msgid ""
"gdalfilter:  Example script for applying kernel based filters to an image"
" using GDAL. Demonstrates use of virtual files as an intermediate "
"representation."
msgstr ""

#: ../../source/api/python_samples.rst:26
msgid ""
"get_soundg: Script to copy the SOUNDG layer from an S-57 file to a "
"Shapefile, splitting up features with MULTIPOINT geometries into many "
"POINT features, and appending the point elevations as an attribute."
msgstr ""

#: ../../source/api/python_samples.rst:29
msgid "histrep: Module to extract data from many rasters into one output."
msgstr ""

#: ../../source/api/python_samples.rst:30
msgid ""
"load2odbc: Load ODBC table to an ODBC datastore. Uses direct SQL since "
"the ODBC driver is read-only for OGR."
msgstr ""

#: ../../source/api/python_samples.rst:31
msgid ""
"rel: Script to produce a shaded relief image from the elevation data. "
"(similar functionality in gdaldem now)"
msgstr ""

#: ../../source/api/python_samples.rst:32
msgid ""
"tigerpoly:  Script demonstrating how to assemble polygons from arcs in "
"TIGER/Line datasource, writing results to a newly created shapefile."
msgstr ""

#: ../../source/api/python_samples.rst:34
msgid ""
"tolatlong: Script to read coordinate system and geotransformation matrix "
"from input file and report latitude/longitude coordinates for the "
"specified pixel."
msgstr ""

#: ../../source/api/python_samples.rst:36
msgid ""
"val_repl: Script to replace specified values from the input raster file "
"with the new ones. May be useful in cases when you don't like value, used"
" for NoData indication and want replace it with other value. Input file "
"remains unchanged, results stored in other file."
msgstr ""

#: ../../source/api/python_samples.rst:39
msgid ""
"vec_tr: Example of applying some algorithm to all the geometries in the "
"file, such as a fixed offset."
msgstr ""

#: ../../source/api/python_samples.rst:40
msgid ""
"vec_tr_spat: Example of using Intersect() to filter based on only those "
"features that truly intersect a given rectangle. Easily extended to "
"general polygon!"
msgstr ""

#: ../../source/api/python_samples.rst:42
msgid ""
"classify: Demonstrates using numpy for simple range based classification "
"of an image. This is only an example that has stuff hardcoded."
msgstr ""

#: ../../source/api/python_samples.rst:44
msgid ""
"gdal_lut: Read a LUT from a text file, and apply it to an image. Sort of "
"a '1 band' version of pct2rgb."
msgstr ""

#: ../../source/api/python_samples.rst:46
msgid ""
"magphase: Example script computing magnitude and phase images from a "
"complex image."
msgstr ""

#: ../../source/api/python_samples.rst:47
msgid "hsv_merge: Merge greyscale image into RGB image as intensity in HSV space."
msgstr ""

#: ../../source/api/python_samples.rst:48
msgid ""
"gdal_ls: Display the list of files in a virtual directory, like /vsicurl "
"or /vsizip"
msgstr ""

#: ../../source/api/python_samples.rst:49
msgid "gdal_cp: Copy a virtual file"
msgstr ""

#: ../../source/api/python_samples.rst:52
msgid "Python Vector Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:56
msgid ""
"ogrupdate: Update a target datasource with the features of a source "
"datasource. Contrary to ogr2ogr, this script tries to match features "
"between the datasources, to decide whether to create a new feature, or to"
" update an existing one."
msgstr ""

#: ../../source/api/python_samples.rst:59
msgid "ogr_layer_algebra: Application for executing OGR layer algebra operations."
msgstr ""

#: ../../source/api/python_samples.rst:60
msgid ""
"ogr_dispatch: Dispatch features into layers according to the value of "
"some fields or the geometry type."
msgstr ""

#: ../../source/api/python_samples.rst:61
msgid ""
"wcs_virtds_params: Generates MapServer WCS layer definition from a "
"tileindex with mixed SRS"
msgstr ""

#: ../../source/api/python_samples.rst:62
msgid ""
"ogr_build_junction_table: Create junction tables for layers coming from "
"GML datasources that reference other objects in _href fields"
msgstr ""

#: ../../source/api/python_samples.rst:64
msgid "gcps2ogr: Outputs GDAL GCPs as OGR points"
msgstr ""

#: ../../source/api/python_samples.rst:68
msgid "Python Coordinate Reference System Sample scripts"
msgstr ""

#: ../../source/api/python_samples.rst:72
msgid ""
"crs2crs2grid: A script to produce PROJ.4 grid shift files from HTDP "
"program."
msgstr ""

#: ../../source/api/python_samples.rst:75
msgid "Python direct ports of c++ programs"
msgstr ""

#: ../../source/api/python_samples.rst:79
msgid ":ref:`gdalinfo`: A direct port of apps/gdalinfo.c"
msgstr ""

#: ../../source/api/python_samples.rst:80
msgid ":ref:`ogrinfo`: A direct port of apps/ogrinfo.cpp"
msgstr ""

#: ../../source/api/python_samples.rst:81
msgid ":ref:`gdallocationinfo`: A direct port of apps/gdallocationinfo.cpp"
msgstr ""

#: ../../source/api/python_samples.rst:84
msgid "Python sample scripts that are now programs"
msgstr ""

#: ../../source/api/python_samples.rst:86
msgid ""
"Sample scripts might be upgraded to proper gdal utilities (programs) in "
"next versions with added functionality and documentation. The following "
"samples from previous versions are now programs."
msgstr ""

#: ../../source/api/python_samples.rst:92
msgid ":ref:`gdal2xyz`: Translates a raster file into xyz format."
msgstr ""

#: ../../source/api/python_samples.rst:93
msgid ""
":ref:`gdal_retile`: Script for restructuring data in a tree of regular "
"tiles."
msgstr ""

#: ../../source/api/python_samples.rst:94
msgid "val_at_coord: see :ref:`gdallocationinfo`"
msgstr ""

#: ../../source/api/raster_c_api.rst:10
msgid "gdal.h: Raster C API"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pszFuncName"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param papszFunctionArgs"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nInBands"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param eInDT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param padfInNoData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pnOutBands"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param peOutDT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param ppadfOutNoData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pszVRTPath"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param ppWorkingData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pWorkingData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nBufXSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nBufYSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pInBuffer"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nInBufferSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param pOutBuffer"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nOutBufferSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param eOutDT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param nOutBands"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param padfOutNoData"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcXOff"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcYOff"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcXSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param dfSrcYSize"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param adfSrcGT"
msgstr ""

#: ../../source/api/raster_c_api.rst
msgid "Param papszExtra"
msgstr ""

#: ../../source/api/vector_c_api.rst:10
msgid "ogr_core.h and ogr_api.h: Vector C API"
msgstr ""

#~ msgid ""
#~ "OGRLayerH OGR_DS_CopyLayer(OGRDataSourceH hDS, "
#~ "OGRLayerH hSrcLayer, const char *pszNewName,"
#~ " char **papszOptions)"
#~ msgstr ""

#~ msgid "Parameters:"
#~ msgstr ""

#~ msgid "hDS:  handle to the data source where to create the new layer"
#~ msgstr ""

#~ msgid "hSrcLayer:  handle to the source layer."
#~ msgstr ""

#~ msgid "pszNewName:  the name of the layer to create."
#~ msgstr ""

#~ msgid ""
#~ "papszOptions:  a StringList of name=value "
#~ "options. Options are driver specific."
#~ msgstr ""

#~ msgid ""
#~ "OGRLayerH OGR_DS_CreateLayer(OGRDataSourceH hDS, "
#~ "const char *pszName, OGRSpatialReferenceH "
#~ "hSpatialRef, OGRwkbGeometryType eType, char "
#~ "**papszOptions)"
#~ msgstr ""

#~ msgid "hDS:  The dataset handle."
#~ msgstr ""

#~ msgid ""
#~ "pszName:  the name for the new "
#~ "layer. This should ideally not match "
#~ "any existing layer on the datasource."
#~ msgstr ""

#~ msgid ""
#~ "hSpatialRef:  handle to the coordinate "
#~ "system to use for the new layer,"
#~ " or NULL if no coordinate system "
#~ "is available. The driver might only "
#~ "increase the reference counter of the"
#~ " object to take ownership, and not"
#~ " make a full copy, so do not"
#~ " use OSRDestroySpatialReference(), but "
#~ "OSRRelease() instead when you are done"
#~ " with the object."
#~ msgstr ""

#~ msgid ""
#~ "eType:  the geometry type for the "
#~ "layer. Use wkbUnknown if there are "
#~ "no constraints on the types geometry "
#~ "to be written."
#~ msgstr ""

#~ msgid ""
#~ "papszOptions:  a StringList of name=value "
#~ "options. Options are driver specific, "
#~ "and driver information can be found "
#~ "at the following "
#~ "url:http://www.gdal.org/ogr_formats.html"
#~ msgstr ""

#~ msgid ""
#~ "NULL is returned on failure, or a"
#~ " new OGRLayer handle on success. "
#~ "Example:"
#~ msgstr ""

#~ msgid ""
#~ "OGRLayerH OGR_DS_ExecuteSQL(OGRDataSourceH hDS, "
#~ "const char *pszStatement, OGRGeometryH "
#~ "hSpatialFilter, const char *pszDialect)"
#~ msgstr ""

#~ msgid "Starting with OGR 1.10, theSQLITE dialect can also be used."
#~ msgstr ""

#~ msgid "hDS:  handle to the data source on which the SQL query is executed."
#~ msgstr ""

#~ msgid "pszSQLCommand:  the SQL statement to execute."
#~ msgstr ""

#~ msgid ""
#~ "hSpatialFilter:  handle to a geometry "
#~ "which represents a spatial filter. Can"
#~ " be NULL."
#~ msgstr ""

#~ msgid ""
#~ "pszDialect:  allows control of the "
#~ "statement dialect. If set to NULL, "
#~ "the OGR SQL engine will be used,"
#~ " except for RDBMS drivers that will"
#~ " use their dedicated SQL engine, "
#~ "unless OGRSQL is explicitly passed as"
#~ " the dialect. Starting with OGR 1.10,"
#~ " the SQLITE dialect can also be "
#~ "used."
#~ msgstr ""

#~ msgid ""
#~ "NOTE: Starting with GDAL 2.0, it "
#~ "is NOT safe to cast the returned"
#~ " handle to OGRSFDriver*. If a C++ "
#~ "object is needed, the handle should "
#~ "be cast to GDALDriver*."
#~ msgstr ""

#~ msgid "hDS:  handle to the datasource"
#~ msgstr ""

#~ msgid ""
#~ "OGRLayerH OGR_DS_GetLayerByName(OGRDataSourceH hDS, "
#~ "const char *pszName)"
#~ msgstr ""

#~ msgid "hDS:  handle to the data source from which to get the layer."
#~ msgstr ""

#~ msgid "pszLayerName:  Layer the layer name of the layer to fetch."
#~ msgstr ""

#~ msgid "hDS:  handle to the data source from which to get the number of layers."
#~ msgstr ""

#~ msgid "const char* OGR_DS_GetName(OGRDataSourceH hDS)"
#~ msgstr ""

#~ msgid "hDS:  handle to the data source to get the name from."
#~ msgstr ""

#~ msgid "hDS:  a handle to the data source on which was executed an SQL query."
#~ msgstr ""

#~ msgid "hLayer:  handle to the result of a previous OGR_DS_ExecuteSQL() call."
#~ msgstr ""

#~ msgid "int OGR_DS_TestCapability(OGRDataSourceH hDS, const char *pszCap)"
#~ msgstr ""

#~ msgid "hDS:  handle to the data source against which to test the capability."
#~ msgstr ""

#~ msgid "pszCapability:  the capability to test."
#~ msgstr ""

#~ msgid "Build a VRT from a list of datasets. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "destName --- Output dataset name "
#~ "srcDSOrSrcDSTab --- an array of Dataset"
#~ " objects or filenames, or a Dataset"
#~ " object or a filename"
#~ msgstr ""

#~ msgid "Keyword arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.BuildVRTOptions(),"
#~ " string or array of strings other "
#~ "keywords arguments of gdal.BuildVRTOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.BuildVRTOptions() object, other keywords "
#~ "are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a BuildVRTOptions() object that "
#~ "can be passed to gdal.BuildVRT() Keyword"
#~ " arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords.. "
#~ "resolution --- 'highest', 'lowest', 'average',"
#~ " 'user'. outputBounds --- output bounds "
#~ "as (minX, minY, maxX, maxY) in "
#~ "target SRS. xRes, yRes --- output "
#~ "resolution in target SRS. targetAlignedPixels"
#~ " --- whether to force output bounds"
#~ " to be multiple of output resolution."
#~ " separate --- whether each source "
#~ "file goes into a separate stacked "
#~ "band in the VRT band. bandList ---"
#~ " array of band numbers (index start"
#~ " at 1). addAlpha --- whether to "
#~ "add an alpha mask band to the "
#~ "VRT when the source raster have "
#~ "none. resampleAlg --- resampling mode. "
#~ "outputSRS --- assigned output SRS. "
#~ "allowProjectionDifference --- whether to "
#~ "accept input datasets have not the "
#~ "same projection. Note: they will *not*"
#~ " be reprojected. srcNodata --- source "
#~ "nodata value(s). VRTNodata --- nodata "
#~ "values at the VRT band level. "
#~ "hideNodata --- whether to make the "
#~ "VRT band not report the NoData "
#~ "value. callback --- callback method. "
#~ "callback_data --- user data for "
#~ "callback."
#~ msgstr ""

#~ msgid "Apply a DEM processing. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "destName --- Output dataset name srcDS"
#~ " --- a Dataset object or a "
#~ "filename processing --- one of "
#~ "\"hillshade\", \"slope\", \"aspect\", \"color-"
#~ "relief\", \"TRI\", \"TPI\", \"Roughness\""
#~ msgstr ""

#~ msgid ""
#~ "options --- return of "
#~ "gdal.DEMProcessingOptions(), string or array "
#~ "of strings other keywords arguments of"
#~ " gdal.DEMProcessingOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.DEMProcessingOptions() object, other keywords"
#~ " are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a DEMProcessingOptions() object that"
#~ " can be passed to gdal.DEMProcessing() "
#~ "Keyword arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "colorFilename --- (mandatory for \"color-"
#~ "relief\") name of file that contains "
#~ "palette definition for the \"color-"
#~ "relief\" processing. format --- output "
#~ "format (\"GTiff\", etc...) creationOptions ---"
#~ " list of creation options computeEdges "
#~ "--- whether to compute values at "
#~ "raster edges. alg --- 'Horn' (default)"
#~ " or 'ZevenbergenThorne' for hillshade, "
#~ "slope or aspect. 'Wilson' (default) or"
#~ " 'Riley' for TRI band --- source "
#~ "band number to use zFactor --- "
#~ "(hillshade only) vertical exaggeration used"
#~ " to pre-multiply the elevations. "
#~ "scale --- ratio of vertical units "
#~ "to horizontal. azimuth --- (hillshade "
#~ "only) azimuth of the light, in "
#~ "degrees. 0 if it comes from the"
#~ " top of the raster, 90 from the"
#~ " east, ... The default value, 315,"
#~ " should rarely be changed as it "
#~ "is the value generally used to "
#~ "generate shaded maps. altitude ---(hillshade"
#~ " only) altitude of the light, in "
#~ "degrees. 90 if the light comes "
#~ "from above the DEM, 0 if it "
#~ "is raking light. combined --- (hillshade"
#~ " only) whether to compute combined "
#~ "shading, a combination of slope and "
#~ "oblique shading. Only one of combined,"
#~ " multiDirectional and igor can be "
#~ "specified. multiDirectional --- (hillshade "
#~ "only) whether to compute multi-"
#~ "directional shading. Only one of "
#~ "combined, multiDirectional and igor can "
#~ "be specified. igor --- (hillshade only)"
#~ " whether to use Igor's hillshading "
#~ "from Maperitive.  Only one of combined,"
#~ " multiDirectional and igor can be "
#~ "specified. slopeformat --- (slope only) "
#~ "\"degree\" or \"percent\". trigonometric ---"
#~ " (aspect only) whether to return "
#~ "trigonometric angle instead of azimuth. "
#~ "Thus 0deg means East, 90deg North, "
#~ "180deg West, 270deg South. zeroForFlat "
#~ "--- (aspect only) whether to return "
#~ "0 for flat areas with slope=0, "
#~ "instead of -9999. addAlpha --- adds "
#~ "an alpha band to the output file"
#~ " (only for processing = 'color-"
#~ "relief') colorSelection --- (color-relief "
#~ "only) Determines how color entries are"
#~ " selected from an input value. Can"
#~ " be \"nearest_color_entry\", \"exact_color_entry\" "
#~ "or \"linear_interpolation\". Defaults to "
#~ "\"linear_interpolation\" callback --- callback "
#~ "method callback_data --- user data for"
#~ " callback"
#~ msgstr ""

#~ msgid "Create raster from the scattered data. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "destName --- Output dataset name srcDS"
#~ " --- a Dataset object or a "
#~ "filename"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.GridOptions(), "
#~ "string or array of strings other "
#~ "keywords arguments of gdal.GridOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.GridOptions() object, other keywords are"
#~ " ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a GridOptions() object that can"
#~ " be passed to gdal.Grid() Keyword "
#~ "arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"GTiff\", "
#~ "etc...) outputType --- output type "
#~ "(gdalconst.GDT_Byte, etc...) width --- width"
#~ " of the output raster in pixel "
#~ "height --- height of the output "
#~ "raster in pixel creationOptions --- list"
#~ " of creation options outputBounds --- "
#~ "assigned output bounds: [ulx, uly, lrx,"
#~ " lry] outputSRS --- assigned output "
#~ "SRS noData --- nodata value algorithm"
#~ " --- e.g "
#~ "\"invdist:power=2.0:smoothing=0.0:radius1=0.0:radius2=0.0:angle=0.0:max_points=0:min_points=0:nodata=0.0\""
#~ " layers --- list of layers to "
#~ "convert SQLStatement --- SQL statement "
#~ "to apply to the source dataset "
#~ "where --- WHERE clause to apply to"
#~ " source layer(s) spatFilter --- spatial "
#~ "filter as (minX, minY, maxX, maxY) "
#~ "bounding box zfield --- Identifies an"
#~ " attribute field on the features to"
#~ " be used to get a Z value "
#~ "from. This value overrides Z value "
#~ "read from feature geometry record. "
#~ "z_increase --- Addition to the attribute"
#~ " field on the features to be "
#~ "used to get a Z value from. "
#~ "The addition should be the same "
#~ "unit as Z value. The result value"
#~ " will be Z value + Z increase"
#~ " value. The default value is 0. "
#~ "z_multiply - Multiplication ratio for Z"
#~ " field. This can be used for "
#~ "shift from e.g. foot to meters or"
#~ " from  elevation to deep. The result"
#~ " value will be (Z value + Z "
#~ "increase value) * Z multiply value.  "
#~ "The default value is 1. callback "
#~ "--- callback method callback_data --- "
#~ "user data for callback"
#~ msgstr ""

#~ msgid "Return information on a dataset. Arguments are :"
#~ msgstr ""

#~ msgid "ds --- a Dataset object or a filename"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.InfoOptions(), "
#~ "string or array of strings other "
#~ "keywords arguments of gdal.InfoOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.InfoOptions() object, other keywords are"
#~ " ignored."
#~ msgstr ""

#~ msgid "Convert nearly black/white borders to exact value. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "destNameOrDestDS --- Output dataset name "
#~ "or object srcDS --- a Dataset "
#~ "object or a filename"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.NearblackOptions(),"
#~ " string or array of strings other "
#~ "keywords arguments of gdal.NearblackOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.NearblackOptions() object, other keywords "
#~ "are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a NearblackOptions() object that "
#~ "can be passed to gdal.Nearblack() "
#~ "Keyword arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"GTiff\", "
#~ "etc...) creationOptions --- list of "
#~ "creation options white --- whether to"
#~ " search for nearly white (255) pixels"
#~ " instead of nearly black pixels. "
#~ "colors --- list of colors  to "
#~ "search for, e.g. ((0,0,0),(255,255,255)). The"
#~ " pixels that are considered as the"
#~ " collar are set to 0 maxNonBlack "
#~ "--- number of non-black (or other"
#~ " searched colors specified with white "
#~ "/ colors) pixels that can be "
#~ "encountered before the giving up search"
#~ " inwards. Defaults to 2. nearDist ---"
#~ " select how far from black, white "
#~ "or custom colors the pixel values "
#~ "can be and still considered near "
#~ "black, white or custom color.  Defaults"
#~ " to 15. setAlpha --- adds an "
#~ "alpha band to the output file. "
#~ "setMask --- adds a mask band to"
#~ " the output file. callback --- "
#~ "callback method callback_data --- user "
#~ "data for callback"
#~ msgstr ""

#~ msgid "Burns vector geometries into a raster Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.RasterizeOptions(),"
#~ " string or array of strings other "
#~ "keywords arguments of gdal.RasterizeOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.RasterizeOptions() object, other keywords "
#~ "are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a RasterizeOptions() object that "
#~ "can be passed to gdal.Rasterize() "
#~ "Keyword arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"GTiff\", "
#~ "etc...) outputType --- output type "
#~ "(gdalconst.GDT_Byte, etc...) creationOptions --- "
#~ "list of creation options outputBounds "
#~ "--- assigned output bounds: [minx, miny,"
#~ " maxx, maxy] outputSRS --- assigned "
#~ "output SRS transformerOptions --- list "
#~ "of transformer options width --- width"
#~ " of the output raster in pixel "
#~ "height --- height of the output "
#~ "raster in pixel xRes, yRes --- "
#~ "output resolution in target SRS "
#~ "targetAlignedPixels --- whether to force "
#~ "output bounds to be multiple of "
#~ "output resolution noData --- nodata "
#~ "value initValues --- Value or list "
#~ "of values to pre-initialize the "
#~ "output image bands with.  However, it"
#~ " is not marked as the nodata "
#~ "value in the output file.  If only"
#~ " one value is given, the same "
#~ "value is used in all the bands."
#~ " bands --- list of output bands "
#~ "to burn values into inverse --- "
#~ "whether to invert rasterization, i.e. "
#~ "burn the fixed burn value, or the"
#~ " burn value associated  with the "
#~ "first feature into all parts of "
#~ "the image not inside the provided "
#~ "a polygon. allTouched -- whether to "
#~ "enable the ALL_TOUCHED rasterization option"
#~ " so that all pixels touched by "
#~ "lines or polygons will be updated, "
#~ "not just those on the line render"
#~ " path, or whose center point is "
#~ "within the polygon. burnValues -- list"
#~ " of fixed values to burn into "
#~ "each band for all objects. Excusive "
#~ "with attribute. attribute --- identifies "
#~ "an attribute field on the features "
#~ "to be used for a burn-in "
#~ "value. The value will be burned "
#~ "into all output bands. Excusive with "
#~ "burnValues. useZ --- whether to indicate"
#~ " that a burn value should be "
#~ "extracted from the \"Z\" values of "
#~ "the feature. These values are added "
#~ "to the burn value given by "
#~ "burnValues or attribute if provided. As"
#~ " of now, only points and lines "
#~ "are drawn in 3D. layers --- list"
#~ " of layers from the datasource that"
#~ " will be used for input features. "
#~ "SQLStatement --- SQL statement to apply"
#~ " to the source dataset SQLDialect ---"
#~ " SQL dialect ('OGRSQL', 'SQLITE', ...) "
#~ "where --- WHERE clause to apply to"
#~ " source layer(s) optim --- optimization "
#~ "mode ('RASTER', 'VECTOR') add --- set"
#~ " to True to use additive mode "
#~ "instead of replace when burning values"
#~ " callback --- callback method callback_data"
#~ " --- user data for callback"
#~ msgstr ""

#~ msgid "Convert a dataset. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.TranslateOptions(),"
#~ " string or array of strings other "
#~ "keywords arguments of gdal.TranslateOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.TranslateOptions() object, other keywords "
#~ "are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a TranslateOptions() object that "
#~ "can be passed to gdal.Translate() "
#~ "Keyword arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"GTiff\", "
#~ "etc...) outputType --- output type "
#~ "(gdalconst.GDT_Byte, etc...) bandList --- "
#~ "array of band numbers (index start "
#~ "at 1) maskBand --- mask band to"
#~ " generate or not (\"none\", \"auto\", "
#~ "\"mask\", 1, ...) width --- width "
#~ "of the output raster in pixel "
#~ "height --- height of the output "
#~ "raster in pixel widthPct --- width "
#~ "of the output raster in percentage "
#~ "(100 = original width) heightPct --- "
#~ "height of the output raster in "
#~ "percentage (100 = original height) xRes"
#~ " --- output horizontal resolution yRes "
#~ "--- output vertical resolution creationOptions"
#~ " --- list of creation options srcWin"
#~ " --- subwindow in pixels to extract:"
#~ " [left_x, top_y, width, height] projWin "
#~ "--- subwindow in projected coordinates "
#~ "to extract: [ulx, uly, lrx, lry] "
#~ "projWinSRS --- SRS in which projWin "
#~ "is expressed strict --- strict mode "
#~ "unscale --- unscale values with scale"
#~ " and offset metadata scaleParams --- "
#~ "list of scale parameters, each of "
#~ "the form [src_min,src_max] or "
#~ "[src_min,src_max,dst_min,dst_max] exponents --- list"
#~ " of exponentiation parameters outputBounds "
#~ "--- assigned output bounds: [ulx, uly,"
#~ " lrx, lry] metadataOptions --- list "
#~ "of metadata options outputSRS --- "
#~ "assigned output SRS nogcp --- ignore "
#~ "GCP in the raster GCPs --- list"
#~ " of GCPs noData --- nodata value "
#~ "(or \"none\" to unset it) rgbExpand "
#~ "--- Color palette expansion mode: "
#~ "\"gray\", \"rgb\", \"rgba\" stats --- "
#~ "whether to calculate statistics rat ---"
#~ " whether to write source RAT "
#~ "resampleAlg --- resampling mode callback "
#~ "--- callback method callback_data --- "
#~ "user data for callback"
#~ msgstr ""

#~ msgid "Warp one or several datasets. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "destNameOrDestDS --- Output dataset name "
#~ "or object srcDSOrSrcDSTab --- an array"
#~ " of Dataset objects or filenames, or"
#~ " a Dataset object or a filename"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of gdal.WarpOptions(), "
#~ "string or array of strings other "
#~ "keywords arguments of gdal.WarpOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.WarpOptions() object, other keywords are"
#~ " ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a WarpOptions() object that can"
#~ " be passed to gdal.Warp() Keyword "
#~ "arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"GTiff\", "
#~ "etc...) outputBounds --- output bounds "
#~ "as (minX, minY, maxX, maxY) in "
#~ "target SRS outputBoundsSRS --- SRS in"
#~ " which output bounds are expressed, "
#~ "in the case they are not expressed"
#~ " in dstSRS xRes, yRes --- output "
#~ "resolution in target SRS targetAlignedPixels"
#~ " --- whether to force output bounds"
#~ " to be multiple of output resolution"
#~ " width --- width of the output "
#~ "raster in pixel height --- height "
#~ "of the output raster in pixel "
#~ "srcSRS --- source SRS dstSRS --- "
#~ "output SRS coordinateOperation -- coordinate"
#~ " operation as a PROJ string or "
#~ "WKT string srcAlpha --- whether to "
#~ "force the last band of the input"
#~ " dataset to be considered as an "
#~ "alpha band dstAlpha --- whether to "
#~ "force the creation of an output "
#~ "alpha band outputType --- output type"
#~ " (gdalconst.GDT_Byte, etc...) workingType --- "
#~ "working type (gdalconst.GDT_Byte, etc...) "
#~ "warpOptions --- list of warping options"
#~ " errorThreshold --- error threshold for "
#~ "approximation transformer (in pixels) "
#~ "warpMemoryLimit --- size of working "
#~ "buffer in MB resampleAlg --- resampling"
#~ " mode creationOptions --- list of "
#~ "creation options srcNodata --- source "
#~ "nodata value(s) dstNodata --- output "
#~ "nodata value(s) multithread --- whether "
#~ "to multithread computation and I/O "
#~ "operations tps --- whether to use "
#~ "Thin Plate Spline GCP transformer rpc"
#~ " --- whether to use RPC transformer"
#~ " geoloc --- whether to use "
#~ "GeoLocation array transformer polynomialOrder "
#~ "--- order of polynomial GCP "
#~ "interpolation transformerOptions --- list of"
#~ " transformer options cutlineDSName --- "
#~ "cutline dataset name cutlineLayer --- "
#~ "cutline layer name cutlineWhere --- "
#~ "cutline WHERE clause cutlineSQL --- "
#~ "cutline SQL statement cutlineBlend --- "
#~ "cutline blend distance in pixels "
#~ "cropToCutline --- whether to use cutline"
#~ " extent for output bounds copyMetadata "
#~ "--- whether to copy source metadata "
#~ "metadataConflictValue --- metadata data "
#~ "conflict value setColorInterpretation --- "
#~ "whether to force color interpretation of"
#~ " input bands to output bands "
#~ "overviewLevel --- To specify which "
#~ "overview level of source files must "
#~ "be used callback --- callback method "
#~ "callback_data --- user data for callback"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of "
#~ "gdal.MultiDimInfoOptions(), string or array of"
#~ " strings other keywords arguments of "
#~ "gdal.MultiDimInfoOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.MultiDimInfoOptions() object, other keywords"
#~ " are ignored."
#~ msgstr ""

#~ msgid "MultiDimTranslate one or several datasets. Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of "
#~ "gdal.MultiDimTranslateOptions(), string or array "
#~ "of strings other keywords arguments of"
#~ " gdal.MultiDimTranslateOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.MultiDimTranslateOptions() object, other "
#~ "keywords are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a MultiDimTranslateOptions() object "
#~ "that can be passed to "
#~ "gdal.MultiDimTranslate() Keyword arguments are "
#~ ":"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"GTiff\", "
#~ "etc...) creationOptions --- list of "
#~ "creation options arraySpecs -- list of"
#~ " array specifications, each of them "
#~ "being an array name or "
#~ "\"name={src_array_name},dstname={dst_name},transpose=[1,0],view=[:,::-1]\""
#~ " groupSpecs -- list of group "
#~ "specifications, each of them being a "
#~ "group name or "
#~ "\"name={src_array_name},dstname={dst_name},recursive=no\" "
#~ "subsetSpecs -- list of subset "
#~ "specifications, each of them being like"
#~ " \"{dim_name}({min_val},{max_val})\" or "
#~ "\"{dim_name}({slice_va})\" scaleAxesSpecs -- list"
#~ " of dimension scaling specifications, each"
#~ " of them being like "
#~ "\"{dim_name}({scale_factor})\" callback --- callback"
#~ " method callback_data --- user data "
#~ "for callback"
#~ msgstr ""

#~ msgid "Convert one vector dataset Arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- return of "
#~ "gdal.VectorTranslateOptions(), string or array "
#~ "of strings other keywords arguments of"
#~ " gdal.VectorTranslateOptions()"
#~ msgstr ""

#~ msgid ""
#~ "If options is provided as a "
#~ "gdal.VectorTranslateOptions() object, other keywords"
#~ " are ignored."
#~ msgstr ""

#~ msgid ""
#~ "Create a VectorTranslateOptions() object that"
#~ " can be passed to gdal.VectorTranslate()"
#~ " Keyword arguments are :"
#~ msgstr ""

#~ msgid ""
#~ "options --- can be be an array "
#~ "of strings, a string or let empty"
#~ " and filled from other keywords. "
#~ "format --- output format (\"ESRI "
#~ "Shapefile\", etc...) accessMode --- None "
#~ "for creation, 'update', 'append', 'overwrite'"
#~ " srcSRS --- source SRS dstSRS --- "
#~ "output SRS (with reprojection if "
#~ "reproject = True) coordinateOperation -- "
#~ "coordinate operation as a PROJ string"
#~ " or WKT string reproject --- whether"
#~ " to do reprojection SQLStatement --- "
#~ "SQL statement to apply to the "
#~ "source dataset SQLDialect --- SQL "
#~ "dialect ('OGRSQL', 'SQLITE', ...) where "
#~ "--- WHERE clause to apply to "
#~ "source layer(s) selectFields --- list of"
#~ " fields to select addFields --- "
#~ "whether to add new fields found in"
#~ " source layers (to be used with "
#~ "accessMode == 'append') forceNullable --- "
#~ "whether to drop NOT NULL constraints "
#~ "on newly created fields emptyStrAsNull "
#~ "--- whether to treat empty string "
#~ "values as NULL spatFilter --- spatial"
#~ " filter as (minX, minY, maxX, maxY)"
#~ " bounding box spatSRS --- SRS in "
#~ "which the spatFilter is expressed. If"
#~ " not specified, it is assumed to "
#~ "be the one of the layer(s) "
#~ "datasetCreationOptions --- list of dataset "
#~ "creation options layerCreationOptions --- list"
#~ " of layer creation options layers ---"
#~ " list of layers to convert layerName"
#~ " --- output layer name geometryType "
#~ "--- output layer geometry type ('POINT',"
#~ " ....) dim --- output dimension "
#~ "('XY', 'XYZ', 'XYM', 'XYZM', 'layer_dim') "
#~ "segmentizeMaxDist --- maximum distance between"
#~ " consecutive nodes of a line geometry"
#~ " makeValid --- run MakeValid() on "
#~ "geometries zField --- name of field "
#~ "to use to set the Z component "
#~ "of geometries resolveDomains --- whether "
#~ "to create an additional field for "
#~ "each field associated with a coded "
#~ "field domain. skipFailures --- whether "
#~ "to skip failures limit -- maximum "
#~ "number of features to read per "
#~ "layer callback --- callback method "
#~ "callback_data --- user data for callback"
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_AlterFieldDefn(OGRLayerH hLayer, int"
#~ " iField, OGRFieldDefnH hNewFieldDefn, int "
#~ "nFlags)"
#~ msgstr ""

#~ msgid ""
#~ "You must use this to alter the "
#~ "definition of an existing field of "
#~ "a real layer. Internally the "
#~ "OGRFeatureDefn for the layer will be "
#~ "updated to reflect the altered field."
#~ " Applications should never modify the "
#~ "OGRFeatureDefn used by a layer directly."
#~ msgstr ""

#~ msgid ""
#~ "This function should not be called "
#~ "while there are feature objects in "
#~ "existence that were obtained or created"
#~ " with the previous layer definition."
#~ msgstr ""

#~ msgid ""
#~ "Not all drivers support this function."
#~ " You can query a layer to check"
#~ " if it supports it with the "
#~ "OLCAlterFieldDefn capability. Some drivers may"
#~ " only support this method while there"
#~ " are still no features in the "
#~ "layer. When it is supported, the "
#~ "existing features of the backing "
#~ "file/database should be updated accordingly."
#~ " Some drivers might also not support"
#~ " all update flags."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::AlterFieldDefn()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer."
#~ msgstr ""

#~ msgid "iField:  index of the field whose definition must be altered."
#~ msgstr ""

#~ msgid "hNewFieldDefn:  new field definition"
#~ msgstr ""

#~ msgid ""
#~ "nFlags:  combination of ALTER_NAME_FLAG, "
#~ "ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, "
#~ "ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to "
#~ "indicate which of the name and/or "
#~ "type and/or width and precision fields"
#~ " and/or nullability from the new "
#~ "field definition must be taken into "
#~ "account."
#~ msgstr ""

#~ msgid "OGRERR_NONE on success."
#~ msgstr ""

#~ msgid "OGR 1.9.0"
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_Clip(OGRLayerH pLayerInput, OGRLayerH"
#~ " pLayerMethod, OGRLayerH pLayerResult, char "
#~ "**papszOptions, GDALProgressFunc pfnProgress, void"
#~ " *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "in the input layer and in the "
#~ "method layer. The features in the "
#~ "result layer have the (possibly clipped)"
#~ " areas of features in the input "
#~ "layer and the attributes from the "
#~ "same features. The schema of the "
#~ "result layer can be set by the "
#~ "user or, if it is empty, is "
#~ "initialized to contain all fields in "
#~ "the input layer."
#~ msgstr ""

#~ msgid ""
#~ "For best performance use the minimum "
#~ "amount of features in the method "
#~ "layer and copy it into a memory"
#~ " layer."
#~ msgstr ""

#~ msgid ""
#~ "This method relies on GEOS support. "
#~ "Do not use unless the GEOS support"
#~ " is compiled in.  The recognized list"
#~ " of options is : SKIP_FAILURES=YES/NO. "
#~ "Set it to YES to go on, even"
#~ " when a feature could not be "
#~ "inserted or a GEOS call failed."
#~ msgstr ""

#~ msgid ""
#~ "PROMOTE_TO_MULTI=YES/NO. Set it to YES "
#~ "to convert Polygons into MultiPolygons, "
#~ "or LineStrings to MultiLineStrings."
#~ msgstr ""

#~ msgid ""
#~ "INPUT_PREFIX=string. Set a prefix for "
#~ "the field names that will be "
#~ "created from the fields of the "
#~ "input layer."
#~ msgstr ""

#~ msgid ""
#~ "METHOD_PREFIX=string. Set a prefix for "
#~ "the field names that will be "
#~ "created from the fields of the "
#~ "method layer."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::Clip()."
#~ msgstr ""

#~ msgid "pLayerInput:  the input layer. Should not be NULL."
#~ msgstr ""

#~ msgid "pLayerMethod:  the method layer. Should not be NULL."
#~ msgstr ""

#~ msgid ""
#~ "pLayerResult:  the layer where the "
#~ "features resulting from the operation "
#~ "are inserted. Should not be NULL. "
#~ "See above the note about the "
#~ "schema."
#~ msgstr ""

#~ msgid "papszOptions:  NULL terminated list of options (may be NULL)."
#~ msgstr ""

#~ msgid ""
#~ "pfnProgress:  a GDALProgressFunc() compatible "
#~ "callback function for reporting progress "
#~ "or NULL."
#~ msgstr ""

#~ msgid "pProgressArg:  argument to be passed to pfnProgress. May be NULL."
#~ msgstr ""

#~ msgid ""
#~ "an error code if there was an "
#~ "error or the execution was interrupted,"
#~ " OGRERR_NONE otherwise."
#~ msgstr ""

#~ msgid "OGR 1.10"
#~ msgstr ""

#~ msgid "OGRErr OGR_L_CommitTransaction(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "For datasources which support transactions,"
#~ " CommitTransaction commits a transaction."
#~ msgstr ""

#~ msgid ""
#~ "If no transaction is active, or "
#~ "the commit fails, will return "
#~ "OGRERR_FAILURE. Datasources which do not "
#~ "support transactions will always return "
#~ "OGRERR_NONE."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRLayer::CommitTransaction()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer"
#~ msgstr ""

#~ msgid "OGRErr OGR_L_CreateFeature(OGRLayerH hLayer, OGRFeatureH hFeat)"
#~ msgstr ""

#~ msgid ""
#~ "The passed feature is written to "
#~ "the layer as a new feature, rather"
#~ " than overwriting an existing one. If"
#~ " the feature has a feature id "
#~ "other than OGRNullFID, then the native"
#~ " implementation may use that as the"
#~ " feature id of the new feature, "
#~ "but not necessarily. Upon successful "
#~ "return the passed feature will have "
#~ "been updated with the new feature "
#~ "id."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::CreateFeature()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to write the feature to."
#~ msgstr ""

#~ msgid "hFeat:  the handle of the feature to write to disk."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_CreateField(OGRLayerH hLayer, "
#~ "OGRFieldDefnH hField, int bApproxOK)"
#~ msgstr ""

#~ msgid ""
#~ "You must use this to create new"
#~ " fields on a real layer. Internally"
#~ " the OGRFeatureDefn for the layer "
#~ "will be updated to reflect the new"
#~ " field. Applications should never modify"
#~ " the OGRFeatureDefn used by a layer"
#~ " directly."
#~ msgstr ""

#~ msgid ""
#~ "Not all drivers support this function."
#~ " You can query a layer to check"
#~ " if it supports it with the "
#~ "OLCCreateField capability. Some drivers may"
#~ " only support this method while there"
#~ " are still no features in the "
#~ "layer. When it is supported, the "
#~ "existing features of the backing "
#~ "file/database should be updated accordingly."
#~ msgstr ""

#~ msgid ""
#~ "Drivers may or may not support "
#~ "not-null constraints. If they support "
#~ "creating fields with not-null "
#~ "constraints, this is generally before "
#~ "creating any feature to the layer."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::CreateField()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to write the field definition."
#~ msgstr ""

#~ msgid "hField:  handle of the field definition to write to disk."
#~ msgstr ""

#~ msgid ""
#~ "bApproxOK:  If TRUE, the field may "
#~ "be created in a slightly different "
#~ "form depending on the limitations of "
#~ "the format driver."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_CreateGeomField(OGRLayerH hLayer, "
#~ "OGRGeomFieldDefnH hField, int bApproxOK)"
#~ msgstr ""

#~ msgid ""
#~ "You must use this to create new"
#~ " geometry fields on a real layer. "
#~ "Internally the OGRFeatureDefn for the "
#~ "layer will be updated to reflect "
#~ "the new field. Applications should never"
#~ " modify the OGRFeatureDefn used by a"
#~ " layer directly."
#~ msgstr ""

#~ msgid "hField:  handle of the geometry field definition to write to disk."
#~ msgstr ""

#~ msgid "OGR 1.11"
#~ msgstr ""

#~ msgid "OGRErr OGR_L_DeleteFeature(OGRLayerH hLayer, GIntBig nFID)"
#~ msgstr ""

#~ msgid ""
#~ "The feature with the indicated feature"
#~ " id is deleted from the layer "
#~ "if supported by the driver. Most "
#~ "drivers do not support feature deletion,"
#~ " and will return OGRERR_UNSUPPORTED_OPERATION."
#~ " The OGR_L_TestCapability() function may be"
#~ " called with OLCDeleteFeature to check "
#~ "if the driver supports feature deletion."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::DeleteFeature()."
#~ msgstr ""

#~ msgid "nFID:  the feature id to be deleted from the layer"
#~ msgstr ""

#~ msgid ""
#~ "OGRERR_NONE if the operation works, "
#~ "otherwise an appropriate error code (e.g"
#~ " OGRERR_NON_EXISTING_FEATURE if the feature "
#~ "does not exist)."
#~ msgstr ""

#~ msgid "OGRErr OGR_L_DeleteField(OGRLayerH hLayer, int iField)"
#~ msgstr ""

#~ msgid ""
#~ "You must use this to delete "
#~ "existing fields on a real layer. "
#~ "Internally the OGRFeatureDefn for the "
#~ "layer will be updated to reflect "
#~ "the deleted field. Applications should "
#~ "never modify the OGRFeatureDefn used by"
#~ " a layer directly."
#~ msgstr ""

#~ msgid ""
#~ "Not all drivers support this function."
#~ " You can query a layer to check"
#~ " if it supports it with the "
#~ "OLCDeleteField capability. Some drivers may"
#~ " only support this method while there"
#~ " are still no features in the "
#~ "layer. When it is supported, the "
#~ "existing features of the backing "
#~ "file/database should be updated accordingly."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::DeleteField()."
#~ msgstr ""

#~ msgid "iField:  index of the field to delete."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_Erase(OGRLayerH pLayerInput, OGRLayerH"
#~ " pLayerMethod, OGRLayerH pLayerResult, char "
#~ "**papszOptions, GDALProgressFunc pfnProgress, void"
#~ " *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "in the input layer but not in "
#~ "the method layer. The features in "
#~ "the result layer have attributes from"
#~ " the input layer. The schema of "
#~ "the result layer can be set by "
#~ "the user or, if it is empty, "
#~ "is initialized to contain all fields "
#~ "in the input layer."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::Erase()."
#~ msgstr ""

#~ msgid ""
#~ "int OGR_L_FindFieldIndex(OGRLayerH hLayer, const "
#~ "char *pszFieldName, int bExactMatch)"
#~ msgstr ""

#~ msgid ""
#~ "The returned number is the index "
#~ "of the field in the layers, or "
#~ "-1 if the field doesn't exist."
#~ msgstr ""

#~ msgid ""
#~ "If bExactMatch is set to FALSE and"
#~ " the field doesn't exists in the "
#~ "given form the driver might apply "
#~ "some changes to make it match, "
#~ "like those it might do if the "
#~ "layer was created (eg. like LAUNDER "
#~ "in the OCI driver)."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::FindFieldIndex()."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_GetExtent(OGRLayerH hLayer, OGREnvelope"
#~ " *psExtent, int bForce)"
#~ msgstr ""

#~ msgid ""
#~ "Returns the extent (MBR) of the "
#~ "data in the layer. If bForce is"
#~ " FALSE, and it would be expensive "
#~ "to establish the extent then "
#~ "OGRERR_FAILURE will be returned indicating "
#~ "that the extent isn't know. If "
#~ "bForce is TRUE then some implementations"
#~ " will actually scan the entire layer"
#~ " once to compute the MBR of all"
#~ " the features in the layer."
#~ msgstr ""

#~ msgid ""
#~ "Depending on the drivers, the returned"
#~ " extent may or may not take the"
#~ " spatial filter into account. So it"
#~ " is safer to call OGR_L_GetExtent() "
#~ "without setting a spatial filter."
#~ msgstr ""

#~ msgid ""
#~ "Layers without any geometry may return"
#~ " OGRERR_FAILURE just indicating that no "
#~ "meaningful extents could be collected."
#~ msgstr ""

#~ msgid ""
#~ "Note that some implementations of this"
#~ " method may alter the read cursor "
#~ "of the layer."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetExtent()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer from which to get extent."
#~ msgstr ""

#~ msgid "psExtent:  the structure in which the extent value will be returned."
#~ msgstr ""

#~ msgid ""
#~ "bForce:  Flag indicating whether the "
#~ "extent should be computed even if "
#~ "it is expensive."
#~ msgstr ""

#~ msgid "OGRERR_NONE on success, OGRERR_FAILURE if extent not known."
#~ msgstr ""

#~ msgid "const char* OGR_L_GetFIDColumn(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "This method returns the name of "
#~ "the underlying database column being "
#~ "used as the FID column, or \"\""
#~ " if not supported."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::GetFIDColumn()"
#~ msgstr ""

#~ msgid "OGRFeatureH OGR_L_GetFeature(OGRLayerH hLayer, GIntBig nFeatureId)"
#~ msgstr ""

#~ msgid ""
#~ "This function will attempt to read "
#~ "the identified feature. The nFID value"
#~ " cannot be OGRNullFID. Success or "
#~ "failure of this operation is unaffected"
#~ " by the spatial or attribute filters"
#~ " (and specialized implementations in "
#~ "drivers should make sure that they "
#~ "do not take into account spatial "
#~ "or attribute filters)."
#~ msgstr ""

#~ msgid ""
#~ "If this function returns a non-"
#~ "NULL feature, it is guaranteed that "
#~ "its feature id ( OGR_F_GetFID()) will"
#~ " be the same as nFID."
#~ msgstr ""

#~ msgid ""
#~ "Use OGR_L_TestCapability(OLCRandomRead) to establish"
#~ " if this layer supports efficient "
#~ "random access reading via OGR_L_GetFeature();"
#~ " however, the call should always work"
#~ " if the feature exists as a "
#~ "fallback implementation just scans all "
#~ "the features in the layer looking "
#~ "for the desired feature."
#~ msgstr ""

#~ msgid ""
#~ "Sequential reads (with OGR_L_GetNextFeature()) "
#~ "are generally considered interrupted by "
#~ "a OGR_L_GetFeature() call."
#~ msgstr ""

#~ msgid "The returned feature should be free with OGR_F_Destroy()."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetFeature( )."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer that owned the feature."
#~ msgstr ""

#~ msgid "nFeatureId:  the feature id of the feature to read."
#~ msgstr ""

#~ msgid "a handle to a feature now owned by the caller, or NULL on failure."
#~ msgstr ""

#~ msgid "GIntBig OGR_L_GetFeatureCount(OGRLayerH hLayer, int bForce)"
#~ msgstr ""

#~ msgid ""
#~ "Returns the number of features in "
#~ "the layer. For dynamic databases the "
#~ "count may not be exact. If bForce"
#~ " is FALSE, and it would be "
#~ "expensive to establish the feature count"
#~ " a value of -1 may be returned"
#~ " indicating that the count isn't "
#~ "know. If bForce is TRUE some "
#~ "implementations will actually scan the "
#~ "entire layer once to count objects."
#~ msgstr ""

#~ msgid "The returned count takes the spatial filter into account."
#~ msgstr ""

#~ msgid "This function is the same as the CPP OGRLayer::GetFeatureCount()."
#~ msgstr ""

#~ msgid "Note: since GDAL 2.0, this method returns a GIntBig (previously a int)"
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer that owned the features."
#~ msgstr ""

#~ msgid ""
#~ "bForce:  Flag indicating whether the "
#~ "count should be computed even if "
#~ "it is expensive."
#~ msgstr ""

#~ msgid "feature count, -1 if count not known."
#~ msgstr ""

#~ msgid "GIntBig OGR_L_GetFeaturesRead(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid "OGRwkbGeometryType OGR_L_GetGeomType(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "This returns the same result as "
#~ "OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for"
#~ " a few drivers, calling OGR_L_GetGeomType()"
#~ " directly can avoid lengthy layer "
#~ "definition initialization."
#~ msgstr ""

#~ msgid ""
#~ "For layers with multiple geometry "
#~ "fields, this method only returns the "
#~ "geometry type of the first geometry "
#~ "column. For other columns, use "
#~ "OGR_GFld_GetType(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer),"
#~ " i)). For layers without any geometry"
#~ " field, this method returns wkbNone."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetGeomType()."
#~ msgstr ""

#~ msgid "the geometry type"
#~ msgstr ""

#~ msgid "OGR 1.8.0"
#~ msgstr ""

#~ msgid "const char* OGR_L_GetGeometryColumn(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "This method returns the name of "
#~ "the underlying database column being "
#~ "used as the geometry column, or "
#~ "\"\" if not supported."
#~ msgstr ""

#~ msgid ""
#~ "For layers with multiple geometry "
#~ "fields, this method only returns the "
#~ "geometry type of the first geometry "
#~ "column. For other columns, use OGR "
#~ "_GFld_GetNameRef(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer),"
#~ " i))."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::GetGeometryColumn()"
#~ msgstr ""

#~ msgid "OGRFeatureDefnH OGR_L_GetLayerDefn(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "The returned handle to the "
#~ "OGRFeatureDefn is owned by the OGRLayer,"
#~ " and should not be modified or "
#~ "freed by the application. It "
#~ "encapsulates the attribute schema of the"
#~ " features of the layer."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetLayerDefn()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to get the schema information."
#~ msgstr ""

#~ msgid "a handle to the feature definition."
#~ msgstr ""

#~ msgid "const char* OGR_L_GetName(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "This returns the same content as "
#~ "OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for "
#~ "a few drivers, calling OGR_L_GetName() "
#~ "directly can avoid lengthy layer "
#~ "definition initialization."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetName()."
#~ msgstr ""

#~ msgid "the layer name (must not been freed)"
#~ msgstr ""

#~ msgid "OGRFeatureH OGR_L_GetNextFeature(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "The returned feature becomes the "
#~ "responsibility of the caller to delete"
#~ " with OGR_F_Destroy(). It is critical "
#~ "that all features associated with an "
#~ "OGRLayer (more specifically an OGRFeatureDefn)"
#~ " be deleted before that layer/datasource"
#~ " is deleted."
#~ msgstr ""

#~ msgid ""
#~ "Only features matching the current "
#~ "spatial filter (set with SetSpatialFilter())"
#~ " will be returned."
#~ msgstr ""

#~ msgid ""
#~ "This function implements sequential access "
#~ "to the features of a layer. The"
#~ " OGR_L_ResetReading() function can be used"
#~ " to start at the beginning again."
#~ msgstr ""

#~ msgid ""
#~ "Features returned by OGR_GetNextFeature() may"
#~ " or may not be affected by "
#~ "concurrent modifications depending on drivers."
#~ " A guaranteed way of seeing "
#~ "modifications in effect is to call "
#~ "OGR_L_ResetReading() on layers where "
#~ "OGR_GetNextFeature() has been called, before"
#~ " reading again. Structural changes in "
#~ "layers (field addition, deletion, ...) "
#~ "when a read is in progress may "
#~ "or may not be possible depending "
#~ "on drivers. If a transaction is "
#~ "committed/aborted, the current sequential "
#~ "reading may or may not be valid"
#~ " after that operation and a call "
#~ "to OGR_L_ResetReading() might be needed."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetNextFeature()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer from which feature are read."
#~ msgstr ""

#~ msgid "a handle to a feature, or NULL if no more features are available."
#~ msgstr ""

#~ msgid "int OGR_L_GetRefCount(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_L_GetSpatialFilter(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "The returned pointer is to an "
#~ "internally owned object, and should not"
#~ " be altered or deleted by the "
#~ "caller."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRLayer::GetSpatialFilter()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to get the spatial filter from."
#~ msgstr ""

#~ msgid "a handle to the spatial filter geometry."
#~ msgstr ""

#~ msgid "OGRSpatialReferenceH OGR_L_GetSpatialRef(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "The returned object is owned by "
#~ "the OGRLayer and should not be "
#~ "modified or freed by the application."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::GetSpatialRef()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to get the spatial reference from."
#~ msgstr ""

#~ msgid "spatial reference, or NULL if there isn't one."
#~ msgstr ""

#~ msgid "OGRStyleTableH OGR_L_GetStyleTable(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_Identity(OGRLayerH pLayerInput, "
#~ "OGRLayerH pLayerMethod, OGRLayerH pLayerResult, "
#~ "char **papszOptions, GDALProgressFunc pfnProgress,"
#~ " void *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "in the input layer. The features "
#~ "in the result layer have attributes "
#~ "from both input and method layers. "
#~ "The schema of the result layer can"
#~ " be set by the user or, if "
#~ "it is empty, is initialized to "
#~ "contain all fields in input and "
#~ "method layers."
#~ msgstr ""

#~ msgid ""
#~ "If the schema of the result is "
#~ "set by user and contains fields "
#~ "that have the same name as a "
#~ "field in input and in method "
#~ "layer, then the attribute in the "
#~ "result feature will get the value "
#~ "from the feature of the method "
#~ "layer (even if it is undefined)."
#~ msgstr ""

#~ msgid ""
#~ "USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to"
#~ " not use prepared geometries to "
#~ "pretest intersection of features of "
#~ "method layer with features of this "
#~ "layer."
#~ msgstr ""

#~ msgid ""
#~ "KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO"
#~ " to skip result features with lower"
#~ " dimension geometry that would otherwise"
#~ " be added to the result layer. "
#~ "The default is to add but only "
#~ "if the result layer has an unknown"
#~ " geometry type."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::Identity()."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_Intersection(OGRLayerH pLayerInput, "
#~ "OGRLayerH pLayerMethod, OGRLayerH pLayerResult, "
#~ "char **papszOptions, GDALProgressFunc pfnProgress,"
#~ " void *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "common between features in the input "
#~ "layer and in the method layer. The"
#~ " features in the result layer have"
#~ " attributes from both input and "
#~ "method layers. The schema of the "
#~ "result layer can be set by the "
#~ "user or, if it is empty, is "
#~ "initialized to contain all fields in "
#~ "the input and method layers."
#~ msgstr ""

#~ msgid ""
#~ "If the schema of the result is "
#~ "set by user and contains fields "
#~ "that have the same name as a "
#~ "field in input and in method "
#~ "layer, then the attribute in the "
#~ "result feature will get the value "
#~ "from the feature of the method "
#~ "layer."
#~ msgstr ""

#~ msgid ""
#~ "PRETEST_CONTAINMENT=YES/NO. Set to YES to "
#~ "pretest the containment of features of"
#~ " method layer within the features of"
#~ " this layer. This will speed up "
#~ "the method significantly in some cases."
#~ " Requires that the prepared geometries "
#~ "are in effect."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::Intersection()."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_ReorderField(OGRLayerH hLayer, int "
#~ "iOldFieldPos, int iNewFieldPos)"
#~ msgstr ""

#~ msgid ""
#~ "This function is a convenience wrapper"
#~ " of OGR_L_ReorderFields() dedicated to move"
#~ " a single field."
#~ msgstr ""

#~ msgid ""
#~ "You must use this to reorder "
#~ "existing fields on a real layer. "
#~ "Internally the OGRFeatureDefn for the "
#~ "layer will be updated to reflect "
#~ "the reordering of the fields. "
#~ "Applications should never modify the "
#~ "OGRFeatureDefn used by a layer directly."
#~ msgstr ""

#~ msgid ""
#~ "The field definition that was at "
#~ "initial position iOldFieldPos will be "
#~ "moved at position iNewFieldPos, and "
#~ "elements between will be shuffled "
#~ "accordingly."
#~ msgstr ""

#~ msgid ""
#~ "For example, let suppose the fields "
#~ "were \"0\",\"1\",\"2\",\"3\",\"4\" initially. "
#~ "ReorderField(1, 3) will reorder them as"
#~ " \"0\",\"2\",\"3\",\"1\",\"4\"."
#~ msgstr ""

#~ msgid ""
#~ "Not all drivers support this function."
#~ " You can query a layer to check"
#~ " if it supports it with the "
#~ "OLCReorderFields capability. Some drivers may"
#~ " only support this method while there"
#~ " are still no features in the "
#~ "layer. When it is supported, the "
#~ "existing features of the backing "
#~ "file/database should be updated accordingly."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::ReorderField()."
#~ msgstr ""

#~ msgid ""
#~ "iOldFieldPos:  previous position of the "
#~ "field to move. Must be in the "
#~ "range [0,GetFieldCount()-1]."
#~ msgstr ""

#~ msgid ""
#~ "iNewFieldPos:  new position of the field"
#~ " to move. Must be in the range"
#~ " [0,GetFieldCount()-1]."
#~ msgstr ""

#~ msgid "OGRErr OGR_L_ReorderFields(OGRLayerH hLayer, int *panMap)"
#~ msgstr ""

#~ msgid ""
#~ "panMap is such that,for each field "
#~ "definition at position i after "
#~ "reordering, its position before reordering "
#~ "was panMap[i]."
#~ msgstr ""

#~ msgid ""
#~ "For example, let suppose the fields "
#~ "were \"0\",\"1\",\"2\",\"3\",\"4\" initially. "
#~ "ReorderFields([0,2,3,1,4]) will reorder them "
#~ "as \"0\",\"2\",\"3\",\"1\",\"4\"."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::ReorderFields()."
#~ msgstr ""

#~ msgid ""
#~ "panMap:  an array of GetLayerDefn()-> "
#~ "OGRFeatureDefn::GetFieldCount() elements which is"
#~ " a permutation of [0, GetLayerDefn()-> "
#~ "OGRFeatureDefn::GetFieldCount()-1]."
#~ msgstr ""

#~ msgid "void OGR_L_ResetReading(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid "This affects GetNextFeature()."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::ResetReading()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer on which features are read."
#~ msgstr ""

#~ msgid "OGRErr OGR_L_RollbackTransaction(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "For datasources which support transactions,"
#~ " RollbackTransaction will roll back a "
#~ "datasource to its state before the "
#~ "start of the current transaction."
#~ msgstr ""

#~ msgid ""
#~ "If no transaction is active, or "
#~ "the rollback fails, will return "
#~ "OGRERR_FAILURE. Datasources which do not "
#~ "support transactions will always return "
#~ "OGRERR_NONE."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRLayer::RollbackTransaction()."
#~ msgstr ""

#~ msgid "OGRErr OGR_L_SetAttributeFilter(OGRLayerH hLayer, const char *pszQuery)"
#~ msgstr ""

#~ msgid ""
#~ "This function sets the attribute query"
#~ " string to be used when fetching "
#~ "features via the OGR_L_GetNextFeature() "
#~ "function. Only features for which the"
#~ " query evaluates as true will be "
#~ "returned."
#~ msgstr ""

#~ msgid ""
#~ "The query string should be in the"
#~ " format of an SQL WHERE clause. "
#~ "For instance \"population > 1000000 and"
#~ " population < 5000000\" where population"
#~ " is an attribute in the layer. "
#~ "The query format is a restricted "
#~ "form of SQL WHERE clause as "
#~ "defined \"eq_format=restricted_where\" about half"
#~ " way through this document:"
#~ msgstr ""

#~ msgid "http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html"
#~ msgstr ""

#~ msgid ""
#~ "Note that installing a query string "
#~ "will generally result in resetting the"
#~ " current reading position (ala "
#~ "OGR_L_ResetReading())."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRLayer::SetAttributeFilter()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer on which attribute query will be executed."
#~ msgstr ""

#~ msgid ""
#~ "pszQuery:  query in restricted SQL WHERE"
#~ " format, or NULL to clear the "
#~ "current query."
#~ msgstr ""

#~ msgid ""
#~ "OGRERR_NONE if successfully installed, or "
#~ "an error code if the query "
#~ "expression is in error, or some "
#~ "other failure occurs."
#~ msgstr ""

#~ msgid "OGRErr OGR_L_SetFeature(OGRLayerH hLayer, OGRFeatureH hFeat)"
#~ msgstr ""

#~ msgid ""
#~ "This function will write a feature "
#~ "to the layer, based on the feature"
#~ " id within the OGRFeature."
#~ msgstr ""

#~ msgid ""
#~ "Use OGR_L_TestCapability(OLCRandomWrite) to "
#~ "establish if this layer supports random"
#~ " access writing via OGR_L_SetFeature()."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::SetFeature()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to write the feature."
#~ msgstr ""

#~ msgid "hFeat:  the feature to write."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_SetIgnoredFields(OGRLayerH hLayer, "
#~ "const char **papszFields)"
#~ msgstr ""

#~ msgid ""
#~ "If the driver supports this "
#~ "functionality (testable using OLCIgnoreFields "
#~ "capability), it will not fetch the "
#~ "specified fields in subsequent calls to"
#~ " GetFeature() / GetNextFeature() and thus"
#~ " save some processing time and/or "
#~ "bandwidth."
#~ msgstr ""

#~ msgid ""
#~ "Besides field names of the layers, "
#~ "the following special fields can be "
#~ "passed: \"OGR_GEOMETRY\" to ignore geometry"
#~ " and \"OGR_STYLE\" to ignore layer "
#~ "style."
#~ msgstr ""

#~ msgid "By default, no fields are ignored."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::SetIgnoredFields()"
#~ msgstr ""

#~ msgid ""
#~ "papszFields:  an array of field names"
#~ " terminated by NULL item. If NULL "
#~ "is passed, the ignored list is "
#~ "cleared."
#~ msgstr ""

#~ msgid ""
#~ "OGRERR_NONE if all field names have "
#~ "been resolved (even if the driver "
#~ "does not support this method)"
#~ msgstr ""

#~ msgid "OGRErr OGR_L_SetNextByIndex(OGRLayerH hLayer, GIntBig nIndex)"
#~ msgstr ""

#~ msgid ""
#~ "This method allows positioning of a "
#~ "layer such that the GetNextFeature() "
#~ "call will read the requested feature,"
#~ " where nIndex is an absolute index"
#~ " into the current result set. So, "
#~ "setting it to 3 would mean the "
#~ "next feature read with GetNextFeature() "
#~ "would have been the 4th feature to"
#~ " have been read if sequential reading"
#~ " took place from the beginning of "
#~ "the layer, including accounting for "
#~ "spatial and attribute filters."
#~ msgstr ""

#~ msgid ""
#~ "Only in rare circumstances is "
#~ "SetNextByIndex() efficiently implemented. In "
#~ "all other cases the default "
#~ "implementation which calls ResetReading() and"
#~ " then calls GetNextFeature() nIndex times"
#~ " is used. To determine if fast "
#~ "seeking is available on the current "
#~ "layer use the TestCapability() method "
#~ "with a value of OLCFastSetNextByIndex."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::SetNextByIndex()"
#~ msgstr ""

#~ msgid ""
#~ "nIndex:  the index indicating how many"
#~ " steps into the result set to "
#~ "seek."
#~ msgstr ""

#~ msgid "OGRERR_NONE on success or an error code."
#~ msgstr ""

#~ msgid "void OGR_L_SetSpatialFilter(OGRLayerH hLayer, OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This function set the geometry to "
#~ "be used as a spatial filter when"
#~ " fetching features via the "
#~ "OGR_L_GetNextFeature() function. Only features "
#~ "that geometrically intersect the filter "
#~ "geometry will be returned."
#~ msgstr ""

#~ msgid ""
#~ "Currently this test is may be "
#~ "inaccurately implemented, but it is "
#~ "guaranteed that all features whose "
#~ "envelope (as returned by OGR_G_GetEnvelope())"
#~ " overlaps the envelope of the spatial"
#~ " filter will be returned. This can"
#~ " result in more shapes being returned"
#~ " that should strictly be the case."
#~ msgstr ""

#~ msgid ""
#~ "Starting with GDAL 2.3, features with"
#~ " null or empty geometries will never"
#~ " be considered as matching a spatial"
#~ " filter."
#~ msgstr ""

#~ msgid ""
#~ "This function makes an internal copy "
#~ "of the passed geometry. The passed "
#~ "geometry remains the responsibility of "
#~ "the caller, and may be safely "
#~ "destroyed."
#~ msgstr ""

#~ msgid ""
#~ "For the time being the passed "
#~ "filter geometry should be in the "
#~ "same SRS as the layer (as returned"
#~ " by OGR_L_GetSpatialRef()). In the future"
#~ " this may be generalized."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::SetSpatialFilter."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer on which to set the spatial filter."
#~ msgstr ""

#~ msgid ""
#~ "hGeom:  handle to the geometry to "
#~ "use as a filtering region. NULL "
#~ "may be passed indicating that the "
#~ "current spatial filter should be "
#~ "cleared, but no new one instituted."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_L_SetSpatialFilterRect(OGRLayerH hLayer, "
#~ "double dfMinX, double dfMinY, double "
#~ "dfMaxX, double dfMaxY)"
#~ msgstr ""

#~ msgid ""
#~ "This method set rectangle to be "
#~ "used as a spatial filter when "
#~ "fetching features via the "
#~ "OGR_L_GetNextFeature() method. Only features "
#~ "that geometrically intersect the given "
#~ "rectangle will be returned."
#~ msgstr ""

#~ msgid ""
#~ "The x/y values should be in the"
#~ " same coordinate system as the layer"
#~ " as a whole (as returned by "
#~ "OGRLayer::GetSpatialRef()). Internally this method"
#~ " is normally implemented as creating "
#~ "a 5 vertex closed rectangular polygon"
#~ " and passing it to "
#~ "OGRLayer::SetSpatialFilter(). It exists as a"
#~ " convenience."
#~ msgstr ""

#~ msgid ""
#~ "The only way to clear a spatial"
#~ " filter set with this method is "
#~ "to call OGRLayer::SetSpatialFilter(NULL)."
#~ msgstr ""

#~ msgid ""
#~ "This method is the same as the "
#~ "C++ method OGRLayer::SetSpatialFilterRect()."
#~ msgstr ""

#~ msgid "dfMinX:  the minimum X coordinate for the rectangular region."
#~ msgstr ""

#~ msgid "dfMinY:  the minimum Y coordinate for the rectangular region."
#~ msgstr ""

#~ msgid "dfMaxX:  the maximum X coordinate for the rectangular region."
#~ msgstr ""

#~ msgid "dfMaxY:  the maximum Y coordinate for the rectangular region."
#~ msgstr ""

#~ msgid "void OGR_L_SetStyleTable(OGRLayerH hLayer, OGRStyleTableH hStyleTable)"
#~ msgstr ""

#~ msgid "OGRErr OGR_L_StartTransaction(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "For datasources which support transactions,"
#~ " StartTransaction creates a transaction."
#~ msgstr ""

#~ msgid ""
#~ "If starting the transaction fails, will"
#~ " return OGRERR_FAILURE. Datasources which "
#~ "do not support transactions will always"
#~ " return OGRERR_NONE."
#~ msgstr ""

#~ msgid ""
#~ "Note: as of GDAL 2.0, use of "
#~ "this API is discouraged when the "
#~ "dataset offers dataset level transaction "
#~ "with GDALDataset::StartTransaction(). The reason "
#~ "is that most drivers can only "
#~ "offer transactions at dataset level, and"
#~ " not layer level. Very few drivers"
#~ " really support transactions at layer "
#~ "scope."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRLayer::StartTransaction()."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_SymDifference(OGRLayerH pLayerInput, "
#~ "OGRLayerH pLayerMethod, OGRLayerH pLayerResult, "
#~ "char **papszOptions, GDALProgressFunc pfnProgress,"
#~ " void *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "in either in the input layer or"
#~ " in the method layer but not in"
#~ " both. The features in the result "
#~ "layer have attributes from both input"
#~ " and method layers. For features "
#~ "which represent areas that are only "
#~ "in the input or in the method "
#~ "layer the respective attributes have "
#~ "undefined values. The schema of the "
#~ "result layer can be set by the "
#~ "user or, if it is empty, is "
#~ "initialized to contain all fields in "
#~ "the input and method layers."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::SymDifference()."
#~ msgstr ""

#~ msgid "OGRErr OGR_L_SyncToDisk(OGRLayerH hLayer)"
#~ msgstr ""

#~ msgid ""
#~ "This call is intended to force the"
#~ " layer to flush any pending writes"
#~ " to disk, and leave the disk "
#~ "file in a consistent state. It "
#~ "would not normally have any effect "
#~ "on read-only datasources."
#~ msgstr ""

#~ msgid ""
#~ "Some layers do not implement this "
#~ "method, and will still return "
#~ "OGRERR_NONE. The default implementation just"
#~ " returns OGRERR_NONE. An error is "
#~ "only returned if an error occurs "
#~ "while attempting to flush to disk."
#~ msgstr ""

#~ msgid ""
#~ "In any event, you should always "
#~ "close any opened datasource with "
#~ "OGR_DS_Destroy() that will ensure all "
#~ "data is correctly flushed."
#~ msgstr ""

#~ msgid "This method is the same as the C++ method OGRLayer::SyncToDisk()"
#~ msgstr ""

#~ msgid ""
#~ "OGRERR_NONE if no error occurs (even "
#~ "if nothing is done) or an error"
#~ " code."
#~ msgstr ""

#~ msgid "int OGR_L_TestCapability(OGRLayerH hLayer, const char *pszCap)"
#~ msgstr ""

#~ msgid ""
#~ "The capability codes that can be "
#~ "tested are represented as strings, but"
#~ " #defined constants exists to ensure "
#~ "correct spelling. Specific layer types "
#~ "may implement class specific capabilities, "
#~ "but this can't generally be discovered"
#~ " by the caller."
#~ msgstr ""

#~ msgid ""
#~ "OLCRandomRead / \"RandomRead\": TRUE if "
#~ "the GetFeature() method is implemented "
#~ "in an optimized way for this "
#~ "layer, as opposed to the default "
#~ "implementation using ResetReading() and "
#~ "GetNextFeature() to find the requested "
#~ "feature id."
#~ msgstr ""

#~ msgid ""
#~ "OLCSequentialWrite / \"SequentialWrite\": TRUE "
#~ "if the CreateFeature() method works for"
#~ " this layer. Note this means that "
#~ "this particular layer is writable. The"
#~ " same OGRLayer class may returned "
#~ "FALSE for other layer instances that "
#~ "are effectively read-only."
#~ msgstr ""

#~ msgid ""
#~ "OLCRandomWrite / \"RandomWrite\": TRUE if "
#~ "the SetFeature() method is operational "
#~ "on this layer. Note this means "
#~ "that this particular layer is writable."
#~ " The same OGRLayer class may returned"
#~ " FALSE for other layer instances that"
#~ " are effectively read-only."
#~ msgstr ""

#~ msgid ""
#~ "OLCFastSpatialFilter / \"FastSpatialFilter\": TRUE"
#~ " if this layer implements spatial "
#~ "filtering efficiently. Layers that effectively"
#~ " read all features, and test them "
#~ "with the OGRFeature intersection methods "
#~ "should return FALSE. This can be "
#~ "used as a clue by the application"
#~ " whether it should build and maintain"
#~ " its own spatial index for features"
#~ " in this layer."
#~ msgstr ""

#~ msgid ""
#~ "OLCFastFeatureCount / \"FastFeatureCount\": TRUE "
#~ "if this layer can return a feature"
#~ " count (via OGR_L_GetFeatureCount()) efficiently,"
#~ " i.e. without counting the features. "
#~ "In some cases this will return "
#~ "TRUE until a spatial filter is "
#~ "installed after which it will return "
#~ "FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCFastGetExtent / \"FastGetExtent\": TRUE if"
#~ " this layer can return its data "
#~ "extent (via OGR_L_GetExtent()) efficiently, "
#~ "i.e. without scanning all the features."
#~ " In some cases this will return "
#~ "TRUE until a spatial filter is "
#~ "installed after which it will return "
#~ "FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCFastSetNextByIndex / \"FastSetNextByIndex\": TRUE"
#~ " if this layer can perform the "
#~ "SetNextByIndex() call efficiently, otherwise "
#~ "FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCCreateField / \"CreateField\": TRUE if "
#~ "this layer can create new fields "
#~ "on the current layer using "
#~ "CreateField(), otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCCreateGeomField / \"CreateGeomField\": (GDAL "
#~ ">= 1.11) TRUE if this layer can"
#~ " create new geometry fields on the"
#~ " current layer using CreateGeomField(), "
#~ "otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCDeleteField / \"DeleteField\": TRUE if "
#~ "this layer can delete existing fields"
#~ " on the current layer using "
#~ "DeleteField(), otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCReorderFields / \"ReorderFields\": TRUE if"
#~ " this layer can reorder existing "
#~ "fields on the current layer using "
#~ "ReorderField() or ReorderFields(), otherwise "
#~ "FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCAlterFieldDefn / \"AlterFieldDefn\": TRUE "
#~ "if this layer can alter the "
#~ "definition of an existing field on "
#~ "the current layer using AlterFieldDefn(), "
#~ "otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCDeleteFeature / \"DeleteFeature\": TRUE if"
#~ " the DeleteFeature() method is supported"
#~ " on this layer, otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCStringsAsUTF8 / \"StringsAsUTF8\": TRUE if"
#~ " values of OFTString fields are "
#~ "assured to be in UTF-8 format. If"
#~ " FALSE the encoding of fields is "
#~ "uncertain, though it might still be "
#~ "UTF-8."
#~ msgstr ""

#~ msgid ""
#~ "OLCTransactions / \"Transactions\": TRUE if"
#~ " the StartTransaction(), CommitTransaction() and"
#~ " RollbackTransaction() methods work in a"
#~ " meaningful way, otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OLCCurveGeometries / \"CurveGeometries\": TRUE "
#~ "if this layer supports writing curve "
#~ "geometries or may return such "
#~ "geometries. (GDAL 2.0)."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::TestCapability()."
#~ msgstr ""

#~ msgid "hLayer:  handle to the layer to get the capability from."
#~ msgstr ""

#~ msgid "pszCap:  the name of the capability to test."
#~ msgstr ""

#~ msgid ""
#~ "TRUE if the layer has the "
#~ "requested capability, or FALSE otherwise. "
#~ "OGRLayers will return FALSE for any "
#~ "unrecognized capabilities."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_Union(OGRLayerH pLayerInput, OGRLayerH"
#~ " pLayerMethod, OGRLayerH pLayerResult, char "
#~ "**papszOptions, GDALProgressFunc pfnProgress, void"
#~ " *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "in either in the input layer, in"
#~ " the method layer, or in both. "
#~ "The features in the result layer "
#~ "have attributes from both input and "
#~ "method layers. For features which "
#~ "represent areas that are only in "
#~ "the input or in the method layer"
#~ " the respective attributes have undefined"
#~ " values. The schema of the result "
#~ "layer can be set by the user "
#~ "or, if it is empty, is initialized"
#~ " to contain all fields in the "
#~ "input and method layers."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::Union()."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_L_Update(OGRLayerH pLayerInput, OGRLayerH"
#~ " pLayerMethod, OGRLayerH pLayerResult, char "
#~ "**papszOptions, GDALProgressFunc pfnProgress, void"
#~ " *pProgressArg)"
#~ msgstr ""

#~ msgid ""
#~ "The result layer contains features whose"
#~ " geometries represent areas that are "
#~ "either in the input layer or in"
#~ " the method layer. The features in"
#~ " the result layer have areas of "
#~ "the features of the method layer "
#~ "or those ares of the features of"
#~ " the input layer that are not "
#~ "covered by the method layer. The "
#~ "features of the result layer get "
#~ "their attributes from the input layer."
#~ " The schema of the result layer "
#~ "can be set by the user or, "
#~ "if it is empty, is initialized to"
#~ " contain all fields in the input "
#~ "layer."
#~ msgstr ""

#~ msgid ""
#~ "If the schema of the result is "
#~ "set by user and contains fields "
#~ "that have the same name as a "
#~ "field in the method layer, then "
#~ "the attribute in the result feature "
#~ "the originates from the method layer "
#~ "will get the value from the "
#~ "feature of the method layer."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRLayer::Update()."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to clone."
#~ msgstr ""

#~ msgid "void OGR_F_DumpReadable(OGRFeatureH hFeat, FILE *fpOut)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to dump."
#~ msgstr ""

#~ msgid "fpOut:  the stream to write to, such as strout."
#~ msgstr ""

#~ msgid "hFeat:  handle to one of the feature."
#~ msgstr ""

#~ msgid "hOtherFeat:  handle to the other feature to test this one against."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_F_FillUnsetWithDefault(OGRFeatureH hFeat, "
#~ "int bNotNullableOnly, char **papszOptions)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature."
#~ msgstr ""

#~ msgid ""
#~ "bNotNullableOnly:  if we should fill "
#~ "only unset fields with a not-null"
#~ " constraint."
#~ msgstr ""

#~ msgid "papszOptions:  unused currently. Must be set to NULL."
#~ msgstr ""

#~ msgid "GDAL 2.0"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to get the feature definition from."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature from which to get the feature identifier."
#~ msgstr ""

#~ msgid ""
#~ "GByte* OGR_F_GetFieldAsBinary(OGRFeatureH hFeat, int"
#~ " iField, int *pnBytes)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature that owned the field."
#~ msgstr ""

#~ msgid "iField:  the field to fetch, from 0 to GetFieldCount()-1."
#~ msgstr ""

#~ msgid "pnBytes:  location to place count of bytes returned."
#~ msgstr ""

#~ msgid ""
#~ "int OGR_F_GetFieldAsDateTime(OGRFeatureH hFeat, int"
#~ " iField, int *pnYear, int *pnMonth, "
#~ "int *pnDay, int *pnHour, int *pnMinute,"
#~ " int *pnSecond, int *pnTZFlag)"
#~ msgstr ""

#~ msgid "pnYear:  (including century)"
#~ msgstr ""

#~ msgid "pnMonth:  (1-12)"
#~ msgstr ""

#~ msgid "pnDay:  (1-31)"
#~ msgstr ""

#~ msgid "pnHour:  (0-23)"
#~ msgstr ""

#~ msgid "pnMinute:  (0-59)"
#~ msgstr ""

#~ msgid "pnSecond:  (0-59)"
#~ msgstr ""

#~ msgid ""
#~ "pnTZFlag:  (0=unknown, 1=localtime, 100=GMT, "
#~ "see data model for details)"
#~ msgstr ""

#~ msgid ""
#~ "See:  Use OGR_F_GetFieldAsDateTimeEx() for "
#~ "second with millisecond accuracy."
#~ msgstr ""

#~ msgid ""
#~ "const double* OGR_F_GetFieldAsDoubleList(OGRFeatureH "
#~ "hFeat, int iField, int *pnCount)"
#~ msgstr ""

#~ msgid "pnCount:  an integer to put the list count (number of doubles) into."
#~ msgstr ""

#~ msgid ""
#~ "the field value. This list is "
#~ "internal, and should not be modified,"
#~ " or freed. Its lifetime may be "
#~ "very brief. If *pnCount is zero on"
#~ " return the returned pointer may be"
#~ " NULL or non-NULL."
#~ msgstr ""

#~ msgid ""
#~ "const GIntBig* OGR_F_GetFieldAsInteger64List(OGRFeatureH"
#~ " hFeat, int iField, int *pnCount)"
#~ msgstr ""

#~ msgid "pnCount:  an integer to put the list count (number of integers) into."
#~ msgstr ""

#~ msgid ""
#~ "const int* OGR_F_GetFieldAsIntegerList(OGRFeatureH "
#~ "hFeat, int iField, int *pnCount)"
#~ msgstr ""

#~ msgid "const char* OGR_F_GetFieldAsString(OGRFeatureH hFeat, int iField)"
#~ msgstr ""

#~ msgid "char** OGR_F_GetFieldAsStringList(OGRFeatureH hFeat, int iField)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to get the fields count from."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature on which the field is found."
#~ msgstr ""

#~ msgid "i:  the field to fetch, from 0 to GetFieldCount()-1."
#~ msgstr ""

#~ msgid "int OGR_F_GetFieldIndex(OGRFeatureH hFeat, const char *pszName)"
#~ msgstr ""

#~ msgid "pszName:  the name of the field to search for."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to get the geometry fields count from."
#~ msgstr ""

#~ msgid "GDAL 1.11"
#~ msgstr ""

#~ msgid "i:  the field to fetch, from 0 to GetGeomFieldCount()-1."
#~ msgstr ""

#~ msgid "int OGR_F_GetGeomFieldIndex(OGRFeatureH hFeat, const char *pszName)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature on which the geometry field is found."
#~ msgstr ""

#~ msgid "pszName:  the name of the geometry field to search for."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to get geometry from."
#~ msgstr ""

#~ msgid "iField:  geometry field to get."
#~ msgstr ""

#~ msgid ""
#~ "a handle to internal feature geometry."
#~ " This object should not be modified."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_F_GetGeometryRef(OGRFeatureH hFeat)"
#~ msgstr ""

#~ msgid ""
#~ "This function is essentially the same"
#~ " as the C++ method "
#~ "OGRFeature::GetGeometryRef() (the only difference"
#~ " is that this C function honours "
#~ "OGRGetNonLinearGeometriesEnabledFlag())"
#~ msgstr ""

#~ msgid "const char* OGR_F_GetNativeData(OGRFeatureH hFeat)"
#~ msgstr ""

#~ msgid "GDAL 2.1"
#~ msgstr ""

#~ msgid ""
#~ "See: "
#~ "https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr"
#~ msgstr ""

#~ msgid "const char* OGR_F_GetNativeMediaType(OGRFeatureH hFeat)"
#~ msgstr ""

#~ msgid "const char* OGR_F_GetStyleString(OGRFeatureH hFeat)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to get the style from."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature on which the field is."
#~ msgstr ""

#~ msgid "iField:  the field to test."
#~ msgstr ""

#~ msgid "GDAL 2.2"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to set the feature id to."
#~ msgstr ""

#~ msgid "nFID:  the new feature identifier value to assign."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_F_SetFieldDoubleList(OGRFeatureH hFeat, int"
#~ " iField, int nCount, const double "
#~ "*padfValues)"
#~ msgstr ""

#~ msgid "iField:  the field to set, from 0 to GetFieldCount()-1."
#~ msgstr ""

#~ msgid "nCount:  the number of values in the list being assigned."
#~ msgstr ""

#~ msgid "padfValues:  the values to assign."
#~ msgstr ""

#~ msgid "nValue:  the value to assign."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_F_SetFieldInteger64List(OGRFeatureH hFeat, "
#~ "int iField, int nCount, const GIntBig"
#~ " *panValues)"
#~ msgstr ""

#~ msgid "panValues:  the values to assign."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_F_SetFieldIntegerList(OGRFeatureH hFeat, "
#~ "int iField, int nCount, const int "
#~ "*panValues)"
#~ msgstr ""

#~ msgid "iField:  the field to set to null."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_F_SetFieldString(OGRFeatureH hFeat, int "
#~ "iField, const char *pszValue)"
#~ msgstr ""

#~ msgid "pszValue:  the value to assign."
#~ msgstr ""

#~ msgid ""
#~ "papszValues:  the values to assign. List"
#~ " of NUL-terminated string, ending "
#~ "with a NULL pointer."
#~ msgstr ""

#~ msgid ""
#~ "Overwrite the contents of this feature"
#~ " from the geometry and attributes of"
#~ " another. The hOtherFeature does not "
#~ "need to have the same OGRFeatureDefn."
#~ " Field values are copied by "
#~ "corresponding field names. Field types "
#~ "do not have to exactly match. "
#~ "OGR_F_SetField*() function conversion rules "
#~ "will be applied as needed."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to set to."
#~ msgstr ""

#~ msgid ""
#~ "hOtherFeat:  handle to the feature from"
#~ " which geometry, and field values "
#~ "will be copied."
#~ msgstr ""

#~ msgid ""
#~ "bForgiving:  TRUE if the operation "
#~ "should continue despite lacking output "
#~ "fields matching some of the source "
#~ "fields."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_F_SetFromWithMap(OGRFeatureH hFeat, "
#~ "OGRFeatureH hOtherFeat, int bForgiving, const"
#~ " int *panMap)"
#~ msgstr ""

#~ msgid ""
#~ "Overwrite the contents of this feature"
#~ " from the geometry and attributes of"
#~ " another. The hOtherFeature does not "
#~ "need to have the same OGRFeatureDefn."
#~ " Field values are copied according to"
#~ " the provided indices map. Field "
#~ "types do not have to exactly "
#~ "match. OGR_F_SetField*() function conversion "
#~ "rules will be applied as needed. "
#~ "This is more efficient than "
#~ "OGR_F_SetFrom() in that this doesn't "
#~ "lookup the fields by their names. "
#~ "Particularly useful when the field names"
#~ " don't match."
#~ msgstr ""

#~ msgid ""
#~ "panMap:  Array of the indices of "
#~ "the destination feature's fields stored "
#~ "at the corresponding index of the "
#~ "source feature's fields. A value of "
#~ "-1 should be used to ignore the"
#~ " source's field. The array should not"
#~ " be NULL and be as long as "
#~ "the number of fields in the source"
#~ " feature."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature on which new geometry is applied to."
#~ msgstr ""

#~ msgid "iField:  geometry field to set."
#~ msgstr ""

#~ msgid "hGeom:  handle to the new geometry to apply to feature."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature on which to apply the geometry."
#~ msgstr ""

#~ msgid "void OGR_F_SetNativeData(OGRFeatureH hFeat, const char *pszNativeData)"
#~ msgstr ""

#~ msgid ""
#~ "pszNativeData:  a string with the native"
#~ " data, or NULL if there is "
#~ "none."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_F_SetNativeMediaType(OGRFeatureH hFeat, "
#~ "const char *pszNativeMediaType)"
#~ msgstr ""

#~ msgid ""
#~ "pszNativeMediaType:  a string with the "
#~ "native media type, or NULL if "
#~ "there is none."
#~ msgstr ""

#~ msgid "void OGR_F_SetStyleString(OGRFeatureH hFeat, const char *pszStyle)"
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to set style to."
#~ msgstr ""

#~ msgid "pszStyle:  the style string to apply to this feature, cannot be NULL."
#~ msgstr ""

#~ msgid "iField:  the field to unset."
#~ msgstr ""

#~ msgid "hFeat:  handle to the feature to validate."
#~ msgstr ""

#~ msgid ""
#~ "nValidateFlags:  OGR_F_VAL_ALL or combination "
#~ "of OGR_F_VAL_NULL, OGR_F_VAL_GEOM_TYPE, "
#~ "OGR_F_VAL_WIDTH and OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT "
#~ "with '|' operator"
#~ msgstr ""

#~ msgid "bEmitError:  TRUE if a CPLError() must be emitted when a check fails"
#~ msgstr ""

#~ msgid ""
#~ "void OGR_G_AssignSpatialReference(OGRGeometryH hGeom, "
#~ "OGRSpatialReferenceH hSRS)"
#~ msgstr ""

#~ msgid ""
#~ "Any existing spatial reference is "
#~ "replaced, but under no circumstances "
#~ "does this result in the object "
#~ "being reprojected. It is just changing"
#~ " the interpretation of the existing "
#~ "geometry. Note that assigning a spatial"
#~ " reference increments the reference count"
#~ " on the OGRSpatialReference, but does "
#~ "not copy it."
#~ msgstr ""

#~ msgid ""
#~ "Starting with GDAL 2.3, this will "
#~ "also assign the spatial reference to "
#~ "potential sub-geometries of the geometry"
#~ " ( OGRGeometryCollection, OGRCurvePolygon/OGRPolygon,"
#~ " OGRCompoundCurve, OGRPolyhedralSurface and their"
#~ " derived classes)."
#~ msgstr ""

#~ msgid "This is similar to the SFCOM IGeometry::put_SpatialReference() method."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::assignSpatialReference."
#~ msgstr ""

#~ msgid ""
#~ "hGeom:  handle on the geometry to "
#~ "apply the new spatial reference system."
#~ msgstr ""

#~ msgid "hSRS:  handle on the new spatial reference system to apply."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_Boundary(OGRGeometryH hTarget)"
#~ msgstr ""

#~ msgid ""
#~ "A new geometry object is created "
#~ "and returned containing the boundary of"
#~ " the geometry on which the method "
#~ "is invoked."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGR_G_Boundary()."
#~ msgstr ""

#~ msgid ""
#~ "This function is built on the GEOS"
#~ " library, check it for the definition"
#~ " of the geometry operation. If OGR"
#~ " is built without the GEOS library,"
#~ " this function will always fail, "
#~ "issuing a CPLE_NotSupported error."
#~ msgstr ""

#~ msgid "hTarget:  The Geometry to calculate the boundary of."
#~ msgstr ""

#~ msgid ""
#~ "a handle to a newly allocated "
#~ "geometry now owned by the caller, "
#~ "or NULL on failure."
#~ msgstr ""

#~ msgid ""
#~ "OGRGeometryH OGR_G_Buffer(OGRGeometryH hTarget, "
#~ "double dfDist, int nQuadSegs)"
#~ msgstr ""

#~ msgid ""
#~ "Builds a new geometry containing the "
#~ "buffer region around the geometry on "
#~ "which it is invoked. The buffer is"
#~ " a polygon containing the region "
#~ "within the buffer distance of the "
#~ "original geometry."
#~ msgstr ""

#~ msgid ""
#~ "Some buffer sections are properly "
#~ "described as curves, but are converted"
#~ " to approximate polygons. The nQuadSegs "
#~ "parameter can be used to control "
#~ "how many segments should be used "
#~ "to define a 90 degree curve - "
#~ "a quadrant of a circle. A value"
#~ " of 30 is a reasonable default. "
#~ "Large values result in large numbers "
#~ "of vertices in the resulting buffer "
#~ "geometry while small numbers reduce the"
#~ " accuracy of the result."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Buffer()."
#~ msgstr ""

#~ msgid "hTarget:  the geometry."
#~ msgstr ""

#~ msgid ""
#~ "dfDist:  the buffer distance to be "
#~ "applied. Should be expressed into the"
#~ " same unit as the coordinates of "
#~ "the geometry."
#~ msgstr ""

#~ msgid ""
#~ "nQuadSegs:  the number of segments used"
#~ " to approximate a 90 degree "
#~ "(quadrant) of curvature."
#~ msgstr ""

#~ msgid "the newly created geometry, or NULL if an error occurs."
#~ msgstr ""

#~ msgid "int OGR_G_Centroid(OGRGeometryH hGeom, OGRGeometryH hCentroidPoint)"
#~ msgstr ""

#~ msgid ""
#~ "The centroid location is applied to "
#~ "the passed in OGRPoint object. The "
#~ "centroid is not necessarily within the"
#~ " geometry."
#~ msgstr ""

#~ msgid ""
#~ "This method relates to the SFCOM "
#~ "ISurface::get_Centroid() method however the "
#~ "current implementation based on GEOS can"
#~ " operate on other geometry types such"
#~ " as multipoint, linestring, geometrycollection"
#~ " such as multipolygons. OGC SF SQL"
#~ " 1.1 defines the operation for "
#~ "surfaces (polygons). SQL/MM-Part 3 "
#~ "defines the operation for surfaces and"
#~ " multisurfaces (multipolygons)."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Centroid()."
#~ msgstr ""

#~ msgid "OGRERR_NONE on success or OGRERR_FAILURE on error."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_Clone(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "This function relates to the SFCOM IGeometry::clone() method."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::clone()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to clone from."
#~ msgstr ""

#~ msgid ""
#~ "a handle on the copy of the "
#~ "geometry with the spatial reference "
#~ "system as the original."
#~ msgstr ""

#~ msgid "void OGR_G_CloseRings(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "If this geometry, or any contained "
#~ "geometries has polygon rings that are"
#~ " not closed, they will be closed "
#~ "by adding the starting point at "
#~ "the end."
#~ msgstr ""

#~ msgid "hGeom:  handle to the geometry."
#~ msgstr ""

#~ msgid "int OGR_G_Contains(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "Tests if this geometry contains the other geometry."
#~ msgstr ""

#~ msgid ""
#~ "Geometry validity is not checked. In "
#~ "case you are unsure of the "
#~ "validity of the input geometries, call"
#~ " IsValid() before, otherwise the result "
#~ "might be wrong."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Contains()."
#~ msgstr ""

#~ msgid "hThis:  the geometry to compare."
#~ msgstr ""

#~ msgid "hOther:  the other geometry to compare."
#~ msgstr ""

#~ msgid "TRUE if hThis contains hOther geometry, otherwise FALSE."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_ConvexHull(OGRGeometryH hTarget)"
#~ msgstr ""

#~ msgid ""
#~ "A new geometry object is created "
#~ "and returned containing the convex hull"
#~ " of the geometry on which the "
#~ "method is invoked."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::ConvexHull()."
#~ msgstr ""

#~ msgid "hTarget:  The Geometry to calculate the convex hull of."
#~ msgstr ""

#~ msgid "int OGR_G_CoordinateDimension(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::CoordinateDimension()."
#~ msgstr ""

#~ msgid ""
#~ "hGeom:  handle on the geometry to "
#~ "get the dimension of the coordinates "
#~ "from."
#~ msgstr ""

#~ msgid "this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data."
#~ msgstr ""

#~ msgid "int OGR_G_Crosses(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "Tests if this geometry and the other geometry are crossing."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Crosses()."
#~ msgstr ""

#~ msgid "TRUE if they are crossing, otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OGRGeometryH OGR_G_DelaunayTriangulation(OGRGeometryH "
#~ "hThis, double dfTolerance, int bOnlyEdges)"
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRGeometry::DelaunayTriangulation()."
#~ msgstr ""

#~ msgid ""
#~ "This function is built on the GEOS"
#~ " library, v3.4 or above. If OGR "
#~ "is built without the GEOS library, "
#~ "this function will always fail, issuing"
#~ " a CPLE_NotSupported error."
#~ msgstr ""

#~ msgid "hThis:  the geometry."
#~ msgstr ""

#~ msgid ""
#~ "dfTolerance:  optional snapping tolerance to"
#~ " use for improved robustness"
#~ msgstr ""

#~ msgid ""
#~ "bOnlyEdges:  if TRUE, will return a "
#~ "MULTILINESTRING, otherwise it will return "
#~ "a GEOMETRYCOLLECTION containing triangular "
#~ "POLYGONs."
#~ msgstr ""

#~ msgid ""
#~ "the geometry resulting from the Delaunay"
#~ " triangulation or NULL if an error"
#~ " occurs."
#~ msgstr ""

#~ msgid "OGR 2.1"
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_Difference(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "Generates a new geometry which is "
#~ "the region of this geometry with "
#~ "the region of the other geometry "
#~ "removed."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Difference()."
#~ msgstr ""

#~ msgid "hOther:  the other geometry."
#~ msgstr ""

#~ msgid ""
#~ "a new geometry representing the "
#~ "difference or NULL if the difference "
#~ "is empty or an error occurs."
#~ msgstr ""

#~ msgid "int OGR_G_Disjoint(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "Tests if this geometry and the other geometry are disjoint."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Disjoint()."
#~ msgstr ""

#~ msgid "TRUE if they are disjoint, otherwise FALSE."
#~ msgstr ""

#~ msgid "double OGR_G_Distance(OGRGeometryH hFirst, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "Returns the shortest distance between "
#~ "the two geometries. The distance is "
#~ "expressed into the same unit as "
#~ "the coordinates of the geometries."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Distance()."
#~ msgstr ""

#~ msgid "hFirst:  the first geometry to compare against."
#~ msgstr ""

#~ msgid "hOther:  the other geometry to compare against."
#~ msgstr ""

#~ msgid "the distance between the geometries or -1 if an error occurs."
#~ msgstr ""

#~ msgid "double OGR_G_Distance3D(OGRGeometryH hFirst, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "The distance is expressed into the "
#~ "same unit as the coordinates of "
#~ "the geometries."
#~ msgstr ""

#~ msgid ""
#~ "This method is built on the SFCGAL"
#~ " library, check it for the definition"
#~ " of the geometry operation. If OGR"
#~ " is built without the SFCGAL library,"
#~ " this method will always return -1.0"
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Distance3D()."
#~ msgstr ""

#~ msgid "distance between the two geometries"
#~ msgstr ""

#~ msgid "void OGR_G_Empty(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This restores the geometry to its "
#~ "initial state after construction, and "
#~ "before assignment of actual geometry."
#~ msgstr ""

#~ msgid "This function relates to the SFCOM IGeometry::Empty() method."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::empty()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to empty."
#~ msgstr ""

#~ msgid "int OGR_G_Equals(OGRGeometryH hGeom, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "Returns TRUE if two geometries are equivalent."
#~ msgstr ""

#~ msgid "This operation implements the SQL/MM ST_OrderingEquals() operation."
#~ msgstr ""

#~ msgid ""
#~ "The comparison is done in a "
#~ "structural way, that is to say "
#~ "that the geometry types must be "
#~ "identical, as well as the number "
#~ "and ordering of sub-geometries and "
#~ "vertices. Or equivalently, two geometries "
#~ "are considered equal by this method "
#~ "if their WKT/WKB representation is "
#~ "equal. Note: this must be distinguished"
#~ " for equality in a spatial way "
#~ "(which is the purpose of the "
#~ "ST_Equals() operation)."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::Equals() method."
#~ msgstr ""

#~ msgid "hGeom:  handle on the first geometry."
#~ msgstr ""

#~ msgid "hOther:  handle on the other geometry to test against."
#~ msgstr ""

#~ msgid "TRUE if equivalent or FALSE otherwise."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_G_ExportToIsoWkb(OGRGeometryH hGeom, "
#~ "OGRwkbByteOrder eOrder, unsigned char "
#~ "*pabyDstBuffer)"
#~ msgstr ""

#~ msgid ""
#~ "This function relates to the SFCOM "
#~ "IWks::ExportToWKB() method. It exports the "
#~ "SFSQL 1.2 and ISO SQL/MM Part 3"
#~ " extended dimension (Z&M) WKB types."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::exportToWkb(OGRwkbByteOrder,"
#~ " unsigned char *, OGRwkbVariant) with "
#~ "eWkbVariant = wkbVariantIso."
#~ msgstr ""

#~ msgid ""
#~ "hGeom:  handle on the geometry to "
#~ "convert to a well know binary data"
#~ " from."
#~ msgstr ""

#~ msgid ""
#~ "eOrder:  One of wkbXDR or wkbNDR "
#~ "indicating MSB or LSB byte order "
#~ "respectively."
#~ msgstr ""

#~ msgid ""
#~ "pabyDstBuffer:  a buffer into which the"
#~ " binary representation is written. This "
#~ "buffer must be at least OGR_G_WkbSize()"
#~ " byte in size."
#~ msgstr ""

#~ msgid "Currently OGRERR_NONE is always returned."
#~ msgstr ""

#~ msgid "OGRErr OGR_G_ExportToIsoWkt(OGRGeometryH hGeom, char **ppszSrcText)"
#~ msgstr ""

#~ msgid ""
#~ "This function relates to the SFCOM "
#~ "IWks::ExportToWKT() method. It exports the "
#~ "SFSQL 1.2 and ISO SQL/MM Part 3"
#~ " extended dimension (Z&M) WKB types."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::exportToWkt(wkbVariantIso)."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to convert to a text format from."
#~ msgstr ""

#~ msgid ""
#~ "ppszSrcText:  a text buffer is allocated"
#~ " by the program, and assigned to "
#~ "the passed pointer. After use, "
#~ "*ppszDstText should be freed with "
#~ "CPLFree()."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_G_ExportToWkb(OGRGeometryH hGeom, "
#~ "OGRwkbByteOrder eOrder, unsigned char "
#~ "*pabyDstBuffer)"
#~ msgstr ""

#~ msgid "This function relates to the SFCOM IWks::ExportToWKB() method."
#~ msgstr ""

#~ msgid ""
#~ "For backward compatibility purposes, it "
#~ "exports the Old-style 99-402 extended"
#~ " dimension (Z) WKB types for types"
#~ " Point, LineString, Polygon, MultiPoint, "
#~ "MultiLineString, MultiPolygon and "
#~ "GeometryCollection. For other geometry types,"
#~ " it is equivalent to "
#~ "OGR_G_ExportToIsoWkb()."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::exportToWkb(OGRwkbByteOrder,"
#~ " unsigned char *, OGRwkbVariant) with "
#~ "eWkbVariant = wkbVariantOldOgc."
#~ msgstr ""

#~ msgid "OGRErr OGR_G_ExportToWkt(OGRGeometryH hGeom, char **ppszSrcText)"
#~ msgstr ""

#~ msgid "This function relates to the SFCOM IWks::ExportToWKT() method."
#~ msgstr ""

#~ msgid ""
#~ "For backward compatibility purposes, it "
#~ "exports the Old-style 99-402 extended"
#~ " dimension (Z) WKB types for types"
#~ " Point, LineString, Polygon, MultiPoint, "
#~ "MultiLineString, MultiPolygon and "
#~ "GeometryCollection. For other geometry types,"
#~ " it is equivalent to "
#~ "OGR_G_ExportToIsoWkt()."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::exportToWkt()."
#~ msgstr ""

#~ msgid "void OGR_G_FlattenTo2D(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "In a sense this converts all Z coordinates to 0.0."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::flattenTo2D()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to convert."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_GetBoundary(OGRGeometryH hTarget)"
#~ msgstr ""

#~ msgid "See:   OGR_G_Boundary()"
#~ msgstr ""

#~ msgid "int OGR_G_GetCoordinateDimension(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::getCoordinateDimension()."
#~ msgstr ""

#~ msgid ""
#~ "Deprecated use OGR_G_CoordinateDimension(), "
#~ "OGR_G_Is3D(), or OGR_G_IsMeasured()."
#~ msgstr ""

#~ msgid "this will return 2 or 3."
#~ msgstr ""

#~ msgid "int OGR_G_GetDimension(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This function corresponds to the SFCOM"
#~ " IGeometry::GetDimension() method. It indicates"
#~ " the dimension of the geometry, but"
#~ " does not indicate the dimension of"
#~ " the underlying space (as indicated "
#~ "by OGR_G_GetCoordinateDimension() function)."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::getDimension()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to get the dimension from."
#~ msgstr ""

#~ msgid "0 for points, 1 for lines and 2 for surfaces."
#~ msgstr ""

#~ msgid "void OGR_G_GetEnvelope(OGRGeometryH hGeom, OGREnvelope *psEnvelope)"
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::getEnvelope()."
#~ msgstr ""

#~ msgid "hGeom:  handle of the geometry to get envelope from."
#~ msgstr ""

#~ msgid "psEnvelope:  the structure in which to place the results."
#~ msgstr ""

#~ msgid "void OGR_G_GetEnvelope3D(OGRGeometryH hGeom, OGREnvelope3D *psEnvelope)"
#~ msgstr ""

#~ msgid "const char* OGR_G_GetGeometryName(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "There is no SFCOM analog to this function."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::getGeometryName()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to get name from."
#~ msgstr ""

#~ msgid "name used for this geometry type in well known text format."
#~ msgstr ""

#~ msgid "OGRwkbGeometryType OGR_G_GetGeometryType(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "Note that the geometry type may "
#~ "include the 2.5D flag. To get a"
#~ " 2D flattened version of the geometry"
#~ " type apply the wkbFlatten() macro to"
#~ " the return result."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::getGeometryType()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to get type from."
#~ msgstr ""

#~ msgid "the geometry type code."
#~ msgstr ""

#~ msgid "OGRSpatialReferenceH OGR_G_GetSpatialReference(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This function relates to the SFCOM "
#~ "IGeometry::get_SpatialReference() method."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " CPP method OGRGeometry::getSpatialReference()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to get spatial reference from."
#~ msgstr ""

#~ msgid "a reference to the spatial reference geometry."
#~ msgstr ""

#~ msgid ""
#~ "OGRGeometryH OGR_G_Intersection(OGRGeometryH hThis, "
#~ "OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "Generates a new geometry which is "
#~ "the region of intersection of the "
#~ "two geometries operated on. The "
#~ "OGR_G_Intersects() function can be used "
#~ "to test if two geometries intersect."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRGeometry::Intersection()."
#~ msgstr ""

#~ msgid ""
#~ "a new geometry representing the "
#~ "intersection or NULL if there is "
#~ "no intersection or an error occurs."
#~ msgstr ""

#~ msgid "int OGR_G_Intersects(OGRGeometryH hGeom, OGRGeometryH hOtherGeom)"
#~ msgstr ""

#~ msgid "Do these features intersect?"
#~ msgstr ""

#~ msgid ""
#~ "Determines whether two geometries intersect."
#~ " If GEOS is enabled, then this "
#~ "is done in rigorous fashion otherwise"
#~ " TRUE is returned if the envelopes"
#~ " (bounding boxes) of the two "
#~ "geometries overlap."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::Intersects."
#~ msgstr ""

#~ msgid "hOtherGeom:  handle on the other geometry to test against."
#~ msgstr ""

#~ msgid "TRUE if the geometries intersect, otherwise FALSE."
#~ msgstr ""

#~ msgid "int OGR_G_Is3D(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::Is3D()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to check whether it has Z coordinates."
#~ msgstr ""

#~ msgid "TRUE if the geometry has Z coordinates."
#~ msgstr ""

#~ msgid "int OGR_G_IsEmpty(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "This method is the same as the CPP method OGRGeometry::IsEmpty()."
#~ msgstr ""

#~ msgid "hGeom:  The Geometry to test."
#~ msgstr ""

#~ msgid "TRUE if the geometry has no points, otherwise FALSE."
#~ msgstr ""

#~ msgid "int OGR_G_IsMeasured(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::IsMeasured()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to check whether it is measured."
#~ msgstr ""

#~ msgid "TRUE if the geometry has M coordinates."
#~ msgstr ""

#~ msgid "int OGR_G_IsRing(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::IsRing()."
#~ msgstr ""

#~ msgid ""
#~ "This function is built on the GEOS"
#~ " library, check it for the definition"
#~ " of the geometry operation. If OGR"
#~ " is built without the GEOS library,"
#~ " this function will always return "
#~ "FALSE."
#~ msgstr ""

#~ msgid "int OGR_G_IsSimple(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "Returns TRUE if the geometry is simple."
#~ msgstr ""

#~ msgid ""
#~ "Returns TRUE if the geometry has "
#~ "no anomalous geometric points, such as"
#~ " self intersection or self tangency. "
#~ "The description of each instantiable "
#~ "geometric class will include the "
#~ "specific conditions that cause an "
#~ "instance of that class to be "
#~ "classified as not simple."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRGeometry::IsSimple() method."
#~ msgstr ""

#~ msgid ""
#~ "If OGR is built without the GEOS"
#~ " library, this function will always "
#~ "return FALSE."
#~ msgstr ""

#~ msgid "TRUE if object is simple, otherwise FALSE."
#~ msgstr ""

#~ msgid "int OGR_G_IsValid(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::IsValid()."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_MakeValid(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "Already-valid geometries are cloned without further intervention."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::MakeValid()."
#~ msgstr ""

#~ msgid ""
#~ "This function is built on the GEOS"
#~ " >= 3.8 library, check it for "
#~ "the definition of the geometry "
#~ "operation. If OGR is built without "
#~ "the GEOS >= 3.8 library, this "
#~ "function will return a clone of "
#~ "the input geometry if it is valid,"
#~ " or NULL if it is invalid"
#~ msgstr ""

#~ msgid "hGeom:  The Geometry to make valid."
#~ msgstr ""

#~ msgid "a newly allocated geometry now owned by the caller, or NULL on failure."
#~ msgstr ""

#~ msgid "GDAL 3.0"
#~ msgstr ""

#~ msgid "int OGR_G_Overlaps(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "Tests if this geometry and the "
#~ "other geometry overlap, that is their"
#~ " intersection has a non-zero area."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Overlaps()."
#~ msgstr ""

#~ msgid "TRUE if they are overlapping, otherwise FALSE."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_PointOnSurface(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This method relates to the SFCOM "
#~ "ISurface::get_PointOnSurface() method however the"
#~ " current implementation based on GEOS "
#~ "can operate on other geometry types "
#~ "than the types that are supported "
#~ "by SQL/MM-Part 3 : surfaces "
#~ "(polygons) and multisurfaces (multipolygons)."
#~ msgstr ""

#~ msgid ""
#~ "This method is built on the GEOS"
#~ " library, check it for the definition"
#~ " of the geometry operation. If OGR"
#~ " is built without the GEOS library,"
#~ " this method will always fail, "
#~ "issuing a CPLE_NotSupported error."
#~ msgstr ""

#~ msgid "hGeom:  the geometry to operate on."
#~ msgstr ""

#~ msgid "a point guaranteed to lie on the surface or NULL if an error occurred."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_Polygonize(OGRGeometryH hTarget)"
#~ msgstr ""

#~ msgid ""
#~ "A new geometry object is created "
#~ "and returned containing a collection of"
#~ " reassembled Polygons: NULL will be "
#~ "returned if the input collection doesn't"
#~ " corresponds to a MultiLinestring, or "
#~ "when reassembling Edges into Polygons is"
#~ " impossible due to topological "
#~ "inconsistencies."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Polygonize()."
#~ msgstr ""

#~ msgid "hTarget:  The Geometry to be polygonized."
#~ msgstr ""

#~ msgid "void OGR_G_Segmentize(OGRGeometryH hGeom, double dfMaxLength)"
#~ msgstr ""

#~ msgid ""
#~ "Interpolated points will have Z and "
#~ "M values (if needed) set to 0. "
#~ "Distance computation is performed in 2d"
#~ " only."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::segmentize()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to segmentize"
#~ msgstr ""

#~ msgid ""
#~ "dfMaxLength:  the maximum distance between "
#~ "2 points after segmentization"
#~ msgstr ""

#~ msgid "void OGR_G_Set3D(OGRGeometryH hGeom, int bIs3D)"
#~ msgstr ""

#~ msgid ""
#~ "This method adds or removes the "
#~ "explicit Z coordinate dimension. Removing "
#~ "the Z coordinate dimension of a "
#~ "geometry will remove any existing Z "
#~ "values. Adding the Z dimension to "
#~ "a geometry collection, a compound curve,"
#~ " a polygon, etc. will affect the "
#~ "children geometries."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to set or unset the Z dimension."
#~ msgstr ""

#~ msgid "bIs3D:  Should the geometry have a Z dimension, either TRUE or FALSE."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_G_SetCoordinateDimension(OGRGeometryH hGeom, "
#~ "int nNewDimension)"
#~ msgstr ""

#~ msgid ""
#~ "This method sets the explicit coordinate"
#~ " dimension. Setting the coordinate "
#~ "dimension of a geometry to 2 "
#~ "should zero out any existing Z "
#~ "values. Setting the dimension of a "
#~ "geometry collection, a compound curve, a"
#~ " polygon, etc. will affect the "
#~ "children geometries. This will also "
#~ "remove the M dimension if present "
#~ "before this call."
#~ msgstr ""

#~ msgid "Deprecated use OGR_G_Set3D() or OGR_G_SetMeasured()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to set the dimension of the coordinates."
#~ msgstr ""

#~ msgid "nNewDimension:  New coordinate dimension value, either 2 or 3."
#~ msgstr ""

#~ msgid "void OGR_G_SetMeasured(OGRGeometryH hGeom, int bIsMeasured)"
#~ msgstr ""

#~ msgid ""
#~ "This method adds or removes the "
#~ "explicit M coordinate dimension. Removing "
#~ "the M coordinate dimension of a "
#~ "geometry will remove any existing M "
#~ "values. Adding the M dimension to "
#~ "a geometry collection, a compound curve,"
#~ " a polygon, etc. will affect the "
#~ "children geometries."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to set or unset the M dimension."
#~ msgstr ""

#~ msgid ""
#~ "bIsMeasured:  Should the geometry have a"
#~ " M dimension, either TRUE or FALSE."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_Simplify(OGRGeometryH hThis, double dTolerance)"
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Simplify()."
#~ msgstr ""

#~ msgid "dTolerance:  the distance tolerance for the simplification."
#~ msgstr ""

#~ msgid "the simplified geometry or NULL if an error occurs."
#~ msgstr ""

#~ msgid ""
#~ "OGRGeometryH OGR_G_SimplifyPreserveTopology(OGRGeometryH "
#~ "hThis, double dTolerance)"
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRGeometry::SimplifyPreserveTopology()."
#~ msgstr ""

#~ msgid "void OGR_G_SwapXY(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid "hGeom:  geometry."
#~ msgstr ""

#~ msgid "OGR 2.3.0"
#~ msgstr ""

#~ msgid ""
#~ "OGRGeometryH OGR_G_SymDifference(OGRGeometryH hThis, "
#~ "OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "Generates a new geometry which is "
#~ "the symmetric difference of this "
#~ "geometry and the other geometry."
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRGeometry::SymmetricDifference()."
#~ msgstr ""

#~ msgid ""
#~ "a new geometry representing the "
#~ "symmetric difference or NULL if the "
#~ "difference is empty or an error "
#~ "occurs."
#~ msgstr ""

#~ msgid ""
#~ "OGRGeometryH OGR_G_SymmetricDifference(OGRGeometryH hThis,"
#~ " OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "See:  OGR_G_SymmetricDifference()"
#~ msgstr ""

#~ msgid "int OGR_G_Touches(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "Tests if this geometry and the other geometry are touching."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Touches()."
#~ msgstr ""

#~ msgid "TRUE if they are touching, otherwise FALSE."
#~ msgstr ""

#~ msgid ""
#~ "OGRErr OGR_G_Transform(OGRGeometryH hGeom, "
#~ "OGRCoordinateTransformationH hTransform)"
#~ msgstr ""

#~ msgid ""
#~ "This function will transform the "
#~ "coordinates of a geometry from their "
#~ "current spatial reference system to a"
#~ " new target spatial reference system. "
#~ "Normally this means reprojecting the "
#~ "vectors, but it could include datum "
#~ "shifts, and changes of units."
#~ msgstr ""

#~ msgid ""
#~ "Note that this function does not "
#~ "require that the geometry already have"
#~ " a spatial reference system. It will"
#~ " be assumed that they can be "
#~ "treated as having the source spatial "
#~ "reference system of the "
#~ "OGRCoordinateTransformation object, and the "
#~ "actual SRS of the geometry will be"
#~ " ignored. On successful completion the "
#~ "output OGRSpatialReference of the "
#~ "OGRCoordinateTransformation will be assigned "
#~ "to the geometry."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::transform."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to apply the transform to."
#~ msgstr ""

#~ msgid "hTransform:  handle on the transformation to apply."
#~ msgstr ""

#~ msgid "OGRErr OGR_G_TransformTo(OGRGeometryH hGeom, OGRSpatialReferenceH hSRS)"
#~ msgstr ""

#~ msgid ""
#~ "This function will only work if "
#~ "the geometry already has an assigned "
#~ "spatial reference system, and if it "
#~ "is transformable to the target "
#~ "coordinate system."
#~ msgstr ""

#~ msgid ""
#~ "Because this function requires internal "
#~ "creation and initialization of an "
#~ "OGRCoordinateTransformation object it is "
#~ "significantly more expensive to use this"
#~ " function to transform many geometries "
#~ "than it is to create the "
#~ "OGRCoordinateTransformation in advance, and "
#~ "call transform() with that transformation. "
#~ "This function exists primarily for "
#~ "convenience when only transforming a "
#~ "single geometry."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::transformTo."
#~ msgstr ""

#~ msgid "hSRS:  handle on the spatial reference system to apply."
#~ msgstr ""

#~ msgid "OGRERR_NONE on success, or an error code."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_Union(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid ""
#~ "Generates a new geometry which is "
#~ "the region of union of the two "
#~ "geometries operated on."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Union()."
#~ msgstr ""

#~ msgid "a new geometry representing the union or NULL if an error occurs."
#~ msgstr ""

#~ msgid "OGRGeometryH OGR_G_UnionCascaded(OGRGeometryH hThis)"
#~ msgstr ""

#~ msgid ""
#~ "This function is the same as the"
#~ " C++ method OGRGeometry::UnionCascaded()."
#~ msgstr ""

#~ msgid "int OGR_G_Within(OGRGeometryH hThis, OGRGeometryH hOther)"
#~ msgstr ""

#~ msgid "Tests if this geometry is within the other geometry."
#~ msgstr ""

#~ msgid "This function is the same as the C++ method OGRGeometry::Within()."
#~ msgstr ""

#~ msgid "TRUE if hThis is within hOther, otherwise FALSE."
#~ msgstr ""

#~ msgid "int OGR_G_WkbSize(OGRGeometryH hGeom)"
#~ msgstr ""

#~ msgid ""
#~ "This function returns the exact number"
#~ " of bytes required to hold the "
#~ "well known binary representation of this"
#~ " geometry object. Its computation may "
#~ "be slightly expensive for complex "
#~ "geometries."
#~ msgstr ""

#~ msgid "This function relates to the SFCOM IWks::WkbSize() method."
#~ msgstr ""

#~ msgid "This function is the same as the CPP method OGRGeometry::WkbSize()."
#~ msgstr ""

#~ msgid "hGeom:  handle on the geometry to get the binary size from."
#~ msgstr ""

#~ msgid "size of binary representation in bytes."
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the feature definition"
#~ " to add the field definition to."
#~ msgstr ""

#~ msgid "hNewField:  handle to the new field definition."
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the feature definition"
#~ " to add the geometry field definition"
#~ " to."
#~ msgstr ""

#~ msgid "hNewGeomField:  handle to the new field definition."
#~ msgstr ""

#~ msgid "hDefn:  handle to the feature definition."
#~ msgstr ""

#~ msgid "iGeomField:  the index of the geometry field definition."
#~ msgstr ""

#~ msgid "hDefn:  handle to the feature definition to get the fields count from."
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the feature definition"
#~ " to get the field definition from."
#~ msgstr ""

#~ msgid "iField:  the field to fetch, between 0 and GetFieldCount()-1."
#~ msgstr ""

#~ msgid ""
#~ "int OGR_FD_GetFieldIndex(OGRFeatureDefnH hDefn, "
#~ "const char *pszFieldName)"
#~ msgstr ""

#~ msgid "hDefn:  handle to the feature definition to get field index from."
#~ msgstr ""

#~ msgid "pszFieldName:  the field name to search for."
#~ msgstr ""

#~ msgid ""
#~ "iGeomField:  the geometry field to "
#~ "fetch, between 0 and GetGeomFieldCount() "
#~ "- 1."
#~ msgstr ""

#~ msgid ""
#~ "int OGR_FD_GetGeomFieldIndex(OGRFeatureDefnH hDefn, "
#~ "const char *pszGeomFieldName)"
#~ msgstr ""

#~ msgid "pszGeomFieldName:  the geometry field name to search for."
#~ msgstr ""

#~ msgid "hDefn:  handle to the feature definition to get the geometry type from."
#~ msgstr ""

#~ msgid "const char* OGR_FD_GetName(OGRFeatureDefnH hDefn)"
#~ msgstr ""

#~ msgid "hDefn:  handle to the feature definition to get the name from."
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the feature definition"
#~ " on witch OGRFeature are based on."
#~ msgstr ""

#~ msgid ""
#~ "hFDefn:  handle to the feature "
#~ "definition on witch OGRFeature are based"
#~ " on."
#~ msgstr ""

#~ msgid "hOtherFDefn:  handle to the other feature definition to compare to."
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the feature definition"
#~ " on which OGRFeature are based on."
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the layer or "
#~ "feature definition to set the geometry"
#~ " type to."
#~ msgstr ""

#~ msgid "eType:  the new type to assign."
#~ msgstr ""

#~ msgid "bIgnore:  ignore state"
#~ msgstr ""

#~ msgid "const char* OGR_Fld_GetAlternativeNameRef(OGRFieldDefnH hDefn)"
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition."
#~ msgstr ""

#~ msgid "GDAL 3.2"
#~ msgstr ""

#~ msgid "const char* OGR_Fld_GetDefault(OGRFieldDefnH hDefn)"
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to get justification from."
#~ msgstr ""

#~ msgid "const char* OGR_Fld_GetNameRef(OGRFieldDefnH hDefn)"
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to get precision from."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to get subtype from."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to get type from."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to get width from."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition"
#~ msgstr ""

#~ msgid ""
#~ "Even if this method returns FALSE "
#~ "(i.e not-nullable field), it doesn't "
#~ "mean that OGRFeature::IsFieldSet() will "
#~ "necessary return TRUE, as fields can "
#~ "be temporary unset and null /not-"
#~ "null validation is usually done when "
#~ "OGRLayer::CreateFeature()/SetFeature() is called."
#~ msgstr ""

#~ msgid ""
#~ "void OGR_Fld_SetAlternativeName(OGRFieldDefnH hDefn, "
#~ "const char *pszAlternativeName)"
#~ msgstr ""

#~ msgid ""
#~ "hDefn:  handle to the field definition"
#~ " to apply the new alternative name"
#~ " to."
#~ msgstr ""

#~ msgid "pszAlternativeName:  the new alternative name to apply."
#~ msgstr ""

#~ msgid "void OGR_Fld_SetDefault(OGRFieldDefnH hDefn, const char *pszDefault)"
#~ msgstr ""

#~ msgid "pszDefault:  new default field value or NULL pointer."
#~ msgstr ""

#~ msgid "ignore:  ignore state"
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to set justification to."
#~ msgstr ""

#~ msgid "eJustify:  the new justification."
#~ msgstr ""

#~ msgid "void OGR_Fld_SetName(OGRFieldDefnH hDefn, const char *pszName)"
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to apply the new name to."
#~ msgstr ""

#~ msgid "pszName:  the new name to apply."
#~ msgstr ""

#~ msgid "bNullableIn:  FALSE if the field must have a not-null constraint."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to set precision to."
#~ msgstr ""

#~ msgid "nPrecision:  the new precision."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to set type to."
#~ msgstr ""

#~ msgid "eSubType:  the new field subtype."
#~ msgstr ""

#~ msgid "eType:  the new field type."
#~ msgstr ""

#~ msgid "bUniqueIn:  TRUE if the field must have a unique constraint."
#~ msgstr ""

#~ msgid "hDefn:  handle to the field definition to set width to."
#~ msgstr ""

#~ msgid "nNewWidth:  the new width."
#~ msgstr ""

#~ msgid "::"
#~ msgstr ""

#~ msgid ""
#~ "pip install --no-cache --force-reinstall"
#~ " gdal[numpy]==\"$(gdal-config --version).*\""
#~ msgstr ""

